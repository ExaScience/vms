typedef long int ptrdiff_t;
typedef unsigned long int size_t;
struct  max_align_t
{
    __attribute__((aligned(alignof(long long int)))) long long int __max_align_ll;
    __attribute__((aligned(alignof(long double)))) long double __max_align_ld;
};
typedef decltype(nullptr) nullptr_t;
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
struct  nanos_region_dimension_internal_t
{
    ::size_t size;
    ::size_t lower_bound;
    ::size_t accessed_length;
};
struct  nanos_access_type_internal_t
{
    bool input:1;
    bool output:1;
    bool can_rename:1;
    bool concurrent:1;
    bool commutative:1;
};
struct  nanos_data_access_internal_t
{
    void *address;
    ::nanos_access_type_internal_t flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
};
enum nanos_sharing_t
{
  NANOS_PRIVATE = 0,
  NANOS_SHARED = 1
};
struct  nanos_reduction_t
{
    void *original;
    void *privates;
    ::size_t element_size;
    ::size_t num_scalars;
    void *descriptor;
    void (*bop)(void *, void *, int);
    void (*vop)(int, void *, void *);
    void (*cleanup)(void *);
};
typedef unsigned int reg_t;
typedef unsigned int memory_space_id_t;
struct  nanos_copy_data_internal_t
{
    void *address;
    ::nanos_sharing_t sharing;
    struct  mcc_struct_anon_46
    {
        bool input:1;
        bool output:1;
    };
    ::nanos_copy_data_internal_t::mcc_struct_anon_46 flags;
    short int dimension_count;
    const ::nanos_region_dimension_internal_t *dimensions;
    ::ptrdiff_t offset;
    ::uint64_t host_base_address;
    ::reg_t host_region_id;
    bool remote_host;
    void *deducted_cd;
};
typedef ::nanos_access_type_internal_t nanos_access_type_t;
typedef ::nanos_region_dimension_internal_t nanos_region_dimension_t;
typedef ::nanos_data_access_internal_t nanos_data_access_t;
typedef ::nanos_copy_data_internal_t nanos_copy_data_t;
typedef void *nanos_thread_t;
typedef void *nanos_wd_t;
typedef void *nanos_pe_t;
struct  nanos_compound_wd_data_t
{
    int nsect;
    ::nanos_wd_t lwd[];
};
struct  nanos_repeat_n_info_t
{
    int n;
};
struct  nanos_loop_info_t
{
    ::int64_t lower;
    ::int64_t upper;
    ::int64_t step;
    bool last;
    bool wait;
    ::int64_t chunk;
    ::int64_t stride;
    int thid;
    int threads;
    void *args;
};
typedef void *nanos_ws_t;
typedef void *nanos_ws_info_t;
typedef void *nanos_ws_data_t;
typedef void *nanos_ws_item_t;
struct  nanos_ws_info_loop_t
{
    ::int64_t lower_bound;
    ::int64_t upper_bound;
    ::int64_t loop_step;
    ::int64_t chunk_size;
};
struct  nanos_ws_item_loop_t
{
    ::int64_t lower;
    ::int64_t upper;
    bool execute:1;
    bool last:1;
};
struct nanos_ws_desc;
struct  nanos_ws_desc
{
    volatile ::nanos_ws_t ws;
    ::nanos_ws_data_t data;
    ::nanos_ws_desc *next;
    ::nanos_thread_t *threads;
    int nths;
};
typedef ::nanos_ws_desc nanos_ws_desc_t;
struct  nanos_wd_props_t
{
    bool mandatory_creation:1;
    bool tied:1;
    bool clear_chunk:1;
    bool reserved0:1;
    bool reserved1:1;
    bool reserved2:1;
    bool reserved3:1;
    bool reserved4:1;
};
struct  nanos_wd_dyn_flags_t
{
    bool is_final:1;
    bool is_recover:1;
    bool is_implicit:1;
    bool reserved3:1;
    bool reserved4:1;
    bool reserved5:1;
    bool reserved6:1;
    bool reserved7:1;
};
struct  nanos_wd_dyn_props_t
{
    ::nanos_wd_dyn_flags_t flags;
    ::nanos_thread_t tie_to;
    int priority;
    void *callback;
    void *arguments;
};
struct  nanos_device_t
{
    void *(*factory)(void *);
    void *arg;
};
struct  nanos_smp_args_t
{
    void (*outline)(void *);
};
extern "C"
{
  extern void *nanos_smp_factory_(void *args);
}
extern "C"
{
  extern void *nanos_smp_factory(void *args);
}
enum nanos_event_type_t
{
  NANOS_STATE_START = 0,
  NANOS_STATE_END = 1,
  NANOS_SUBSTATE_START = 2,
  NANOS_SUBSTATE_END = 3,
  NANOS_BURST_START = 4,
  NANOS_BURST_END = 5,
  NANOS_PTP_START = 6,
  NANOS_PTP_END = 7,
  NANOS_POINT = 8,
  EVENT_TYPES = 9
};
typedef unsigned int nanos_event_key_t;
typedef unsigned long long int nanos_event_value_t;
typedef unsigned long long int nanos_event_time_t;
enum nanos_event_state_value_t
{
  NANOS_NOT_CREATED = 0,
  NANOS_NOT_RUNNING = 1,
  NANOS_STARTUP = 2,
  NANOS_SHUTDOWN = 3,
  NANOS_ERROR = 4,
  NANOS_IDLE = 5,
  NANOS_RUNTIME = 6,
  NANOS_RUNNING = 7,
  NANOS_SYNCHRONIZATION = 8,
  NANOS_SCHEDULING = 9,
  NANOS_CREATION = 10,
  NANOS_MEM_TRANSFER_ISSUE = 11,
  NANOS_CACHE = 12,
  NANOS_YIELD = 13,
  NANOS_ACQUIRING_LOCK = 14,
  NANOS_CONTEXT_SWITCH = 15,
  NANOS_FILL1 = 16,
  NANOS_WAKINGUP = 17,
  NANOS_STOPPED = 18,
  NANOS_SYNCED_RUNNING = 19,
  NANOS_DEBUG = 20,
  NANOS_EVENT_STATE_TYPES = 21
};
enum nanos_event_domain_t
{
  NANOS_WD_DOMAIN = 0,
  NANOS_WD_DEPENDENCY = 1,
  NANOS_WAIT = 2,
  NANOS_XFER_DATA = 3,
  NANOS_XFER_REQ = 4,
  NANOS_WD_REMOTE = 5,
  NANOS_AM_WORK = 6,
  NANOS_AM_WORK_DONE = 7,
  NANOS_XFER_WAIT_REQ_PUT = 8,
  NANOS_XFER_FREE_TMP_BUFF = 9
};
typedef long long int nanos_event_id_t;
struct  nanos_event_t
{
    ::nanos_event_type_t type;
    ::nanos_event_key_t key;
    ::nanos_event_value_t value;
    ::nanos_event_domain_t domain;
    ::nanos_event_id_t id;
};
enum nanos_lock_state_t
{
  NANOS_LOCK_FREE = 0,
  NANOS_LOCK_BUSY = 1
};
struct  nanos_lock_t
{
    volatile ::nanos_lock_state_t state_;
    inline nanos_lock_t(::nanos_lock_state_t init  = (::NANOS_LOCK_FREE))
      : state_(init)
    {
    }
};
typedef void (*nanos_translate_args_t)(void *, ::nanos_wd_t);
typedef void nanos_init_func_t(void *);
struct  nanos_init_desc_t
{
    ::nanos_init_func_t (*func);
    void *data;
};
enum nanos_err_t
{
  NANOS_OK = 0,
  NANOS_UNKNOWN_ERR = 1,
  NANOS_UNIMPLEMENTED = 2,
  NANOS_ENOMEM = 3,
  NANOS_INVALID_PARAM = 4,
  NANOS_INVALID_REQUEST = 5
};
typedef void *nanos_wg_t;
typedef void *nanos_team_t;
typedef void *nanos_sched_t;
typedef void *nanos_slicer_t;
typedef void *nanos_dd_t;
typedef void *nanos_sync_cond_t;
typedef unsigned int nanos_copy_id_t;
struct  nanos_const_wd_definition_tag
{
    ::nanos_wd_props_t props;
    ::size_t data_alignment;
    ::size_t num_copies;
    ::size_t num_devices;
    ::size_t num_dimensions;
    const char *description;
};
typedef ::nanos_const_wd_definition_tag nanos_const_wd_definition_t;
struct  nanos_constraint_t
{
    int nthreads;
    void *arch;
};
typedef void *nanos_cpu_set_t;
typedef const void *const_nanos_cpu_set_t;
struct  nanos_const_wd_definition_internal_t : ::nanos_const_wd_definition_tag
{
    ::nanos_device_t devices[1L];
};
extern "C"
{
  extern char *nanos_get_mode_();
}
extern "C"
{
  extern char *nanos_get_mode();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd_();
}
extern "C"
{
  extern ::nanos_wd_t nanos_current_wd();
}
extern "C"
{
  extern int nanos_get_wd_id_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_id(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority_(::nanos_wd_t wd);
}
extern "C"
{
  extern int nanos_get_wd_priority(::nanos_wd_t wd);
}
extern "C"
{
  extern void nanos_set_wd_priority_(::nanos_wd_t wd, int p);
}
extern "C"
{
  extern void nanos_set_wd_priority(::nanos_wd_t wd, int p);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description_(const char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_wd_description(const char **description, ::nanos_wd_t wd);
}
extern "C"
{
  extern bool nanos_try_lock_pe_(::nanos_pe_t pe);
}
extern "C"
{
  extern bool nanos_try_lock_pe(::nanos_pe_t pe);
}
extern "C"
{
  extern void nanos_unlock_pe_(::nanos_pe_t pe);
}
extern "C"
{
  extern void nanos_unlock_pe(::nanos_pe_t pe);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer_(const char *slicer);
}
extern "C"
{
  extern ::nanos_slicer_t nanos_find_slicer(const char *slicer);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing_(const char *label);
}
extern "C"
{
  extern ::nanos_ws_t nanos_find_worksharing(const char *label);
}
extern "C"
{
  extern ::nanos_err_t nanos_find_smp_pe_(void *req, ::nanos_pe_t *pe);
}
extern "C"
{
  extern ::nanos_err_t nanos_find_smp_pe(void *req, ::nanos_pe_t *pe);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact_(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_compact(::nanos_wd_t *wd, ::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void **data, ::nanos_wg_t wg, ::nanos_copy_data_t **copies, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function_(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_translate_function(::nanos_wd_t wd, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd_(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_sliced_wd(::nanos_wd_t *uwd, ::size_t num_devices, ::nanos_device_t *devices, ::size_t outline_data_size, int outline_data_align, void **outline_data, ::nanos_wg_t uwg, ::nanos_slicer_t slicer, ::nanos_wd_props_t *props, ::nanos_wd_dyn_props_t *dyn_props, ::size_t num_copies, ::nanos_copy_data_t **copies, ::size_t num_dimensions, ::nanos_region_dimension_internal_t **dimensions);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit_(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_submit(::nanos_wd_t wd, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_outline_(::nanos_wd_t wd, ::nanos_pe_t pe);
}
extern "C"
{
  extern ::nanos_err_t nanos_outline(::nanos_wd_t wd, ::nanos_pe_t pe);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact_(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_wd_and_run_compact(::nanos_const_wd_definition_t *const_data, ::nanos_wd_dyn_props_t *dyn_props, ::size_t data_size, void *data, ::size_t num_data_accesses, ::nanos_data_access_t *data_accesses, ::nanos_copy_data_t *copies, ::nanos_region_dimension_internal_t *dimensions, ::nanos_translate_args_t translate_args);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for_();
}
extern "C"
{
  extern ::nanos_err_t nanos_create_for();
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data_(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_internal_wd_data(::nanos_wd_t wd, void *data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data_(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_internal_wd_data(::nanos_wd_t wd, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_yield_();
}
extern "C"
{
  extern ::nanos_err_t nanos_yield();
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data_(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_slicer_get_specific_data(::nanos_slicer_t slicer, void **data);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks_(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_ready_tasks(unsigned int *ready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks_(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_total_tasks(unsigned int *total_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks_(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_nonready_tasks(unsigned int *nonready_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks_(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_running_tasks(unsigned int *running_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks_(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_blocked_tasks(unsigned int *blocked_tasks);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final_(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_in_final(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_final(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_switch_to_thread_(unsigned int *thid);
}
extern "C"
{
  extern ::nanos_err_t nanos_switch_to_thread(unsigned int *thid);
}
extern "C"
{
  extern ::nanos_err_t nanos_is_tied_(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_is_tied(bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info, ::nanos_const_wd_definition_t *const_data);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, ::nanos_constraint_t *constraints, bool reuse, ::nanos_thread_t *info, ::nanos_const_wd_definition_t *const_data);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped_(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_team_mapped(::nanos_team_t *team, ::nanos_sched_t sg, unsigned int *nthreads, unsigned int *mapping);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team_();
}
extern "C"
{
  extern ::nanos_err_t nanos_leave_team();
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team_(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_end_team(::nanos_team_t team);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_barrier();
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_single_guard(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init_(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_enter_sync_init(bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init_();
}
extern "C"
{
  extern ::nanos_err_t nanos_release_sync_init();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence_();
}
extern "C"
{
  extern ::nanos_err_t nanos_memory_fence();
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads_(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_num_supporting_threads(int *n);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads_(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_team_get_supporting_threads(int *n, ::nanos_thread_t *list_of_threads);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction_(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_reduction(::nanos_reduction_t *red);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data_(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_private_data(void **copy, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get_(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_reduction_get(::nanos_reduction_t **dest, void *original);
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_register_(void *orig, ::size_t size_target, ::size_t size_elem, void (*init)(void *, void *), void (*reducer)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_register(void *orig, ::size_t size_target, ::size_t size_elem, void (*init)(void *, void *), void (*reducer)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_fortran_array_reduction_register_(void *orig, void *dep, ::size_t array_descriptor_size, void (*init)(void *, void *), void (*reducer)(void *, void *), void (*reducer_orig_var)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_fortran_array_reduction_register(void *orig, void *dep, ::size_t array_descriptor_size, void (*init)(void *, void *), void (*reducer)(void *, void *), void (*reducer_orig_var)(void *, void *));
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_get_thread_storage_(void *orig, void **tpd);
}
extern "C"
{
  extern ::nanos_err_t nanos_task_reduction_get_thread_storage(void *orig, void **tpd);
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_admit_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread_();
}
extern "C"
{
  extern ::nanos_err_t nanos_expel_current_thread();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all_();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_release_all();
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes_(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_pendant_writes(bool *res, void *addr);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_create_(::nanos_wd_t pred, ::nanos_wd_t succ);
}
extern "C"
{
  extern ::nanos_err_t nanos_dependence_create(::nanos_wd_t pred, ::nanos_wd_t succ);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create_(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_create(::nanos_ws_desc_t **wsd, ::nanos_ws_t ws, ::nanos_ws_info_t *info, bool *b);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item_(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_worksharing_next_item(::nanos_ws_desc_t *wsd, ::nanos_ws_item_t *wsi);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_mandatory_(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_mandatory(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion_(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_wg_wait_completion(::nanos_wg_t wg, bool avoid_flush);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_int_sync_cond(::nanos_sync_cond_t *sync_cond, volatile int *p, int condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond_(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_create_bool_sync_cond(::nanos_sync_cond_t *sync_cond, volatile bool *p, bool condition);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_wait(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_sync_cond_signal(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond_(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_sync_cond(::nanos_sync_cond_t sync_cond);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on_(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_on(::size_t num_data_accesses, ::nanos_data_access_t *data_accesses);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock(::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_init_lock_at(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_unset_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock_(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_try_lock(::nanos_lock_t *lock, bool *result);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock_(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_destroy_lock(::nanos_lock_t *lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address_(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_lock_address(void *addr, ::nanos_lock_t **lock);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies_(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_copies(::nanos_wd_t wd, int num_copies, ::nanos_copy_data_t *copies);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr_(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_addr(::nanos_copy_id_t copy_id, void **addr, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value_(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_copy_value(void *dst, ::nanos_copy_id_t copy_id, ::nanos_wd_t cwd);
}
extern "C"
{
  extern const char *nanos_get_runtime_version_();
}
extern "C"
{
  extern const char *nanos_get_runtime_version();
}
extern "C"
{
  extern const char *nanos_get_default_architecture_();
}
extern "C"
{
  extern const char *nanos_get_default_architecture();
}
extern "C"
{
  extern const char *nanos_get_pm_();
}
extern "C"
{
  extern const char *nanos_get_pm();
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_default_binding(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_binding_(::nanos_cpu_set_t *);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_binding(::nanos_cpu_set_t *);
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_delay_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish_();
}
extern "C"
{
  extern ::nanos_err_t nanos_finish();
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket_(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_current_socket(int socket);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets_(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_num_sockets(int *num_sockets);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc_(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_malloc(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_memalign_(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_memalign(void **p, ::size_t size, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_(void **p, ::size_t size, unsigned int node, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc(void **p, ::size_t size, unsigned int node, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_2dim_distributed_(void **p, ::size_t rows, ::size_t cols, ::size_t elem_size, unsigned int start_node, ::size_t num_nodes, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_cmalloc_2dim_distributed(void **p, ::size_t rows, ::size_t cols, ::size_t elem_size, unsigned int start_node, ::size_t num_nodes, const char *file, int line);
}
extern "C"
{
  extern ::nanos_err_t nanos_stick_to_producer_(void *p, ::size_t size);
}
extern "C"
{
  extern ::nanos_err_t nanos_stick_to_producer(void *p, ::size_t size);
}
extern "C"
{
  extern ::nanos_err_t nanos_free_(void *p);
}
extern "C"
{
  extern ::nanos_err_t nanos_free(void *p);
}
extern "C"
{
  extern void nanos_free0_(void *p);
}
extern "C"
{
  extern void nanos_free0(void *p);
}
extern "C"
{
  extern void nanos_handle_error_(::nanos_err_t err);
}
extern "C"
{
  extern void nanos_handle_error(::nanos_err_t err);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key_(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key(::nanos_event_key_t *event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key_with_key_(::nanos_event_key_t event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_key_with_key(::nanos_event_key_t event_key, const char *key, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value(::nanos_event_value_t *event_value, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val_(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_register_value_with_val(::nanos_event_value_t val, const char *key, const char *value, const char *description, bool abort_when_registered);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key_(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_key(const char *key, ::nanos_event_key_t *event_key);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value_(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_get_value(const char *key, const char *value, ::nanos_event_value_t *event_value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events_(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_events(unsigned int num_events, ::nanos_event_t events[]);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_user_fun_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_raise_gpu_kernel_launch_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_raise_gpu_kernel_launch_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_gpu_kernel_launch_event_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_close_gpu_kernel_launch_event();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_enable();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable_();
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_disable();
}
extern "C"
{
  extern ::nanos_err_t nanos_get_node_num_(unsigned int *num);
}
extern "C"
{
  extern ::nanos_err_t nanos_get_node_num(unsigned int *num);
}
extern "C"
{
  extern int nanos_get_num_nodes_();
}
extern "C"
{
  extern int nanos_get_num_nodes();
}
extern "C"
{
  extern ::nanos_err_t nanos_set_create_local_tasks_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_set_create_local_tasks(bool value);
}
typedef const char *nanos_string_t;
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_string_t value, ::nanos_string_t value_descr);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst(::nanos_string_t key, ::nanos_string_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_with_val_(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_begin_burst_with_val(::nanos_string_t key, ::nanos_string_t key_descr, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_with_val_(::nanos_string_t key, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_end_burst_with_val(::nanos_string_t key, ::nanos_event_value_t *val);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_burst_begin_(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_burst_begin(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_burst_end_(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_burst_end(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_point_event_(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_instrument_point_event(::nanos_event_key_t key, ::nanos_event_value_t value);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy_(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern ::nanos_err_t nanos_memcpy(void *dest, const void *src, ::size_t n);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_object_(int num_objects, ::nanos_copy_data_t *obj);
}
extern "C"
{
  extern ::nanos_err_t nanos_register_object(int num_objects, ::nanos_copy_data_t *obj);
}
extern "C"
{
  extern ::nanos_err_t nanos_unregister_object_(int num_objects, void *base_addresses);
}
extern "C"
{
  extern ::nanos_err_t nanos_unregister_object(int num_objects, void *base_addresses);
}
extern "C"
{
  extern const char *nanos_get_default_scheduler_();
}
extern "C"
{
  extern const char *nanos_get_default_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_start_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler_();
}
extern "C"
{
  extern ::nanos_err_t nanos_stop_scheduler();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_enabled(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_paused();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused_();
}
extern "C"
{
  extern ::nanos_err_t nanos_wait_until_threads_unpaused();
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing_(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_get_stealing(bool *res);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing_(bool value);
}
extern "C"
{
  extern ::nanos_err_t nanos_scheduler_set_stealing(bool value);
}
extern "C"
{
  extern void ompss_nanox_main_begin_(void *addr, const char *filename, int line);
}
extern "C"
{
  extern void ompss_nanox_main_begin(void *addr, const char *filename, int line);
}
extern "C"
{
  extern void ompss_nanox_main_end_();
}
extern "C"
{
  extern void ompss_nanox_main_end();
}
extern "C"
{
  extern void ompss_nanox_main_();
}
extern "C"
{
  extern void ompss_nanox_main();
}
extern "C"
{
  extern void nanos_atexit_(void *);
}
extern "C"
{
  extern void nanos_atexit(void *);
}
extern "C"
{
  void nanos_reduction_int_vop(int, void *, void *);
}
extern "C"
{
  extern int nanos_cmpi_init_(int *argc, char **argv[]);
}
extern "C"
{
  extern int nanos_cmpi_init(int *argc, char **argv[]);
}
extern "C"
{
  extern void nanos_cmpi_finalize_();
}
extern "C"
{
  extern void nanos_cmpi_finalize();
}
extern "C"
{
  extern void nanos_into_blocking_mpi_call_();
}
extern "C"
{
  extern void nanos_into_blocking_mpi_call();
}
extern "C"
{
  extern void nanos_out_of_blocking_mpi_call_();
}
extern "C"
{
  extern void nanos_out_of_blocking_mpi_call();
}
extern "C"
{
  extern void nanos_thread_print_(char *str);
}
extern "C"
{
  extern void nanos_thread_print(char *str);
}
extern "C"
{
  extern void nanos_set_watch_addr_(void *addr);
}
extern "C"
{
  extern void nanos_set_watch_addr(void *addr);
}
extern "C"
{
  extern void nanos_print_bt_();
}
extern "C"
{
  extern void nanos_print_bt();
}
extern "C"
{
  extern void nanos_enable_verbose_copies_();
}
extern "C"
{
  extern void nanos_enable_verbose_copies();
}
extern "C"
{
  extern void nanos_disable_verbose_copies_();
}
extern "C"
{
  extern void nanos_disable_verbose_copies();
}
extern "C"
{
  extern void nanos_atomic_assig_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_assig_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_assig_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_assig_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_add_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_add_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_add_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_add_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_add_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_sub_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_sub_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_sub_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mul_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_mul_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mul_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_div_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_div_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_div_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_div_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_div_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_pow_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_pow_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_pow_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_max_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_max_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_max_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_min_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_min_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_min_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_max_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_max_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_max_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_min_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_min_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_eq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_eq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_eq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_neq_float_(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_float(volatile float *, float);
}
extern "C"
{
  extern void nanos_atomic_neq_double_(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_double(volatile double *, double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble_(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_ldouble(volatile long double *, long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat_(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cfloat(volatile _Complex float *, _Complex float);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble_(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cdouble(volatile _Complex double *, _Complex double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble_(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_neq_cldouble(volatile _Complex long double *, _Complex long double);
}
extern "C"
{
  extern void nanos_atomic_mod_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_mod_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shl_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_shr_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_land_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_land_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_land_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_lor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_band_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_band_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_band_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bor_longlongbool(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_schar(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_short_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_short(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_int(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_long(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlong(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar_(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_uchar(volatile unsigned char *, unsigned char);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort_(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ushort(volatile unsigned short int *, unsigned short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint_(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_uint(volatile unsigned int *, unsigned int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong_(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulong(volatile unsigned long int *, unsigned long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong_(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_ulonglong(volatile unsigned long long int *, unsigned long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool_(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_bytebool(volatile signed char *, signed char);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool_(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_shortbool(volatile short int *, short int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool_(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_intbool(volatile int *, int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool_(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longbool(volatile long int *, long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool_(volatile long long int *, long long int);
}
extern "C"
{
  extern void nanos_atomic_bxor_longlongbool(volatile long long int *, long long int);
}
enum nanos_omp_sched_t
{
  nanos_omp_sched_static = 1,
  nanos_omp_sched_dynamic = 2,
  nanos_omp_sched_guided = 3,
  nanos_omp_sched_auto = 4
};
extern "C"
{
  extern ::nanos_err_t nanos_omp_single_(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_single(bool *);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier_();
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_barrier();
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit_(::nanos_wd_t uwd);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_set_implicit(::nanos_wd_t uwd);
}
extern "C"
{
  extern int nanos_omp_get_max_threads_();
}
extern "C"
{
  extern int nanos_omp_get_max_threads();
}
extern "C"
{
  extern int nanos_omp_get_num_threads_();
}
extern "C"
{
  extern int nanos_omp_get_num_threads();
}
extern "C"
{
  extern int nanos_omp_get_thread_num_();
}
extern "C"
{
  extern int nanos_omp_get_thread_num();
}
extern "C"
{
  extern int nanos_omp_set_num_threads_(int nthreads);
}
extern "C"
{
  extern int nanos_omp_set_num_threads(int nthreads);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing_(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_ws_t nanos_omp_find_worksharing(::nanos_omp_sched_t kind);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule_(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern ::nanos_err_t nanos_omp_get_schedule(::nanos_omp_sched_t *kind, int *modifier);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel_(int threads_requested);
}
extern "C"
{
  extern int nanos_omp_get_num_threads_next_parallel(int threads_requested);
}
extern "C"
{
  extern void nanos_omp_get_process_mask_(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_process_mask(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_process_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_process_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_process_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_process_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_active_mask_(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_get_active_mask(::nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_active_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_set_active_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_active_mask_(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern void nanos_omp_add_active_mask(::const_nanos_cpu_set_t cpu_set);
}
extern "C"
{
  extern int nanos_omp_enable_cpu_(int cpuid);
}
extern "C"
{
  extern int nanos_omp_enable_cpu(int cpuid);
}
extern "C"
{
  extern int nanos_omp_disable_cpu_(int cpuid);
}
extern "C"
{
  extern int nanos_omp_disable_cpu(int cpuid);
}
extern "C"
{
  extern int nanos_omp_get_max_processors_();
}
extern "C"
{
  extern int nanos_omp_get_max_processors();
}
struct  nanos_fpga_args_t
{
    void (*outline)(void *);
    unsigned int type;
};
struct  nanos_find_fpga_args_t
{
    unsigned int type;
    bool check_free;
    bool lock_pe;
};
enum nanos_fpga_memcpy_kind_t
{
  NANOS_COPY_HOST_TO_FPGA = 0,
  NANOS_COPY_FPGA_TO_HOST = 1
};
extern "C"
{
  extern void *nanos_fpga_factory_(void *args);
}
extern "C"
{
  extern void *nanos_fpga_factory(void *args);
}
extern "C"
{
  extern void *nanos_fpga_alloc_dma_mem_(::size_t len);
}
extern "C"
{
  extern void *nanos_fpga_alloc_dma_mem(::size_t len);
}
extern "C"
{
  extern void nanos_fpga_free_dma_mem_(void *address);
}
extern "C"
{
  extern void nanos_fpga_free_dma_mem(void *address);
}
extern "C"
{
  extern ::nanos_err_t nanos_find_fpga_pe_(void *req, ::nanos_pe_t *pe);
}
extern "C"
{
  extern ::nanos_err_t nanos_find_fpga_pe(void *req, ::nanos_pe_t *pe);
}
extern "C"
{
  extern void *nanos_fpga_get_phy_address_(void *address);
}
extern "C"
{
  extern void *nanos_fpga_get_phy_address(void *address);
}
extern "C"
{
  extern ::nanos_err_t nanos_fpga_set_task_arg_(::nanos_wd_t wd, ::size_t argIdx, bool isInput, bool isOutput, ::uint64_t argValue);
}
extern "C"
{
  extern ::nanos_err_t nanos_fpga_set_task_arg(::nanos_wd_t wd, ::size_t argIdx, bool isInput, bool isOutput, ::uint64_t argValue);
}
extern "C"
{
  extern void *nanos_fpga_malloc_(::size_t len);
}
extern "C"
{
  extern void *nanos_fpga_malloc(::size_t len);
}
extern "C"
{
  extern void nanos_fpga_free_(void *fpgaPtr);
}
extern "C"
{
  extern void nanos_fpga_free(void *fpgaPtr);
}
extern "C"
{
  extern void nanos_fpga_memcpy_(void *fpgaPtr, void *hostPtr, ::size_t len, ::nanos_fpga_memcpy_kind_t kind);
}
extern "C"
{
  extern void nanos_fpga_memcpy(void *fpgaPtr, void *hostPtr, ::size_t len, ::nanos_fpga_memcpy_kind_t kind);
}
namespace std __attribute__((__visibility__("default"))) {
  typedef unsigned long int size_t;
  typedef long int ptrdiff_t;
  typedef decltype(nullptr) nullptr_t;
}
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short int __int16_t;
typedef unsigned short int __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
struct  __fsid_t
{
    int __val[2L];
};
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef ::__off64_t __loff_t;
typedef ::__quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
struct _IO_FILE;
typedef ::_IO_FILE FILE;
typedef ::_IO_FILE __FILE;
struct  __mbstate_t
{
    int __count;
    union  mcc_union_anon_64
    {
        unsigned int __wch;
        char __wchb[4L];
    };
    ::__mbstate_t::mcc_union_anon_64 __value;
};
struct  _G_fpos_t
{
    ::__off_t __pos;
    ::__mbstate_t __state;
};
struct  _G_fpos64_t
{
    ::__off64_t __pos;
    ::__mbstate_t __state;
};
typedef ::__builtin_va_list __gnuc_va_list;
struct _IO_jump_t;
typedef void _IO_lock_t;
struct _IO_marker;
struct  _IO_marker
{
    ::_IO_marker *_next;
    ::_IO_FILE *_sbuf;
    int _pos;
};
enum __codecvt_result
{
  __codecvt_ok = 0,
  __codecvt_partial = 1,
  __codecvt_error = 2,
  __codecvt_noconv = 3
};
struct  _IO_FILE
{
    int _flags;
    char *_IO_read_ptr;
    char *_IO_read_end;
    char *_IO_read_base;
    char *_IO_write_base;
    char *_IO_write_ptr;
    char *_IO_write_end;
    char *_IO_buf_base;
    char *_IO_buf_end;
    char *_IO_save_base;
    char *_IO_backup_base;
    char *_IO_save_end;
    ::_IO_marker *_markers;
    ::_IO_FILE *_chain;
    int _fileno;
    int _flags2;
    ::__off_t _old_offset;
    unsigned short int _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1L];
    ::_IO_lock_t *_lock;
    ::__off64_t _offset;
    void *__pad1;
    void *__pad2;
    void *__pad3;
    void *__pad4;
    ::size_t __pad5;
    int _mode;
    char _unused2[20L];
};
struct _IO_FILE_plus;
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdin_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stdout_;
}
extern "C"
{
  extern ::_IO_FILE_plus _IO_2_1_stderr_;
}
typedef ::__ssize_t __io_read_fn(void *, char *, ::size_t);
typedef ::__ssize_t __io_write_fn(void *, const char *, ::size_t);
typedef int __io_seek_fn(void *, ::__off64_t *, int);
typedef int __io_close_fn(void *);
typedef ::__io_read_fn cookie_read_function_t;
typedef ::__io_write_fn cookie_write_function_t;
typedef ::__io_seek_fn cookie_seek_function_t;
typedef ::__io_close_fn cookie_close_function_t;
struct  _IO_cookie_io_functions_t
{
    ::__io_read_fn (*read);
    ::__io_write_fn (*write);
    ::__io_seek_fn (*seek);
    ::__io_close_fn (*close);
};
typedef ::_IO_cookie_io_functions_t cookie_io_functions_t;
struct _IO_cookie_file;
extern "C"
{
  extern void _IO_cookie_init(::_IO_cookie_file *__cfile, int __read_write, void *__cookie, ::_IO_cookie_io_functions_t __fns);
}
extern "C"
{
  extern int __underflow(::_IO_FILE *);
}
extern "C"
{
  extern int __uflow(::_IO_FILE *);
}
extern "C"
{
  extern int __overflow(::_IO_FILE *, int);
}
extern "C"
{
  extern int _IO_getc(::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_putc(int __c, ::_IO_FILE *__fp);
}
extern "C"
{
  extern int _IO_feof(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_ferror(::_IO_FILE *__fp) throw();
}
extern "C"
{
  extern int _IO_peekc_locked(::_IO_FILE *__fp);
}
extern "C"
{
  extern void _IO_flockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern void _IO_funlockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_ftrylockfile(::_IO_FILE *) throw();
}
extern "C"
{
  extern int _IO_vfscanf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list, int *__restrict );
}
extern "C"
{
  extern int _IO_vfprintf(::_IO_FILE *__restrict , const char *__restrict , ::__gnuc_va_list);
}
extern "C"
{
  extern ::__ssize_t _IO_padn(::_IO_FILE *, int, ::__ssize_t);
}
extern "C"
{
  extern ::size_t _IO_sgetn(::_IO_FILE *, void *, ::size_t);
}
extern "C"
{
  extern ::__off64_t _IO_seekoff(::_IO_FILE *, ::__off64_t, int, int);
}
extern "C"
{
  extern ::__off64_t _IO_seekpos(::_IO_FILE *, ::__off64_t, int);
}
extern "C"
{
  extern void _IO_free_backup_area(::_IO_FILE *) throw();
}
typedef ::__gnuc_va_list va_list;
typedef ::__off_t off_t;
typedef ::__off64_t off64_t;
typedef ::__ssize_t ssize_t;
typedef ::_G_fpos_t fpos_t;
typedef ::_G_fpos64_t fpos64_t;
extern "C"
{
  extern ::_IO_FILE *stdin;
}
extern "C"
{
  extern ::_IO_FILE *stdout;
}
extern "C"
{
  extern ::_IO_FILE *stderr;
}
extern "C"
{
  extern int remove(const char *__filename) throw();
}
extern "C"
{
  extern int rename(const char *__old, const char *__new) throw();
}
extern "C"
{
  extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new) throw();
}
extern "C"
{
  extern ::FILE *tmpfile();
}
extern "C"
{
  extern ::FILE *tmpfile64();
}
extern "C"
{
  extern char *tmpnam(char *__s) throw();
}
extern "C"
{
  extern char *tmpnam_r(char *__s) throw();
}
extern "C"
{
  extern char *tempnam(const char *__dir, const char *__pfx) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern int fclose(::FILE *__stream);
}
extern "C"
{
  extern int fflush(::FILE *__stream);
}
extern "C"
{
  extern int fflush_unlocked(::FILE *__stream);
}
extern "C"
{
  extern int fcloseall();
}
extern "C"
{
  extern ::FILE *fopen(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fopen64(const char *__restrict __filename, const char *__restrict __modes);
}
extern "C"
{
  extern ::FILE *freopen64(const char *__restrict __filename, const char *__restrict __modes, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::FILE *fdopen(int __fd, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *fopencookie(void *__restrict __magic_cookie, const char *__restrict __modes, ::_IO_cookie_io_functions_t __io_funcs) throw();
}
extern "C"
{
  extern ::FILE *fmemopen(void *__s, ::size_t __len, const char *__modes) throw();
}
extern "C"
{
  extern ::FILE *open_memstream(char **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern void setbuf(::FILE *__restrict __stream, char *__restrict __buf) throw();
}
extern "C"
{
  extern int setvbuf(::FILE *__restrict __stream, char *__restrict __buf, int __modes, ::size_t __n) throw();
}
extern "C"
{
  extern void setbuffer(::FILE *__restrict __stream, char *__restrict __buf, ::size_t __size) throw();
}
extern "C"
{
  extern void setlinebuf(::FILE *__stream) throw();
}
extern "C"
{
  extern int fprintf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int printf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sprintf(char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfprintf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern inline int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __arg) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int vsprintf(char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int snprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ...) throw() __attribute__((__format__(__printf__, 3, 4)));
}
extern "C"
{
  extern int vsnprintf(char *__restrict __s, ::size_t __maxlen, const char *__restrict __format, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__printf__, 3, 0)));
}
extern "C"
{
  extern int vasprintf(char **__restrict __ptr, const char *__restrict __f, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int __asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int asprintf(char **__restrict __ptr, const char *__restrict __fmt, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int vdprintf(int __fd, const char *__restrict __fmt, ::__gnuc_va_list __arg) __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern int dprintf(int __fd, const char *__restrict __fmt, ...) __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int fscanf(::FILE *__restrict __stream, const char *__restrict __format, ...);
}
extern "C"
{
  extern int scanf(const char *__restrict __format, ...);
}
extern "C"
{
  extern int sscanf(const char *__restrict __s, const char *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfscanf(::FILE *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int vscanf(const char *__restrict __format, ::__gnuc_va_list __arg) __attribute__((__format__(__scanf__, 1, 0)));
}
extern "C"
{
  extern int vsscanf(const char *__restrict __s, const char *__restrict __format, ::__gnuc_va_list __arg) throw() __attribute__((__format__(__scanf__, 2, 0)));
}
extern "C"
{
  extern int fgetc(::FILE *__stream);
}
extern "C"
{
  extern int getc(::FILE *__stream);
}
extern "C"
{
  extern inline int getchar() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int getchar_unlocked() __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fgetc_unlocked(::FILE *__fp) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern int putc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern inline int putchar(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int fputc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putc_unlocked(int __c, ::FILE *__stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int putchar_unlocked(int __c) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int getw(::FILE *__stream);
}
extern "C"
{
  extern int putw(int __w, ::FILE *__stream);
}
extern "C"
{
  extern char *fgets(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern char *gets(char *__s) __attribute__((__deprecated__));
}
extern "C"
{
  extern char *fgets_unlocked(char *__restrict __s, int __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t __getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::__ssize_t getdelim(char **__restrict __lineptr, ::size_t *__restrict __n, int __delimiter, ::FILE *__restrict __stream);
}
extern "C"
{
  extern inline ::__ssize_t getline(char **__restrict __lineptr, ::size_t *__restrict __n, ::FILE *__restrict __stream) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int fputs(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int puts(const char *__s);
}
extern "C"
{
  extern int ungetc(int __c, ::FILE *__stream);
}
extern "C"
{
  extern ::size_t fread(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __s);
}
extern "C"
{
  extern int fputs_unlocked(const char *__restrict __s, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fread_unlocked(void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t fwrite_unlocked(const void *__restrict __ptr, ::size_t __size, ::size_t __n, ::FILE *__restrict __stream);
}
extern "C"
{
  extern int fseek(::FILE *__stream, long int __off, int __whence);
}
extern "C"
{
  extern long int ftell(::FILE *__stream);
}
extern "C"
{
  extern void rewind(::FILE *__stream);
}
extern "C"
{
  extern int fseeko(::FILE *__stream, ::__off_t __off, int __whence);
}
extern "C"
{
  extern ::__off_t ftello(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos(::FILE *__restrict __stream, ::fpos_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos(::FILE *__stream, const ::fpos_t *__pos);
}
extern "C"
{
  extern int fseeko64(::FILE *__stream, ::__off64_t __off, int __whence);
}
extern "C"
{
  extern ::__off64_t ftello64(::FILE *__stream);
}
extern "C"
{
  extern int fgetpos64(::FILE *__restrict __stream, ::fpos64_t *__restrict __pos);
}
extern "C"
{
  extern int fsetpos64(::FILE *__stream, const ::fpos64_t *__pos);
}
extern "C"
{
  extern void clearerr(::FILE *__stream) throw();
}
extern "C"
{
  extern int feof(::FILE *__stream) throw();
}
extern "C"
{
  extern int ferror(::FILE *__stream) throw();
}
extern "C"
{
  extern void clearerr_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern inline int feof_unlocked(::FILE *__stream) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int ferror_unlocked(::FILE *__stream) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern void perror(const char *__s);
}
extern "C"
{
  extern int sys_nerr;
}
extern "C"
{
  extern const char *const sys_errlist[];
}
extern "C"
{
  extern int _sys_nerr;
}
extern "C"
{
  extern const char *const _sys_errlist[];
}
extern "C"
{
  extern int fileno(::FILE *__stream) throw();
}
extern "C"
{
  extern int fileno_unlocked(::FILE *__stream) throw();
}
extern "C"
{
  extern ::FILE *popen(const char *__command, const char *__modes);
}
extern "C"
{
  extern int pclose(::FILE *__stream);
}
extern "C"
{
  extern char *ctermid(char *__s) throw();
}
extern "C"
{
  extern char *cuserid(char *__s);
}
struct obstack;
extern "C"
{
  extern int obstack_printf(::obstack *__restrict __obstack, const char *__restrict __format, ...) throw() __attribute__((__format__(__printf__, 2, 3)));
}
extern "C"
{
  extern int obstack_vprintf(::obstack *__restrict __obstack, const char *__restrict __format, ::__gnuc_va_list __args) throw() __attribute__((__format__(__printf__, 2, 0)));
}
extern "C"
{
  extern void flockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern int ftrylockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern void funlockfile(::FILE *__stream) throw();
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int vprintf(const char *__restrict __fmt, ::__gnuc_va_list __arg)
  {
    return ::vfprintf(::stdout, __fmt, __arg);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar()
  {
    return ::_IO_getc(::stdin);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fgetc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getc_unlocked(::FILE *__fp)
  {
    return __builtin_expect((*__fp)._IO_read_ptr >= (*__fp)._IO_read_end, 0) ? ::__uflow(__fp) : *((unsigned char *)(*__fp)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int getchar_unlocked()
  {
    return __builtin_expect((*::stdin)._IO_read_ptr >= (*::stdin)._IO_read_end, 0) ? ::__uflow(::stdin) : *((unsigned char *)(*::stdin)._IO_read_ptr++);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar(int __c)
  {
    return ::_IO_putc(__c, ::stdout);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int fputc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putc_unlocked(int __c, ::FILE *__stream)
  {
    return __builtin_expect((*__stream)._IO_write_ptr >= (*__stream)._IO_write_end, 0) ? ::__overflow(__stream, (unsigned char)__c) : (unsigned char)(*(*__stream)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) int putchar_unlocked(int __c)
  {
    return __builtin_expect((*::stdout)._IO_write_ptr >= (*::stdout)._IO_write_end, 0) ? ::__overflow(::stdout, (unsigned char)__c) : (unsigned char)(*(*::stdout)._IO_write_ptr++ = __c);
  }
}
extern "C"
{
  extern inline __attribute__((__gnu_inline__)) ::__ssize_t getline(char **__lineptr, ::size_t *__n, ::FILE *__stream)
  {
    return ::__getdelim(__lineptr, __n, '\n', __stream);
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int feof_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 16) != 0;
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int ferror_unlocked(::FILE *__stream) throw()
  {
    return ((*__stream)._flags & 32) != 0;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::FILE;
  using ::fpos_t;
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Iterator, typename _Container >
  class __normal_iterator;
}
namespace std __attribute__((__visibility__("default"))) {
  struct  __true_type
  {
  };
  struct  __false_type
  {
  };
  template < bool __nontype_tpl_param_1_0__ >
  struct  __truth_type
  {
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __truth_type<true>
  {
      typedef ::std::__true_type __type;
  };
  template < typename _Sp, typename _Tp >
  struct  __traitor
  {
      enum mcc_enum_anon_14
      {
        __value = bool(_Sp::__value) || bool(_Tp::__value)
      };
      typedef typename ::std::__truth_type< ::std::__traitor<_Sp, _Tp>::__value>::__type __type;
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __are_same
  {
      enum mcc_enum_anon_15
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __are_same<_Tp, _Tp>
  {
      enum mcc_enum_anon_16
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_void
  {
      enum mcc_enum_anon_17
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_void<void>
  {
      enum mcc_enum_anon_18
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_integer
  {
      enum mcc_enum_anon_19
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_integer<bool>
  {
      enum mcc_enum_anon_20
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char>
  {
      enum mcc_enum_anon_21
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<signed char>
  {
      enum mcc_enum_anon_22
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned char>
  {
      enum mcc_enum_anon_23
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<wchar_t>
  {
      enum mcc_enum_anon_24
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char16_t>
  {
      enum mcc_enum_anon_25
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<char32_t>
  {
      enum mcc_enum_anon_26
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<short int>
  {
      enum mcc_enum_anon_27
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned short int>
  {
      enum mcc_enum_anon_28
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<int>
  {
      enum mcc_enum_anon_29
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned int>
  {
      enum mcc_enum_anon_30
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long int>
  {
      enum mcc_enum_anon_31
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long int>
  {
      enum mcc_enum_anon_32
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<long long int>
  {
      enum mcc_enum_anon_33
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_integer<unsigned long long int>
  {
      enum mcc_enum_anon_34
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_floating
  {
      enum mcc_enum_anon_35
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_floating<float>
  {
      enum mcc_enum_anon_36
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<double>
  {
      enum mcc_enum_anon_37
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_floating<long double>
  {
      enum mcc_enum_anon_38
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer
  {
      enum mcc_enum_anon_39
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Tp >
  struct  __is_pointer<_Tp *>
  {
      enum mcc_enum_anon_40
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_normal_iterator
  {
      enum mcc_enum_anon_41
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator, typename _Container >
  struct  __is_normal_iterator< ::__gnu_cxx::__normal_iterator<_Iterator, _Container> >
  {
      enum mcc_enum_anon_42
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_arithmetic : ::std::__traitor< ::std::__is_integer<_Tp>, ::std::__is_floating<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_scalar : ::std::__traitor< ::std::__is_arithmetic<_Tp>, ::std::__is_pointer<_Tp> >
  {
  };
  template < typename _Tp >
  struct  __is_char
  {
      enum mcc_enum_anon_43
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_char<char>
  {
      enum mcc_enum_anon_44
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_char<wchar_t>
  {
      enum mcc_enum_anon_45
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_byte
  {
      enum mcc_enum_anon_46
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template <>
  struct  __is_byte<char>
  {
      enum mcc_enum_anon_47
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<signed char>
  {
      enum mcc_enum_anon_48
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template <>
  struct  __is_byte<unsigned char>
  {
      enum mcc_enum_anon_49
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
  template < typename _Tp >
  struct  __is_move_iterator
  {
      enum mcc_enum_anon_50
      {
        __value = 0
      };
      typedef ::std::__false_type __type;
  };
  template < typename _Iterator >
  class move_iterator;
  template < typename _Iterator >
  struct  __is_move_iterator< ::std::move_iterator<_Iterator> >
  {
      enum mcc_enum_anon_51
      {
        __value = 1
      };
      typedef ::std::__true_type __type;
  };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __enable_if
  {
  };
  template < typename _Tp >
  struct  __enable_if<true, _Tp>
  {
      typedef _Tp __type;
  };
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  __conditional_type
  {
      typedef _Iftrue __type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  __conditional_type<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse __type;
  };
  template < typename _Tp >
  struct  __add_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __add_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __add_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __add_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __add_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __add_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template <>
  struct __add_unsigned<bool>;
  template <>
  struct __add_unsigned<wchar_t>;
  template < typename _Tp >
  struct  __remove_unsigned
  {
    private:
      typedef ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename ::__gnu_cxx::__enable_if<std::__is_integer<_Tp>::__value, _Tp>::__type __type;
  };
  template <>
  struct  __remove_unsigned<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __remove_unsigned<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __remove_unsigned<unsigned long long int>
  {
      typedef long long int __type;
  };
  template <>
  struct __remove_unsigned<bool>;
  template <>
  struct __remove_unsigned<wchar_t>;
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr);
  template < typename _Type >
  inline bool __is_null_pointer(_Type *__ptr)
  {
    return __ptr == 0;
  }
  template < typename _Type >
  inline bool __is_null_pointer(_Type);
  template < typename _Type >
  inline bool __is_null_pointer(_Type)
  {
    return false;
  }
  inline bool __is_null_pointer(::std::nullptr_t)
  {
    return true;
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = std::__is_integer<_Tp>::__value >
  struct  __promote
  {
      typedef double __type;
  };
  template < typename _Tp >
  struct  __promote<_Tp, false>
  {
  };
 /* Instantiation of class template '::std::__is_integer<long double>' */ 
  template <>
  struct  __promote<long double>
  {
      typedef long double __type;
  };
 /* Instantiation of class template '::std::__is_integer<double>' */ 
  template <>
  struct  __promote<double>
  {
      typedef double __type;
  };
 /* Instantiation of class template '::std::__is_integer<float>' */ 
  template <>
  struct  __promote<float>
  {
      typedef float __type;
  };
  template < typename _Tp, typename _Up, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type >
  struct  __promote_2
  {
      typedef __typeof__(_Tp2() + _Up2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type >
  struct  __promote_3
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
  };
  template < typename _Tp, typename _Up, typename _Vp, typename _Wp, typename _Tp2 = typename ::__gnu_cxx::__promote<_Tp>::__type, typename _Up2 = typename ::__gnu_cxx::__promote<_Up>::__type, typename _Vp2 = typename ::__gnu_cxx::__promote<_Vp>::__type, typename _Wp2 = typename ::__gnu_cxx::__promote<_Wp>::__type >
  struct  __promote_4
  {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
  };
}
typedef float float_t;
typedef double double_t;
extern "C"
{
  extern double acos(double __x) throw();
}
extern "C"
{
  extern double __acos(double __x) throw();
}
extern "C"
{
  extern double asin(double __x) throw();
}
extern "C"
{
  extern double __asin(double __x) throw();
}
extern "C"
{
  extern double atan(double __x) throw();
}
extern "C"
{
  extern double __atan(double __x) throw();
}
extern "C"
{
  extern double atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double __atan2(double __y, double __x) throw();
}
extern "C"
{
  extern double cos(double __x) throw();
}
extern "C"
{
  extern double __cos(double __x) throw();
}
extern "C"
{
  extern double sin(double __x) throw();
}
extern "C"
{
  extern double __sin(double __x) throw();
}
extern "C"
{
  extern double tan(double __x) throw();
}
extern "C"
{
  extern double __tan(double __x) throw();
}
extern "C"
{
  extern double cosh(double __x) throw();
}
extern "C"
{
  extern double __cosh(double __x) throw();
}
extern "C"
{
  extern double sinh(double __x) throw();
}
extern "C"
{
  extern double __sinh(double __x) throw();
}
extern "C"
{
  extern double tanh(double __x) throw();
}
extern "C"
{
  extern double __tanh(double __x) throw();
}
extern "C"
{
  extern void sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern void __sincos(double __x, double *__sinx, double *__cosx) throw();
}
extern "C"
{
  extern double acosh(double __x) throw();
}
extern "C"
{
  extern double __acosh(double __x) throw();
}
extern "C"
{
  extern double asinh(double __x) throw();
}
extern "C"
{
  extern double __asinh(double __x) throw();
}
extern "C"
{
  extern double atanh(double __x) throw();
}
extern "C"
{
  extern double __atanh(double __x) throw();
}
extern "C"
{
  extern double exp(double __x) throw();
}
extern "C"
{
  extern double __exp(double __x) throw();
}
extern "C"
{
  extern double frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double __frexp(double __x, int *__exponent) throw();
}
extern "C"
{
  extern double ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double __ldexp(double __x, int __exponent) throw();
}
extern "C"
{
  extern double log(double __x) throw();
}
extern "C"
{
  extern double __log(double __x) throw();
}
extern "C"
{
  extern double log10(double __x) throw();
}
extern "C"
{
  extern double __log10(double __x) throw();
}
extern "C"
{
  extern double modf(double __x, double *__iptr) throw();
}
extern "C"
{
  extern double __modf(double __x, double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern double exp10(double __x) throw();
}
extern "C"
{
  extern double __exp10(double __x) throw();
}
extern "C"
{
  extern double pow10(double __x) throw();
}
extern "C"
{
  extern double __pow10(double __x) throw();
}
extern "C"
{
  extern double expm1(double __x) throw();
}
extern "C"
{
  extern double __expm1(double __x) throw();
}
extern "C"
{
  extern double log1p(double __x) throw();
}
extern "C"
{
  extern double __log1p(double __x) throw();
}
extern "C"
{
  extern double logb(double __x) throw();
}
extern "C"
{
  extern double __logb(double __x) throw();
}
extern "C"
{
  extern double exp2(double __x) throw();
}
extern "C"
{
  extern double __exp2(double __x) throw();
}
extern "C"
{
  extern double log2(double __x) throw();
}
extern "C"
{
  extern double __log2(double __x) throw();
}
extern "C"
{
  extern double pow(double __x, double __y) throw();
}
extern "C"
{
  extern double __pow(double __x, double __y) throw();
}
extern "C"
{
  extern double sqrt(double __x) throw();
}
extern "C"
{
  extern double __sqrt(double __x) throw();
}
extern "C"
{
  extern double hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double __hypot(double __x, double __y) throw();
}
extern "C"
{
  extern double cbrt(double __x) throw();
}
extern "C"
{
  extern double __cbrt(double __x) throw();
}
extern "C"
{
  extern double ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __ceil(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fabs(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __floor(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmod(double __x, double __y) throw();
}
extern "C"
{
  extern double __fmod(double __x, double __y) throw();
}
extern "C"
{
  extern int __isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinf(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finite(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double drem(double __x, double __y) throw();
}
extern "C"
{
  extern double __drem(double __x, double __y) throw();
}
extern "C"
{
  extern double significand(double __x) throw();
}
extern "C"
{
  extern double __significand(double __x) throw();
}
extern "C"
{
  extern double copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __copysign(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nan(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnan(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double j0(double) throw();
}
extern "C"
{
  extern double __j0(double) throw();
}
extern "C"
{
  extern double j1(double) throw();
}
extern "C"
{
  extern double __j1(double) throw();
}
extern "C"
{
  extern double jn(int, double) throw();
}
extern "C"
{
  extern double __jn(int, double) throw();
}
extern "C"
{
  extern double y0(double) throw();
}
extern "C"
{
  extern double __y0(double) throw();
}
extern "C"
{
  extern double y1(double) throw();
}
extern "C"
{
  extern double __y1(double) throw();
}
extern "C"
{
  extern double yn(int, double) throw();
}
extern "C"
{
  extern double __yn(int, double) throw();
}
extern "C"
{
  extern double erf(double) throw();
}
extern "C"
{
  extern double __erf(double) throw();
}
extern "C"
{
  extern double erfc(double) throw();
}
extern "C"
{
  extern double __erfc(double) throw();
}
extern "C"
{
  extern double lgamma(double) throw();
}
extern "C"
{
  extern double __lgamma(double) throw();
}
extern "C"
{
  extern double tgamma(double) throw();
}
extern "C"
{
  extern double __tgamma(double) throw();
}
extern "C"
{
  extern double gamma(double) throw();
}
extern "C"
{
  extern double __gamma(double) throw();
}
extern "C"
{
  extern double lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double __lgamma_r(double, int *__signgamp) throw();
}
extern "C"
{
  extern double rint(double __x) throw();
}
extern "C"
{
  extern double __rint(double __x) throw();
}
extern "C"
{
  extern double nextafter(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nextafter(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double nexttoward(double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __nexttoward(double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double __remainder(double __x, double __y) throw();
}
extern "C"
{
  extern double scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern double __scalbn(double __x, int __n) throw();
}
extern "C"
{
  extern int ilogb(double __x) throw();
}
extern "C"
{
  extern int __ilogb(double __x) throw();
}
extern "C"
{
  extern double scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double __scalbln(double __x, long int __n) throw();
}
extern "C"
{
  extern double nearbyint(double __x) throw();
}
extern "C"
{
  extern double __nearbyint(double __x) throw();
}
extern "C"
{
  extern double round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __round(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __trunc(double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern double remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern double __remquo(double __x, double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrint(double __x) throw();
}
extern "C"
{
  extern long int __lrint(double __x) throw();
}
extern "C"
{
  extern long long int llrint(double __x) throw();
}
extern "C"
{
  extern long long int __llrint(double __x) throw();
}
extern "C"
{
  extern long int lround(double __x) throw();
}
extern "C"
{
  extern long int __lround(double __x) throw();
}
extern "C"
{
  extern long long int llround(double __x) throw();
}
extern "C"
{
  extern long long int __llround(double __x) throw();
}
extern "C"
{
  extern double fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double __fdim(double __x, double __y) throw();
}
extern "C"
{
  extern double fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmax(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern double __fmin(double __x, double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassify(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbit(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern double __fma(double __x, double __y, double __z) throw();
}
extern "C"
{
  extern int __issignaling(double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern double scalb(double __x, double __n) throw();
}
extern "C"
{
  extern double __scalb(double __x, double __n) throw();
}
extern "C"
{
  extern float acosf(float __x) throw();
}
extern "C"
{
  extern float __acosf(float __x) throw();
}
extern "C"
{
  extern float asinf(float __x) throw();
}
extern "C"
{
  extern float __asinf(float __x) throw();
}
extern "C"
{
  extern float atanf(float __x) throw();
}
extern "C"
{
  extern float __atanf(float __x) throw();
}
extern "C"
{
  extern float atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float __atan2f(float __y, float __x) throw();
}
extern "C"
{
  extern float cosf(float __x) throw();
}
extern "C"
{
  extern float __cosf(float __x) throw();
}
extern "C"
{
  extern float sinf(float __x) throw();
}
extern "C"
{
  extern float __sinf(float __x) throw();
}
extern "C"
{
  extern float tanf(float __x) throw();
}
extern "C"
{
  extern float __tanf(float __x) throw();
}
extern "C"
{
  extern float coshf(float __x) throw();
}
extern "C"
{
  extern float __coshf(float __x) throw();
}
extern "C"
{
  extern float sinhf(float __x) throw();
}
extern "C"
{
  extern float __sinhf(float __x) throw();
}
extern "C"
{
  extern float tanhf(float __x) throw();
}
extern "C"
{
  extern float __tanhf(float __x) throw();
}
extern "C"
{
  extern void sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern void __sincosf(float __x, float *__sinx, float *__cosx) throw();
}
extern "C"
{
  extern float acoshf(float __x) throw();
}
extern "C"
{
  extern float __acoshf(float __x) throw();
}
extern "C"
{
  extern float asinhf(float __x) throw();
}
extern "C"
{
  extern float __asinhf(float __x) throw();
}
extern "C"
{
  extern float atanhf(float __x) throw();
}
extern "C"
{
  extern float __atanhf(float __x) throw();
}
extern "C"
{
  extern float expf(float __x) throw();
}
extern "C"
{
  extern float __expf(float __x) throw();
}
extern "C"
{
  extern float frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float __frexpf(float __x, int *__exponent) throw();
}
extern "C"
{
  extern float ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float __ldexpf(float __x, int __exponent) throw();
}
extern "C"
{
  extern float logf(float __x) throw();
}
extern "C"
{
  extern float __logf(float __x) throw();
}
extern "C"
{
  extern float log10f(float __x) throw();
}
extern "C"
{
  extern float __log10f(float __x) throw();
}
extern "C"
{
  extern float modff(float __x, float *__iptr) throw();
}
extern "C"
{
  extern float __modff(float __x, float *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern float exp10f(float __x) throw();
}
extern "C"
{
  extern float __exp10f(float __x) throw();
}
extern "C"
{
  extern float pow10f(float __x) throw();
}
extern "C"
{
  extern float __pow10f(float __x) throw();
}
extern "C"
{
  extern float expm1f(float __x) throw();
}
extern "C"
{
  extern float __expm1f(float __x) throw();
}
extern "C"
{
  extern float log1pf(float __x) throw();
}
extern "C"
{
  extern float __log1pf(float __x) throw();
}
extern "C"
{
  extern float logbf(float __x) throw();
}
extern "C"
{
  extern float __logbf(float __x) throw();
}
extern "C"
{
  extern float exp2f(float __x) throw();
}
extern "C"
{
  extern float __exp2f(float __x) throw();
}
extern "C"
{
  extern float log2f(float __x) throw();
}
extern "C"
{
  extern float __log2f(float __x) throw();
}
extern "C"
{
  extern float powf(float __x, float __y) throw();
}
extern "C"
{
  extern float __powf(float __x, float __y) throw();
}
extern "C"
{
  extern float sqrtf(float __x) throw();
}
extern "C"
{
  extern float __sqrtf(float __x) throw();
}
extern "C"
{
  extern float hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float __hypotf(float __x, float __y) throw();
}
extern "C"
{
  extern float cbrtf(float __x) throw();
}
extern "C"
{
  extern float __cbrtf(float __x) throw();
}
extern "C"
{
  extern float ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __ceilf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fabsf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __floorf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fmodf(float __x, float __y) throw();
}
extern "C"
{
  extern int __isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinff(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitef(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float __dremf(float __x, float __y) throw();
}
extern "C"
{
  extern float significandf(float __x) throw();
}
extern "C"
{
  extern float __significandf(float __x) throw();
}
extern "C"
{
  extern float copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __copysignf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nanf(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float j0f(float) throw();
}
extern "C"
{
  extern float __j0f(float) throw();
}
extern "C"
{
  extern float j1f(float) throw();
}
extern "C"
{
  extern float __j1f(float) throw();
}
extern "C"
{
  extern float jnf(int, float) throw();
}
extern "C"
{
  extern float __jnf(int, float) throw();
}
extern "C"
{
  extern float y0f(float) throw();
}
extern "C"
{
  extern float __y0f(float) throw();
}
extern "C"
{
  extern float y1f(float) throw();
}
extern "C"
{
  extern float __y1f(float) throw();
}
extern "C"
{
  extern float ynf(int, float) throw();
}
extern "C"
{
  extern float __ynf(int, float) throw();
}
extern "C"
{
  extern float erff(float) throw();
}
extern "C"
{
  extern float __erff(float) throw();
}
extern "C"
{
  extern float erfcf(float) throw();
}
extern "C"
{
  extern float __erfcf(float) throw();
}
extern "C"
{
  extern float lgammaf(float) throw();
}
extern "C"
{
  extern float __lgammaf(float) throw();
}
extern "C"
{
  extern float tgammaf(float) throw();
}
extern "C"
{
  extern float __tgammaf(float) throw();
}
extern "C"
{
  extern float gammaf(float) throw();
}
extern "C"
{
  extern float __gammaf(float) throw();
}
extern "C"
{
  extern float lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float __lgammaf_r(float, int *__signgamp) throw();
}
extern "C"
{
  extern float rintf(float __x) throw();
}
extern "C"
{
  extern float __rintf(float __x) throw();
}
extern "C"
{
  extern float nextafterf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nextafterf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float nexttowardf(float __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __nexttowardf(float __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float __remainderf(float __x, float __y) throw();
}
extern "C"
{
  extern float scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern float __scalbnf(float __x, int __n) throw();
}
extern "C"
{
  extern int ilogbf(float __x) throw();
}
extern "C"
{
  extern int __ilogbf(float __x) throw();
}
extern "C"
{
  extern float scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float __scalblnf(float __x, long int __n) throw();
}
extern "C"
{
  extern float nearbyintf(float __x) throw();
}
extern "C"
{
  extern float __nearbyintf(float __x) throw();
}
extern "C"
{
  extern float roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __roundf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __truncf(float __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern float remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern float __remquof(float __x, float __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintf(float __x) throw();
}
extern "C"
{
  extern long int __lrintf(float __x) throw();
}
extern "C"
{
  extern long long int llrintf(float __x) throw();
}
extern "C"
{
  extern long long int __llrintf(float __x) throw();
}
extern "C"
{
  extern long int lroundf(float __x) throw();
}
extern "C"
{
  extern long int __lroundf(float __x) throw();
}
extern "C"
{
  extern long long int llroundf(float __x) throw();
}
extern "C"
{
  extern long long int __llroundf(float __x) throw();
}
extern "C"
{
  extern float fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float __fdimf(float __x, float __y) throw();
}
extern "C"
{
  extern float fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fmaxf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern float __fminf(float __x, float __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassifyf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbitf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern float __fmaf(float __x, float __y, float __z) throw();
}
extern "C"
{
  extern int __issignalingf(float __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern float scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern float __scalbf(float __x, float __n) throw();
}
extern "C"
{
  extern long double acosl(long double __x) throw();
}
extern "C"
{
  extern long double __acosl(long double __x) throw();
}
extern "C"
{
  extern long double asinl(long double __x) throw();
}
extern "C"
{
  extern long double __asinl(long double __x) throw();
}
extern "C"
{
  extern long double atanl(long double __x) throw();
}
extern "C"
{
  extern long double __atanl(long double __x) throw();
}
extern "C"
{
  extern long double atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double __atan2l(long double __y, long double __x) throw();
}
extern "C"
{
  extern long double cosl(long double __x) throw();
}
extern "C"
{
  extern long double __cosl(long double __x) throw();
}
extern "C"
{
  extern long double sinl(long double __x) throw();
}
extern "C"
{
  extern long double __sinl(long double __x) throw();
}
extern "C"
{
  extern long double tanl(long double __x) throw();
}
extern "C"
{
  extern long double __tanl(long double __x) throw();
}
extern "C"
{
  extern long double coshl(long double __x) throw();
}
extern "C"
{
  extern long double __coshl(long double __x) throw();
}
extern "C"
{
  extern long double sinhl(long double __x) throw();
}
extern "C"
{
  extern long double __sinhl(long double __x) throw();
}
extern "C"
{
  extern long double tanhl(long double __x) throw();
}
extern "C"
{
  extern long double __tanhl(long double __x) throw();
}
extern "C"
{
  extern void sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern void __sincosl(long double __x, long double *__sinx, long double *__cosx) throw();
}
extern "C"
{
  extern long double acoshl(long double __x) throw();
}
extern "C"
{
  extern long double __acoshl(long double __x) throw();
}
extern "C"
{
  extern long double asinhl(long double __x) throw();
}
extern "C"
{
  extern long double __asinhl(long double __x) throw();
}
extern "C"
{
  extern long double atanhl(long double __x) throw();
}
extern "C"
{
  extern long double __atanhl(long double __x) throw();
}
extern "C"
{
  extern long double expl(long double __x) throw();
}
extern "C"
{
  extern long double __expl(long double __x) throw();
}
extern "C"
{
  extern long double frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double __frexpl(long double __x, int *__exponent) throw();
}
extern "C"
{
  extern long double ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double __ldexpl(long double __x, int __exponent) throw();
}
extern "C"
{
  extern long double logl(long double __x) throw();
}
extern "C"
{
  extern long double __logl(long double __x) throw();
}
extern "C"
{
  extern long double log10l(long double __x) throw();
}
extern "C"
{
  extern long double __log10l(long double __x) throw();
}
extern "C"
{
  extern long double modfl(long double __x, long double *__iptr) throw();
}
extern "C"
{
  extern long double __modfl(long double __x, long double *__iptr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern long double exp10l(long double __x) throw();
}
extern "C"
{
  extern long double __exp10l(long double __x) throw();
}
extern "C"
{
  extern long double pow10l(long double __x) throw();
}
extern "C"
{
  extern long double __pow10l(long double __x) throw();
}
extern "C"
{
  extern long double expm1l(long double __x) throw();
}
extern "C"
{
  extern long double __expm1l(long double __x) throw();
}
extern "C"
{
  extern long double log1pl(long double __x) throw();
}
extern "C"
{
  extern long double __log1pl(long double __x) throw();
}
extern "C"
{
  extern long double logbl(long double __x) throw();
}
extern "C"
{
  extern long double __logbl(long double __x) throw();
}
extern "C"
{
  extern long double exp2l(long double __x) throw();
}
extern "C"
{
  extern long double __exp2l(long double __x) throw();
}
extern "C"
{
  extern long double log2l(long double __x) throw();
}
extern "C"
{
  extern long double __log2l(long double __x) throw();
}
extern "C"
{
  extern long double powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __powl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double __sqrtl(long double __x) throw();
}
extern "C"
{
  extern long double hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __hypotl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double __cbrtl(long double __x) throw();
}
extern "C"
{
  extern long double ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __ceill(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fabsl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __floorl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fmodl(long double __x, long double __y) throw();
}
extern "C"
{
  extern int __isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isinfl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int finitel(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __dreml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double significandl(long double __x) throw();
}
extern "C"
{
  extern long double __significandl(long double __x) throw();
}
extern "C"
{
  extern long double copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __copysignl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nanl(const char *__tagb) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int isnanl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double j0l(long double) throw();
}
extern "C"
{
  extern long double __j0l(long double) throw();
}
extern "C"
{
  extern long double j1l(long double) throw();
}
extern "C"
{
  extern long double __j1l(long double) throw();
}
extern "C"
{
  extern long double jnl(int, long double) throw();
}
extern "C"
{
  extern long double __jnl(int, long double) throw();
}
extern "C"
{
  extern long double y0l(long double) throw();
}
extern "C"
{
  extern long double __y0l(long double) throw();
}
extern "C"
{
  extern long double y1l(long double) throw();
}
extern "C"
{
  extern long double __y1l(long double) throw();
}
extern "C"
{
  extern long double ynl(int, long double) throw();
}
extern "C"
{
  extern long double __ynl(int, long double) throw();
}
extern "C"
{
  extern long double erfl(long double) throw();
}
extern "C"
{
  extern long double __erfl(long double) throw();
}
extern "C"
{
  extern long double erfcl(long double) throw();
}
extern "C"
{
  extern long double __erfcl(long double) throw();
}
extern "C"
{
  extern long double lgammal(long double) throw();
}
extern "C"
{
  extern long double __lgammal(long double) throw();
}
extern "C"
{
  extern long double tgammal(long double) throw();
}
extern "C"
{
  extern long double __tgammal(long double) throw();
}
extern "C"
{
  extern long double gammal(long double) throw();
}
extern "C"
{
  extern long double __gammal(long double) throw();
}
extern "C"
{
  extern long double lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double __lgammal_r(long double, int *__signgamp) throw();
}
extern "C"
{
  extern long double rintl(long double __x) throw();
}
extern "C"
{
  extern long double __rintl(long double __x) throw();
}
extern "C"
{
  extern long double nextafterl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nextafterl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double nexttowardl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __nexttowardl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __remainderl(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern long double __scalbnl(long double __x, int __n) throw();
}
extern "C"
{
  extern int ilogbl(long double __x) throw();
}
extern "C"
{
  extern int __ilogbl(long double __x) throw();
}
extern "C"
{
  extern long double scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double __scalblnl(long double __x, long int __n) throw();
}
extern "C"
{
  extern long double nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double __nearbyintl(long double __x) throw();
}
extern "C"
{
  extern long double roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __roundl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __truncl(long double __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long double __remquol(long double __x, long double __y, int *__quo) throw();
}
extern "C"
{
  extern long int lrintl(long double __x) throw();
}
extern "C"
{
  extern long int __lrintl(long double __x) throw();
}
extern "C"
{
  extern long long int llrintl(long double __x) throw();
}
extern "C"
{
  extern long long int __llrintl(long double __x) throw();
}
extern "C"
{
  extern long int lroundl(long double __x) throw();
}
extern "C"
{
  extern long int __lroundl(long double __x) throw();
}
extern "C"
{
  extern long long int llroundl(long double __x) throw();
}
extern "C"
{
  extern long long int __llroundl(long double __x) throw();
}
extern "C"
{
  extern long double fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double __fdiml(long double __x, long double __y) throw();
}
extern "C"
{
  extern long double fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fmaxl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double __fminl(long double __x, long double __y) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __fpclassifyl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern int __signbitl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern long double __fmal(long double __x, long double __y, long double __z) throw();
}
extern "C"
{
  extern int __issignalingl(long double __value) throw() __attribute__((__const__));
}
extern "C"
{
  extern long double scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern long double __scalbl(long double __x, long double __n) throw();
}
extern "C"
{
  extern int signgam;
}
enum mcc_enum_anon_52
{
  FP_NAN = 0,
  FP_INFINITE = 1,
  FP_ZERO = 2,
  FP_SUBNORMAL = 3,
  FP_NORMAL = 4
};
enum _LIB_VERSION_TYPE
{
  _IEEE_ =  -1,
  _SVID_ = 0,
  _XOPEN_ = 1,
  _POSIX_ = 2,
  _ISOC_ = 3
};
extern "C"
{
  extern ::_LIB_VERSION_TYPE _LIB_VERSION;
}
struct  __exception
{
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
};
extern "C"
{
  extern int matherr(::__exception *__exc) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  inline constexpr double abs(double __x)
  {
    return __builtin_fabs(__x);
  }
  inline constexpr float abs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline constexpr long double abs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type abs(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type abs(_Tp __x)
  {
    return __builtin_fabs(__x);
  }
  using ::acos;
  inline constexpr float acos(float __x)
  {
    return __builtin_acosf(__x);
  }
  inline constexpr long double acos(long double __x)
  {
    return __builtin_acosl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acos(_Tp __x)
  {
    return __builtin_acos(__x);
  }
  using ::asin;
  inline constexpr float asin(float __x)
  {
    return __builtin_asinf(__x);
  }
  inline constexpr long double asin(long double __x)
  {
    return __builtin_asinl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asin(_Tp __x)
  {
    return __builtin_asin(__x);
  }
  using ::atan;
  inline constexpr float atan(float __x)
  {
    return __builtin_atanf(__x);
  }
  inline constexpr long double atan(long double __x)
  {
    return __builtin_atanl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atan(_Tp __x)
  {
    return __builtin_atan(__x);
  }
  using ::atan2;
  inline constexpr float atan2(float __y, float __x)
  {
    return __builtin_atan2f(__y, __x);
  }
  inline constexpr long double atan2(long double __y, long double __x)
  {
    return __builtin_atan2l(__y, __x);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type atan2(_Tp __y, _Up __x)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return atan2(__type(__y), __type(__x));
  }
  using ::ceil;
  inline constexpr float ceil(float __x)
  {
    return __builtin_ceilf(__x);
  }
  inline constexpr long double ceil(long double __x)
  {
    return __builtin_ceill(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ceil(_Tp __x)
  {
    return __builtin_ceil(__x);
  }
  using ::cos;
  inline constexpr float cos(float __x)
  {
    return __builtin_cosf(__x);
  }
  inline constexpr long double cos(long double __x)
  {
    return __builtin_cosl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cos(_Tp __x)
  {
    return __builtin_cos(__x);
  }
  using ::cosh;
  inline constexpr float cosh(float __x)
  {
    return __builtin_coshf(__x);
  }
  inline constexpr long double cosh(long double __x)
  {
    return __builtin_coshl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cosh(_Tp __x)
  {
    return __builtin_cosh(__x);
  }
  using ::exp;
  inline constexpr float exp(float __x)
  {
    return __builtin_expf(__x);
  }
  inline constexpr long double exp(long double __x)
  {
    return __builtin_expl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp(_Tp __x)
  {
    return __builtin_exp(__x);
  }
  using ::fabs;
  inline constexpr float fabs(float __x)
  {
    return __builtin_fabsf(__x);
  }
  inline constexpr long double fabs(long double __x)
  {
    return __builtin_fabsl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type fabs(_Tp __x)
  {
    return __builtin_fabs(__x);
  }
  using ::floor;
  inline constexpr float floor(float __x)
  {
    return __builtin_floorf(__x);
  }
  inline constexpr long double floor(long double __x)
  {
    return __builtin_floorl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type floor(_Tp __x)
  {
    return __builtin_floor(__x);
  }
  using ::fmod;
  inline constexpr float fmod(float __x, float __y)
  {
    return __builtin_fmodf(__x, __y);
  }
  inline constexpr long double fmod(long double __x, long double __y)
  {
    return __builtin_fmodl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmod(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmod(__type(__x), __type(__y));
  }
  using ::frexp;
  inline float frexp(float __x, int *__exp)
  {
    return __builtin_frexpf(__x, __exp);
  }
  inline long double frexp(long double __x, int *__exp)
  {
    return __builtin_frexpl(__x, __exp);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type frexp(_Tp __x, int *__exp)
  {
    return __builtin_frexp(__x, __exp);
  }
  using ::ldexp;
  inline constexpr float ldexp(float __x, int __exp)
  {
    return __builtin_ldexpf(__x, __exp);
  }
  inline constexpr long double ldexp(long double __x, int __exp)
  {
    return __builtin_ldexpl(__x, __exp);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type ldexp(_Tp __x, int __exp)
  {
    return __builtin_ldexp(__x, __exp);
  }
  using ::log;
  inline constexpr float log(float __x)
  {
    return __builtin_logf(__x);
  }
  inline constexpr long double log(long double __x)
  {
    return __builtin_logl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log(_Tp __x)
  {
    return __builtin_log(__x);
  }
  using ::log10;
  inline constexpr float log10(float __x)
  {
    return __builtin_log10f(__x);
  }
  inline constexpr long double log10(long double __x)
  {
    return __builtin_log10l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log10(_Tp __x)
  {
    return __builtin_log10(__x);
  }
  using ::modf;
  inline float modf(float __x, float *__iptr)
  {
    return __builtin_modff(__x, __iptr);
  }
  inline long double modf(long double __x, long double *__iptr)
  {
    return __builtin_modfl(__x, __iptr);
  }
  using ::pow;
  inline constexpr float pow(float __x, float __y)
  {
    return __builtin_powf(__x, __y);
  }
  inline constexpr long double pow(long double __x, long double __y)
  {
    return __builtin_powl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type pow(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return pow(__type(__x), __type(__y));
  }
  using ::sin;
  inline constexpr float sin(float __x)
  {
    return __builtin_sinf(__x);
  }
  inline constexpr long double sin(long double __x)
  {
    return __builtin_sinl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sin(_Tp __x)
  {
    return __builtin_sin(__x);
  }
  using ::sinh;
  inline constexpr float sinh(float __x)
  {
    return __builtin_sinhf(__x);
  }
  inline constexpr long double sinh(long double __x)
  {
    return __builtin_sinhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sinh(_Tp __x)
  {
    return __builtin_sinh(__x);
  }
  using ::sqrt;
  inline constexpr float sqrt(float __x)
  {
    return __builtin_sqrtf(__x);
  }
  inline constexpr long double sqrt(long double __x)
  {
    return __builtin_sqrtl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type sqrt(_Tp __x)
  {
    return __builtin_sqrt(__x);
  }
  using ::tan;
  inline constexpr float tan(float __x)
  {
    return __builtin_tanf(__x);
  }
  inline constexpr long double tan(long double __x)
  {
    return __builtin_tanl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tan(_Tp __x)
  {
    return __builtin_tan(__x);
  }
  using ::tanh;
  inline constexpr float tanh(float __x)
  {
    return __builtin_tanhf(__x);
  }
  inline constexpr long double tanh(long double __x)
  {
    return __builtin_tanhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tanh(_Tp __x)
  {
    return __builtin_tanh(__x);
  }
  inline constexpr int fpclassify(float __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  inline constexpr int fpclassify(double __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  inline constexpr int fpclassify(long double __x)
  {
    return __builtin_fpclassify(0, 1, 4, 3, 2, __x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type fpclassify(_Tp __x)
  {
    return __x != 0 ? 4 : 2;
  }
  inline constexpr bool isfinite(float __x)
  {
    return __builtin_isfinite(__x);
  }
  inline constexpr bool isfinite(double __x)
  {
    return __builtin_isfinite(__x);
  }
  inline constexpr bool isfinite(long double __x)
  {
    return __builtin_isfinite(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isfinite(_Tp __x)
  {
    return true;
  }
  inline constexpr bool isinf(float __x)
  {
    return __builtin_isinf(__x);
  }
  inline constexpr bool isinf(double __x)
  {
    return __builtin_isinf(__x);
  }
  inline constexpr bool isinf(long double __x)
  {
    return __builtin_isinf(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isinf(_Tp __x)
  {
    return false;
  }
  inline constexpr bool isnan(float __x)
  {
    return __builtin_isnan(__x);
  }
  inline constexpr bool isnan(double __x)
  {
    return __builtin_isnan(__x);
  }
  inline constexpr bool isnan(long double __x)
  {
    return __builtin_isnan(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnan(_Tp __x)
  {
    return false;
  }
  inline constexpr bool isnormal(float __x)
  {
    return __builtin_isnormal(__x);
  }
  inline constexpr bool isnormal(double __x)
  {
    return __builtin_isnormal(__x);
  }
  inline constexpr bool isnormal(long double __x)
  {
    return __builtin_isnormal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type isnormal(_Tp __x)
  {
    return __x != 0 ? true : false;
  }
  inline constexpr bool signbit(float __x)
  {
    return __builtin_signbitf(__x);
  }
  inline constexpr bool signbit(double __x)
  {
    return __builtin_signbit(__x);
  }
  inline constexpr bool signbit(long double __x)
  {
    return __builtin_signbitl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, bool>::__type signbit(_Tp __x)
  {
    return __x < 0 ? true : false;
  }
  inline constexpr bool isgreater(float __x, float __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  inline constexpr bool isgreater(double __x, double __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  inline constexpr bool isgreater(long double __x, long double __y)
  {
    return __builtin_isgreater(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreater(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreater(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreater(__type(__x), __type(__y));
  }
  inline constexpr bool isgreaterequal(float __x, float __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  inline constexpr bool isgreaterequal(double __x, double __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  inline constexpr bool isgreaterequal(long double __x, long double __y)
  {
    return __builtin_isgreaterequal(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreaterequal(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isgreaterequal(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isgreaterequal(__type(__x), __type(__y));
  }
  inline constexpr bool isless(float __x, float __y)
  {
    return __builtin_isless(__x, __y);
  }
  inline constexpr bool isless(double __x, double __y)
  {
    return __builtin_isless(__x, __y);
  }
  inline constexpr bool isless(long double __x, long double __y)
  {
    return __builtin_isless(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isless(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isless(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isless(__type(__x), __type(__y));
  }
  inline constexpr bool islessequal(float __x, float __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  inline constexpr bool islessequal(double __x, double __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  inline constexpr bool islessequal(long double __x, long double __y)
  {
    return __builtin_islessequal(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessequal(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessequal(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessequal(__type(__x), __type(__y));
  }
  inline constexpr bool islessgreater(float __x, float __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  inline constexpr bool islessgreater(double __x, double __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  inline constexpr bool islessgreater(long double __x, long double __y)
  {
    return __builtin_islessgreater(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessgreater(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type islessgreater(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_islessgreater(__type(__x), __type(__y));
  }
  inline constexpr bool isunordered(float __x, float __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  inline constexpr bool isunordered(double __x, double __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  inline constexpr bool isunordered(long double __x, long double __y)
  {
    return __builtin_isunordered(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isunordered(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value && __is_arithmetic<_Up>::__value, bool>::__type isunordered(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return __builtin_isunordered(__type(__x), __type(__y));
  }
  using ::double_t;
  using ::float_t;
  using ::acosh;
  using ::acoshf;
  using ::acoshl;
  using ::asinh;
  using ::asinhf;
  using ::asinhl;
  using ::atanh;
  using ::atanhf;
  using ::atanhl;
  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;
  using ::copysign;
  using ::copysignf;
  using ::copysignl;
  using ::erf;
  using ::erff;
  using ::erfl;
  using ::erfc;
  using ::erfcf;
  using ::erfcl;
  using ::exp2;
  using ::exp2f;
  using ::exp2l;
  using ::expm1;
  using ::expm1f;
  using ::expm1l;
  using ::fdim;
  using ::fdimf;
  using ::fdiml;
  using ::fma;
  using ::fmaf;
  using ::fmal;
  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;
  using ::fmin;
  using ::fminf;
  using ::fminl;
  using ::hypot;
  using ::hypotf;
  using ::hypotl;
  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;
  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;
  using ::llrint;
  using ::llrintf;
  using ::llrintl;
  using ::llround;
  using ::llroundf;
  using ::llroundl;
  using ::log1p;
  using ::log1pf;
  using ::log1pl;
  using ::log2;
  using ::log2f;
  using ::log2l;
  using ::logb;
  using ::logbf;
  using ::logbl;
  using ::lrint;
  using ::lrintf;
  using ::lrintl;
  using ::lround;
  using ::lroundf;
  using ::lroundl;
  using ::nan;
  using ::nanf;
  using ::nanl;
  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;
  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;
  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;
  using ::remainder;
  using ::remainderf;
  using ::remainderl;
  using ::remquo;
  using ::remquof;
  using ::remquol;
  using ::rint;
  using ::rintf;
  using ::rintl;
  using ::round;
  using ::roundf;
  using ::roundl;
  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;
  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;
  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;
  using ::trunc;
  using ::truncf;
  using ::truncl;
  inline constexpr float acosh(float __x)
  {
    return __builtin_acoshf(__x);
  }
  inline constexpr long double acosh(long double __x)
  {
    return __builtin_acoshl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type acosh(_Tp __x)
  {
    return __builtin_acosh(__x);
  }
  inline constexpr float asinh(float __x)
  {
    return __builtin_asinhf(__x);
  }
  inline constexpr long double asinh(long double __x)
  {
    return __builtin_asinhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type asinh(_Tp __x)
  {
    return __builtin_asinh(__x);
  }
  inline constexpr float atanh(float __x)
  {
    return __builtin_atanhf(__x);
  }
  inline constexpr long double atanh(long double __x)
  {
    return __builtin_atanhl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type atanh(_Tp __x)
  {
    return __builtin_atanh(__x);
  }
  inline constexpr float cbrt(float __x)
  {
    return __builtin_cbrtf(__x);
  }
  inline constexpr long double cbrt(long double __x)
  {
    return __builtin_cbrtl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type cbrt(_Tp __x)
  {
    return __builtin_cbrt(__x);
  }
  inline constexpr float copysign(float __x, float __y)
  {
    return __builtin_copysignf(__x, __y);
  }
  inline constexpr long double copysign(long double __x, long double __y)
  {
    return __builtin_copysignl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type copysign(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return copysign(__type(__x), __type(__y));
  }
  inline constexpr float erf(float __x)
  {
    return __builtin_erff(__x);
  }
  inline constexpr long double erf(long double __x)
  {
    return __builtin_erfl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erf(_Tp __x)
  {
    return __builtin_erf(__x);
  }
  inline constexpr float erfc(float __x)
  {
    return __builtin_erfcf(__x);
  }
  inline constexpr long double erfc(long double __x)
  {
    return __builtin_erfcl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type erfc(_Tp __x)
  {
    return __builtin_erfc(__x);
  }
  inline constexpr float exp2(float __x)
  {
    return __builtin_exp2f(__x);
  }
  inline constexpr long double exp2(long double __x)
  {
    return __builtin_exp2l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type exp2(_Tp __x)
  {
    return __builtin_exp2(__x);
  }
  inline constexpr float expm1(float __x)
  {
    return __builtin_expm1f(__x);
  }
  inline constexpr long double expm1(long double __x)
  {
    return __builtin_expm1l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type expm1(_Tp __x)
  {
    return __builtin_expm1(__x);
  }
  inline constexpr float fdim(float __x, float __y)
  {
    return __builtin_fdimf(__x, __y);
  }
  inline constexpr long double fdim(long double __x, long double __y)
  {
    return __builtin_fdiml(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fdim(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fdim(__type(__x), __type(__y));
  }
  inline constexpr float fma(float __x, float __y, float __z)
  {
    return __builtin_fmaf(__x, __y, __z);
  }
  inline constexpr long double fma(long double __x, long double __y, long double __z)
  {
    return __builtin_fmal(__x, __y, __z);
  }
  template < typename _Tp, typename _Up, typename _Vp >
  inline constexpr typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z);
  template < typename _Tp, typename _Up, typename _Vp >
  inline constexpr typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type fma(_Tp __x, _Up __y, _Vp __z)
  {
    typedef typename ::__gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
    return fma(__type(__x), __type(__y), __type(__z));
  }
  inline constexpr float fmax(float __x, float __y)
  {
    return __builtin_fmaxf(__x, __y);
  }
  inline constexpr long double fmax(long double __x, long double __y)
  {
    return __builtin_fmaxl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmax(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmax(__type(__x), __type(__y));
  }
  inline constexpr float fmin(float __x, float __y)
  {
    return __builtin_fminf(__x, __y);
  }
  inline constexpr long double fmin(long double __x, long double __y)
  {
    return __builtin_fminl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type fmin(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return fmin(__type(__x), __type(__y));
  }
  inline constexpr float hypot(float __x, float __y)
  {
    return __builtin_hypotf(__x, __y);
  }
  inline constexpr long double hypot(long double __x, long double __y)
  {
    return __builtin_hypotl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type hypot(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return hypot(__type(__x), __type(__y));
  }
  inline constexpr int ilogb(float __x)
  {
    return __builtin_ilogbf(__x);
  }
  inline constexpr int ilogb(long double __x)
  {
    return __builtin_ilogbl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, int>::__type ilogb(_Tp __x)
  {
    return __builtin_ilogb(__x);
  }
  inline constexpr float lgamma(float __x)
  {
    return __builtin_lgammaf(__x);
  }
  inline constexpr long double lgamma(long double __x)
  {
    return __builtin_lgammal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type lgamma(_Tp __x)
  {
    return __builtin_lgamma(__x);
  }
  inline constexpr long long int llrint(float __x)
  {
    return __builtin_llrintf(__x);
  }
  inline constexpr long long int llrint(long double __x)
  {
    return __builtin_llrintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llrint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llrint(_Tp __x)
  {
    return __builtin_llrint(__x);
  }
  inline constexpr long long int llround(float __x)
  {
    return __builtin_llroundf(__x);
  }
  inline constexpr long long int llround(long double __x)
  {
    return __builtin_llroundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llround(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long long int>::__type llround(_Tp __x)
  {
    return __builtin_llround(__x);
  }
  inline constexpr float log1p(float __x)
  {
    return __builtin_log1pf(__x);
  }
  inline constexpr long double log1p(long double __x)
  {
    return __builtin_log1pl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log1p(_Tp __x)
  {
    return __builtin_log1p(__x);
  }
  inline constexpr float log2(float __x)
  {
    return __builtin_log2f(__x);
  }
  inline constexpr long double log2(long double __x)
  {
    return __builtin_log2l(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type log2(_Tp __x)
  {
    return __builtin_log2(__x);
  }
  inline constexpr float logb(float __x)
  {
    return __builtin_logbf(__x);
  }
  inline constexpr long double logb(long double __x)
  {
    return __builtin_logbl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type logb(_Tp __x)
  {
    return __builtin_logb(__x);
  }
  inline constexpr long int lrint(float __x)
  {
    return __builtin_lrintf(__x);
  }
  inline constexpr long int lrint(long double __x)
  {
    return __builtin_lrintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lrint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lrint(_Tp __x)
  {
    return __builtin_lrint(__x);
  }
  inline constexpr long int lround(float __x)
  {
    return __builtin_lroundf(__x);
  }
  inline constexpr long int lround(long double __x)
  {
    return __builtin_lroundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lround(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, long int>::__type lround(_Tp __x)
  {
    return __builtin_lround(__x);
  }
  inline constexpr float nearbyint(float __x)
  {
    return __builtin_nearbyintf(__x);
  }
  inline constexpr long double nearbyint(long double __x)
  {
    return __builtin_nearbyintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nearbyint(_Tp __x)
  {
    return __builtin_nearbyint(__x);
  }
  inline constexpr float nextafter(float __x, float __y)
  {
    return __builtin_nextafterf(__x, __y);
  }
  inline constexpr long double nextafter(long double __x, long double __y)
  {
    return __builtin_nextafterl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type nextafter(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return nextafter(__type(__x), __type(__y));
  }
  inline constexpr float nexttoward(float __x, long double __y)
  {
    return __builtin_nexttowardf(__x, __y);
  }
  inline constexpr long double nexttoward(long double __x, long double __y)
  {
    return __builtin_nexttowardl(__x, __y);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type nexttoward(_Tp __x, long double __y)
  {
    return __builtin_nexttoward(__x, __y);
  }
  inline constexpr float remainder(float __x, float __y)
  {
    return __builtin_remainderf(__x, __y);
  }
  inline constexpr long double remainder(long double __x, long double __y)
  {
    return __builtin_remainderl(__x, __y);
  }
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y);
  template < typename _Tp, typename _Up >
  inline constexpr typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remainder(_Tp __x, _Up __y)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remainder(__type(__x), __type(__y));
  }
  inline float remquo(float __x, float __y, int *__pquo)
  {
    return __builtin_remquof(__x, __y, __pquo);
  }
  inline long double remquo(long double __x, long double __y, int *__pquo)
  {
    return __builtin_remquol(__x, __y, __pquo);
  }
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo);
  template < typename _Tp, typename _Up >
  inline typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type remquo(_Tp __x, _Up __y, int *__pquo)
  {
    typedef typename ::__gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
    return remquo(__type(__x), __type(__y), __pquo);
  }
  inline constexpr float rint(float __x)
  {
    return __builtin_rintf(__x);
  }
  inline constexpr long double rint(long double __x)
  {
    return __builtin_rintl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type rint(_Tp __x)
  {
    return __builtin_rint(__x);
  }
  inline constexpr float round(float __x)
  {
    return __builtin_roundf(__x);
  }
  inline constexpr long double round(long double __x)
  {
    return __builtin_roundl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type round(_Tp __x)
  {
    return __builtin_round(__x);
  }
  inline constexpr float scalbln(float __x, long int __ex)
  {
    return __builtin_scalblnf(__x, __ex);
  }
  inline constexpr long double scalbln(long double __x, long int __ex)
  {
    return __builtin_scalblnl(__x, __ex);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long int __ex);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbln(_Tp __x, long int __ex)
  {
    return __builtin_scalbln(__x, __ex);
  }
  inline constexpr float scalbn(float __x, int __ex)
  {
    return __builtin_scalbnf(__x, __ex);
  }
  inline constexpr long double scalbn(long double __x, int __ex)
  {
    return __builtin_scalbnl(__x, __ex);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type scalbn(_Tp __x, int __ex)
  {
    return __builtin_scalbn(__x, __ex);
  }
  inline constexpr float tgamma(float __x)
  {
    return __builtin_tgammaf(__x);
  }
  inline constexpr long double tgamma(long double __x)
  {
    return __builtin_tgammal(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type tgamma(_Tp __x)
  {
    return __builtin_tgamma(__x);
  }
  inline constexpr float trunc(float __x)
  {
    return __builtin_truncf(__x);
  }
  inline constexpr long double trunc(long double __x)
  {
    return __builtin_truncl(__x);
  }
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x);
  template < typename _Tp >
  inline constexpr typename ::__gnu_cxx::__enable_if<__is_integer<_Tp>::__value, double>::__type trunc(_Tp __x)
  {
    return __builtin_trunc(__x);
  }
  template < typename __type_tpl__param_1_0__ >
  class allocator;
  template <>
  class allocator<void>;
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct uses_allocator;
  template < typename _CharT >
  struct char_traits;
  template <>
  struct char_traits<char>;
  template <>
  struct char_traits<wchar_t>;
  template <>
  struct char_traits<char16_t>;
  template <>
  struct char_traits<char32_t>;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_string;
    typedef ::std::__cxx11::basic_string<char> string;
    typedef ::std::__cxx11::basic_string<wchar_t> wstring;
    typedef ::std::__cxx11::basic_string<char16_t> u16string;
    typedef ::std::__cxx11::basic_string<char32_t> u32string;
  }
}
typedef unsigned int wint_t;
typedef ::__mbstate_t mbstate_t;
struct tm;
extern "C"
{
  extern wchar_t *wcscpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wcscat(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcsncat(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscmp(const wchar_t *__s1, const wchar_t *__s2) throw() __attribute__((__pure__));
}
extern "C"
{
  extern int wcsncmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__));
}
extern "C"
{
  extern int wcscasecmp(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern int wcsncasecmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
struct __locale_data;
struct  __locale_struct
{
    ::__locale_data *__locales[13L];
    const unsigned short int *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13L];
};
typedef ::__locale_struct *__locale_t;
typedef ::__locale_t locale_t;
extern "C"
{
  extern int wcscasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcsncasecmp_l(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern int wcscoll(const wchar_t *__s1, const wchar_t *__s2) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::size_t wcsxfrm_l(wchar_t *__s1, const wchar_t *__s2, ::size_t __n, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcsdup(const wchar_t *__s) throw() __attribute__((__malloc__));
}
wchar_t *wcschr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
const wchar_t *wcschr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcschr") __attribute__((__pure__));
wchar_t *wcsrchr(wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
const wchar_t *wcsrchr(const wchar_t *__wcs, wchar_t __wc) throw() __asm("wcsrchr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcschrnul(const wchar_t *__s, wchar_t __wc) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcscspn(const wchar_t *__wcs, const wchar_t *__reject) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t wcsspn(const wchar_t *__wcs, const wchar_t *__accept) throw() __attribute__((__pure__));
}
wchar_t *wcspbrk(wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
const wchar_t *wcspbrk(const wchar_t *__wcs, const wchar_t *__accept) throw() __asm("wcspbrk") __attribute__((__pure__));
wchar_t *wcsstr(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
const wchar_t *wcsstr(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcsstr") __attribute__((__pure__));
extern "C"
{
  extern wchar_t *wcstok(wchar_t *__restrict __s, const wchar_t *__restrict __delim, wchar_t **__restrict __ptr) throw();
}
extern "C"
{
  extern ::size_t wcslen(const wchar_t *__s) throw() __attribute__((__pure__));
}
wchar_t *wcswcs(wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
const wchar_t *wcswcs(const wchar_t *__haystack, const wchar_t *__needle) throw() __asm("wcswcs") __attribute__((__pure__));
extern "C"
{
  extern ::size_t wcsnlen(const wchar_t *__s, ::size_t __maxlen) throw() __attribute__((__pure__));
}
wchar_t *wmemchr(wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
const wchar_t *wmemchr(const wchar_t *__s, wchar_t __c, ::size_t __n) throw() __asm("wmemchr") __attribute__((__pure__));
extern "C"
{
  extern int wmemcmp(const wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw() __attribute__((__pure__));
}
extern "C"
{
  extern wchar_t *wmemcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemmove(wchar_t *__s1, const wchar_t *__s2, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmemset(wchar_t *__s, wchar_t __c, ::size_t __n) throw();
}
extern "C"
{
  extern wchar_t *wmempcpy(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, ::size_t __n) throw();
}
extern "C"
{
  extern inline ::wint_t btowc(int __c) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int wctob(::wint_t __wc) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int mbsinit(const ::mbstate_t *__ps) throw() __attribute__((__pure__));
}
extern "C"
{
  extern ::size_t mbrtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __p) throw();
}
extern "C"
{
  extern ::size_t wcrtomb(char *__restrict __s, wchar_t __wc, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t __mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern inline ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw() __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern ::wint_t __btowc_alias(int __c) __asm("btowc");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::wint_t btowc(int __c) throw()
  {
    return (__builtin_constant_p(__c) && __c >= '\000') && __c <= '\177' ? (::wint_t)__c : ::__btowc_alias(__c);
  }
}
extern "C"
{
  extern int __wctob_alias(::wint_t __c) __asm("wctob");
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int wctob(::wint_t __wc) throw()
  {
    return (__builtin_constant_p(__wc) && __wc >= L'\x0000') && __wc <= L'\x007f' ? (int)__wc : ::__wctob_alias(__wc);
  }
}
extern "C"
{
  extern inline __attribute__((__leaf__)) __attribute__((__gnu_inline__)) ::size_t mbrlen(const char *__restrict __s, ::size_t __n, ::mbstate_t *__restrict __ps) throw()
  {
    return __ps != 0L ? ::mbrtowc(0L, __s, __n, __ps) : ::__mbrlen(__s, __n, 0L);
  }
}
extern "C"
{
  extern ::size_t mbsrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t mbsnrtowcs(wchar_t *__restrict __dst, const char **__restrict __src, ::size_t __nmc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern ::size_t wcsnrtombs(char *__restrict __dst, const wchar_t **__restrict __src, ::size_t __nwc, ::size_t __len, ::mbstate_t *__restrict __ps) throw();
}
extern "C"
{
  extern int wcwidth(wchar_t __c) throw();
}
extern "C"
{
  extern int wcswidth(const wchar_t *__s, ::size_t __n) throw();
}
extern "C"
{
  extern double wcstod(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern float wcstof(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long double wcstold(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr) throw();
}
extern "C"
{
  extern long int wcstol(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long int wcstoul(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoll(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long long int wcstoq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern unsigned long long int wcstouq(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base) throw();
}
extern "C"
{
  extern long int wcstol_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long int wcstoul_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long long int wcstoll_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern unsigned long long int wcstoull_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, int __base, ::__locale_t __loc) throw();
}
extern "C"
{
  extern double wcstod_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern float wcstof_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern long double wcstold_l(const wchar_t *__restrict __nptr, wchar_t **__restrict __endptr, ::__locale_t __loc) throw();
}
extern "C"
{
  extern wchar_t *wcpcpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src) throw();
}
extern "C"
{
  extern wchar_t *wcpncpy(wchar_t *__restrict __dest, const wchar_t *__restrict __src, ::size_t __n) throw();
}
extern "C"
{
  extern ::__FILE *open_wmemstream(wchar_t **__bufloc, ::size_t *__sizeloc) throw();
}
extern "C"
{
  extern int fwide(::__FILE *__fp, int __mode) throw();
}
extern "C"
{
  extern int fwprintf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wprintf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwprintf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwprintf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswprintf(wchar_t *__restrict __s, ::size_t __n, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern int fwscanf(::__FILE *__restrict __stream, const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int wscanf(const wchar_t *__restrict __format, ...);
}
extern "C"
{
  extern int swscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) throw();
}
extern "C"
{
  extern int vfwscanf(::__FILE *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vwscanf(const wchar_t *__restrict __format, ::__gnuc_va_list __arg);
}
extern "C"
{
  extern int vswscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ::__gnuc_va_list __arg) throw();
}
extern "C"
{
  extern ::wint_t fgetwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar();
}
extern "C"
{
  extern ::wint_t fputwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::wint_t ungetwc(::wint_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t getwchar_unlocked();
}
extern "C"
{
  extern ::wint_t fgetwc_unlocked(::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t fputwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwc_unlocked(wchar_t __wc, ::__FILE *__stream);
}
extern "C"
{
  extern ::wint_t putwchar_unlocked(wchar_t __wc);
}
extern "C"
{
  extern wchar_t *fgetws_unlocked(wchar_t *__restrict __ws, int __n, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern int fputws_unlocked(const wchar_t *__restrict __ws, ::__FILE *__restrict __stream);
}
extern "C"
{
  extern ::size_t wcsftime(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::size_t wcsftime_l(wchar_t *__restrict __s, ::size_t __maxsize, const wchar_t *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::mbstate_t;
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
  using ::std::wcstof;
  using ::std::vfwscanf;
  using ::std::vswscanf;
  using ::std::vwscanf;
  using ::std::wcstold;
  using ::std::wcstoll;
  using ::std::wcstoull;
  typedef long int streamoff;
  typedef ::std::ptrdiff_t streamsize;
  template < typename _StateT >
  class  fpos
  {
      ::std::streamoff _M_off;
      _StateT _M_state;
    public:
      inline fpos()
        : _M_off(0), _M_state()
      {
      }
      inline fpos(::std::streamoff __off)
        : _M_off(__off), _M_state()
      {
      }
      inline operator ::std::streamoff() const 
      {
        return ::std::fpos<_StateT>::_M_off;
      }
      inline void state(_StateT __st)
      {
        ::std::fpos<_StateT>::_M_state = __st;
      }
      inline _StateT state() const 
      {
        return ::std::fpos<_StateT>::_M_state;
      }
      inline ::std::fpos<_StateT> &operator +=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off += __off;
        return *this;
      }
      inline ::std::fpos<_StateT> &operator -=(::std::streamoff __off)
      {
        ::std::fpos<_StateT>::_M_off -= __off;
        return *this;
      }
      inline ::std::fpos<_StateT> operator +(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos += __off;
        return __pos;
      }
      inline ::std::fpos<_StateT> operator -(::std::streamoff __off) const 
      {
        ::std::fpos<_StateT> __pos(*this);
        __pos -= __off;
        return __pos;
      }
      inline ::std::streamoff operator -(const ::std::fpos<_StateT> &__other) const 
      {
        return ::std::fpos<_StateT>::_M_off - __other._M_off;
      }
  };
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator ==(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) == long(__rhs);
  }
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs);
  template < typename _StateT >
  inline bool operator !=(const ::std::fpos<_StateT> &__lhs, const ::std::fpos<_StateT> &__rhs)
  {
    return long(__lhs) != long(__rhs);
  }
  typedef ::std::fpos< ::__mbstate_t> streampos;
  typedef ::std::fpos< ::__mbstate_t> wstreampos;
  typedef ::std::fpos< ::__mbstate_t> u16streampos;
  typedef ::std::fpos< ::__mbstate_t> u32streampos;
  class ios_base;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ios;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_streambuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_istream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ostream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_iostream;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_stringbuf;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_istringstream;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_ostringstream;
    template < typename _CharT, typename _Traits = ::std::char_traits<_CharT>, typename _Alloc = ::std::allocator<_CharT> >
    class basic_stringstream;
  }
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_filebuf;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ifstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_ofstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class basic_fstream;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits = ::std::char_traits<_CharT> >
  class ostreambuf_iterator;
  typedef ::std::basic_ios<char> ios;
  typedef ::std::basic_streambuf<char> streambuf;
  typedef ::std::basic_istream<char> istream;
  typedef ::std::basic_ostream<char> ostream;
  typedef ::std::basic_iostream<char> iostream;
  typedef ::std::__cxx11::basic_stringbuf<char> stringbuf;
  typedef ::std::__cxx11::basic_istringstream<char> istringstream;
  typedef ::std::__cxx11::basic_ostringstream<char> ostringstream;
  typedef ::std::__cxx11::basic_stringstream<char> stringstream;
  typedef ::std::basic_filebuf<char> filebuf;
  typedef ::std::basic_ifstream<char> ifstream;
  typedef ::std::basic_ofstream<char> ofstream;
  typedef ::std::basic_fstream<char> fstream;
  typedef ::std::basic_ios<wchar_t> wios;
  typedef ::std::basic_streambuf<wchar_t> wstreambuf;
  typedef ::std::basic_istream<wchar_t> wistream;
  typedef ::std::basic_ostream<wchar_t> wostream;
  typedef ::std::basic_iostream<wchar_t> wiostream;
  typedef ::std::__cxx11::basic_stringbuf<wchar_t> wstringbuf;
  typedef ::std::__cxx11::basic_istringstream<wchar_t> wistringstream;
  typedef ::std::__cxx11::basic_ostringstream<wchar_t> wostringstream;
  typedef ::std::__cxx11::basic_stringstream<wchar_t> wstringstream;
  typedef ::std::basic_filebuf<wchar_t> wfilebuf;
  typedef ::std::basic_ifstream<wchar_t> wifstream;
  typedef ::std::basic_ofstream<wchar_t> wofstream;
  typedef ::std::basic_fstream<wchar_t> wfstream;
}
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  exception
  {
    public:
      inline exception() noexcept(true)
      {
      }
      virtual ~exception() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  bad_exception : public ::std::exception
  {
    public:
      inline bad_exception() noexcept(true)
      {
      }
      virtual ~bad_exception() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  typedef void (*terminate_handler)();
  typedef void (*unexpected_handler)();
  ::std::terminate_handler set_terminate(::std::terminate_handler) noexcept(true);
  ::std::terminate_handler get_terminate() noexcept(true);
  void terminate() noexcept(true) __attribute__((__noreturn__));
  ::std::unexpected_handler set_unexpected(::std::unexpected_handler) noexcept(true);
  ::std::unexpected_handler get_unexpected() noexcept(true);
  void unexpected() __attribute__((__noreturn__));
  bool uncaught_exception() noexcept(true) __attribute__((__pure__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  void __verbose_terminate_handler();
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class type_info;
  namespace __exception_ptr {
    class exception_ptr;
  }
  using ::std::__exception_ptr::exception_ptr;
  ::std::__exception_ptr::exception_ptr current_exception() noexcept(true);
  void rethrow_exception(::std::__exception_ptr::exception_ptr) __attribute__((__noreturn__));
  namespace __exception_ptr {
    class  exception_ptr
    {
        void *_M_exception_object;
        explicit exception_ptr(void *__e) noexcept(true);
        void _M_addref() noexcept(true);
        void _M_release() noexcept(true);
        void *_M_get() const  noexcept(true) __attribute__((__pure__));
      public:
        exception_ptr() noexcept(true);
        exception_ptr(const ::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline exception_ptr(::std::nullptr_t) noexcept(true)
          : _M_exception_object(0)
        {
        }
        inline exception_ptr(::std::__exception_ptr::exception_ptr &&__o) noexcept(true)
          : _M_exception_object(__o._M_exception_object)
        {
          __o._M_exception_object = 0;
        }
        ::std::__exception_ptr::exception_ptr &operator =(const ::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline ::std::__exception_ptr::exception_ptr &operator =(::std::__exception_ptr::exception_ptr &&__o) noexcept(true)
        {
          ::std::__exception_ptr::exception_ptr(static_cast< ::std::__exception_ptr::exception_ptr &&>(__o)).::std::__exception_ptr::exception_ptr::swap(*this);
          return *this;
        }
        ~exception_ptr() noexcept(true);
        void swap(::std::__exception_ptr::exception_ptr &) noexcept(true);
        inline explicit operator bool() const 
        {
          return (*this)._M_exception_object;
        }
        const ::std::type_info *__cxa_exception_type() const  noexcept(true) __attribute__((__pure__));
      friend ::std::__exception_ptr::exception_ptr (::std::current_exception)() noexcept(true);
      friend void (::std::rethrow_exception)(::std::__exception_ptr::exception_ptr);
      friend bool operator ==(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true);
    };
    bool operator ==(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true) __attribute__((__pure__));
    bool operator !=(const ::std::__exception_ptr::exception_ptr &, const ::std::__exception_ptr::exception_ptr &) noexcept(true) __attribute__((__pure__));
    inline void swap(::std::__exception_ptr::exception_ptr &__lhs, ::std::__exception_ptr::exception_ptr &__rhs)
    {
      __lhs.::std::__exception_ptr::exception_ptr::swap(__rhs);
    }
  }
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept(true);
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr make_exception_ptr(_Ex __ex) noexcept(true)
  {
    try
    {
      throw __ex;
    }
    catch (...)
    {
      return ::std::current_exception();
    }
  }
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr copy_exception(_Ex __ex) noexcept(true);
  template < typename _Ex >
  ::std::__exception_ptr::exception_ptr copy_exception(_Ex __ex) noexcept(true)
  {
    return std::make_exception_ptr<_Ex>(__ex);
  }
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  nested_exception
  {
      ::std::__exception_ptr::exception_ptr _M_ptr;
    public:
      inline nested_exception() noexcept(true)
        : _M_ptr(::std::current_exception())
      {
      }
      nested_exception(const ::std::nested_exception &) noexcept(true) = default ;
      ::std::nested_exception &operator =(const ::std::nested_exception &) noexcept(true) = default ;
      virtual ~nested_exception() noexcept(true);
      inline __attribute__((noreturn)) void rethrow_nested() const 
      {
        if ((*this)._M_ptr)
          {
            ::std::rethrow_exception((*this)._M_ptr);
          }
        std::terminate();
      }
      inline ::std::__exception_ptr::exception_ptr nested_ptr() const  noexcept(true)
      {
        return (*this)._M_ptr;
      }
  };
  template < typename _Except >
  struct  _Nested_exception : _Except, ::std::nested_exception
  {
      inline explicit _Nested_exception(const _Except &__ex)
        : _Except(__ex)
      {
      }
      inline explicit _Nested_exception(_Except &&__ex)
        : _Except(static_cast<_Except &&>(__ex))
      {
      }
  };
  template < typename _Tp, bool __with_nested = !(__is_base_of(::std::nested_exception, _Tp)) >
  struct  _Throw_with_nested_impl
  {
      template < typename _Up >
      static inline void _S_throw(_Up &&__t)
      {
        throw ::std::_Nested_exception<_Tp>{ static_cast<_Up &&>(__t) };
      }
  };
  template < typename _Tp >
  struct  _Throw_with_nested_impl<_Tp, false>
  {
      template < typename _Up >
      static inline void _S_throw(_Up &&__t)
      {
        throw static_cast<_Up &&>(__t);
      }
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = (__is_class(_Tp)) && !(__is_final(_Tp)) >
  struct  _Throw_with_nested_helper : ::std::_Throw_with_nested_impl<_Tp>
  {
  };
  template < typename _Tp >
  struct  _Throw_with_nested_helper<_Tp, false> : ::std::_Throw_with_nested_impl<_Tp, false>
  {
  };
  template < typename _Tp >
  struct  _Throw_with_nested_helper<_Tp &, false> : ::std::_Throw_with_nested_helper<_Tp>
  {
  };
  template < typename _Tp >
  struct  _Throw_with_nested_helper<_Tp &&, false> : ::std::_Throw_with_nested_helper<_Tp>
  {
  };
  template < typename _Tp >
  inline void throw_with_nested(_Tp &&__t) __attribute__((noreturn));
  template < typename _Tp >
  inline __attribute__((noreturn)) void throw_with_nested(_Tp &&__t)
  {
    _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp &&>(__t));
  }
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_polymorphic(_Tp) >
  struct  _Rethrow_if_nested_impl
  {
      static inline void _S_rethrow(const _Tp &__t)
      {
        if (const ::std::nested_exception *__tp = dynamic_cast<const ::std::nested_exception *>(&__t))
          {
            (*__tp).::std::nested_exception::rethrow_nested();
          }
      }
  };
  template < typename _Tp >
  struct  _Rethrow_if_nested_impl<_Tp, false>
  {
      static inline void _S_rethrow(const _Tp &)
      {
      }
  };
  template < typename _Ex >
  inline void rethrow_if_nested(const _Ex &__ex);
  template < typename _Ex >
  inline void rethrow_if_nested(const _Ex &__ex)
  {
    _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
  }
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  void __throw_bad_exception() __attribute__((__noreturn__));
  void __throw_bad_alloc() __attribute__((__noreturn__));
  void __throw_bad_cast() __attribute__((__noreturn__));
  void __throw_bad_typeid() __attribute__((__noreturn__));
  void __throw_logic_error(const char *) __attribute__((__noreturn__));
  void __throw_domain_error(const char *) __attribute__((__noreturn__));
  void __throw_invalid_argument(const char *) __attribute__((__noreturn__));
  void __throw_length_error(const char *) __attribute__((__noreturn__));
  void __throw_out_of_range(const char *) __attribute__((__noreturn__));
  void __throw_out_of_range_fmt(const char *, ...) __attribute__((__noreturn__)) __attribute__((__format__(__gnu_printf__, 1, 2)));
  void __throw_runtime_error(const char *) __attribute__((__noreturn__));
  void __throw_range_error(const char *) __attribute__((__noreturn__));
  void __throw_overflow_error(const char *) __attribute__((__noreturn__));
  void __throw_underflow_error(const char *) __attribute__((__noreturn__));
  void __throw_ios_failure(const char *) __attribute__((__noreturn__));
  void __throw_system_error(int) __attribute__((__noreturn__));
  void __throw_future_error(int) __attribute__((__noreturn__));
  void __throw_bad_function_call() __attribute__((__noreturn__));
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Value >
  struct  __numeric_traits_integer
  {
      static const _Value __min = ((_Value) -1 < 0 ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0)) : (_Value)0);
      static const _Value __max = ((_Value) -1 < 0 ? ((((_Value)1 << (sizeof(_Value) * 8 - ((_Value) -1 < 0) - 1)) - 1) << 1) + 1 : ~((_Value)0));
      static const bool __is_signed = (_Value) -1 < 0;
      static const int __digits = sizeof(_Value) * 8 - ((_Value) -1 < 0);
  };
  template < typename _Value >
  struct  __numeric_traits_floating
  {
      static const int __max_digits10 = 2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 113) * 643L / 2136;
      static const bool __is_signed = true;
      static const int __digits10 = std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 33;
      static const int __max_exponent10 = std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932;
  };
  template < typename _Value >
  struct  __numeric_traits : ::__gnu_cxx::__conditional_type<std::__is_integer<_Value>::__value, ::__gnu_cxx::__numeric_traits_integer<_Value>, ::__gnu_cxx::__numeric_traits_floating<_Value> >::__type
  {
  };
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r) noexcept(true);
  template < typename _Tp >
  inline _Tp *__addressof(_Tp &__r) noexcept(true)
  {
    return reinterpret_cast<_Tp *>(&const_cast<char &>(reinterpret_cast<const volatile char &>(__r)));
  }
  typedef unsigned short int uint_least16_t;
  typedef unsigned int uint_least32_t;
  template < typename _Tp, _Tp __v >
  struct  integral_constant
  {
      static constexpr const _Tp value = __v;
      typedef _Tp value_type;
      typedef ::std::integral_constant<_Tp, __v> type;
      inline constexpr operator typename ::std::integral_constant<_Tp, __v>::value_type() const 
      {
        return ::std::integral_constant<_Tp, __v>::value;
      }
  };
  typedef ::std::integral_constant<bool, true> true_type;
  typedef ::std::integral_constant<bool, false> false_type;
  template < bool __v >
  using __bool_constant = ::std::integral_constant<bool, __v>;
  template < bool __nontype_tpl_param_1_0__, typename __type_tpl__param_1_1__, typename __type_tpl__param_1_2__ >
  struct conditional;
  template < typename ...__type_tpl__param_1_0__ >
  struct __or_;
 /* Instantiation of class template '::std::integral_constant<bool, false>' */ 
  template <>
  struct  __or_<> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _B1 >
  struct  __or_<_B1> : _B1
  {
  };
  template < typename _B1, typename _B2 >
  struct  __or_<_B1, _B2> : ::std::conditional<_B1::value, _B1, _B2>::type
  {
  };
  template < typename _B1, typename _B2, typename _B3, typename ..._Bn >
  struct  __or_<_B1, _B2, _B3, _Bn ...> : ::std::conditional<_B1::value, _B1, ::std::__or_<_B2, _B3, _Bn ...> >::type
  {
  };
  template < typename ...__type_tpl__param_1_0__ >
  struct __and_;
 /* Instantiation of class template '::std::integral_constant<bool, true>' */ 
  template <>
  struct  __and_<> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _B1 >
  struct  __and_<_B1> : _B1
  {
  };
  template < typename _B1, typename _B2 >
  struct  __and_<_B1, _B2> : ::std::conditional<_B1::value, _B2, _B1>::type
  {
  };
  template < typename _B1, typename _B2, typename _B3, typename ..._Bn >
  struct  __and_<_B1, _B2, _B3, _Bn ...> : ::std::conditional<_B1::value, ::std::__and_<_B2, _B3, _Bn ...>, _B1>::type
  {
  };
  template < typename _Pp >
  struct  __not_ : ::std::integral_constant<bool, !_Pp::value>
  {
  };
  template < typename _Tp >
  struct  __success_type
  {
      typedef _Tp type;
  };
  struct  __failure_type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct remove_cv;
  template < typename __type_tpl__param_1_0__ >
  struct  __is_void_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_void_helper<void> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_void : ::std::__is_void_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_integral_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_integral_helper<bool> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<signed char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned char> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<wchar_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char16_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<char32_t> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<short int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned short int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<long long int> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_integral_helper<unsigned long long int> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_integral : ::std::__is_integral_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_floating_point_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_floating_point_helper<float> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_floating_point_helper<double> : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_floating_point_helper<long double> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_floating_point : ::std::__is_floating_point_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_array : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  is_array<_Tp [_Size]> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_array<_Tp []> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_pointer_helper<_Tp *> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_pointer : ::std::__is_pointer_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_lvalue_reference : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_lvalue_reference<_Tp &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_rvalue_reference : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_rvalue_reference<_Tp &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct is_function;
  template < typename __type_tpl__param_1_0__ >
  struct  __is_member_object_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_object_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, !is_function<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  is_member_object_pointer : ::std::__is_member_object_pointer_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_member_function_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_function_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, is_function<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  is_member_function_pointer : ::std::__is_member_function_pointer_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  is_enum : ::std::integral_constant<bool, __is_enum(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_union : ::std::integral_constant<bool, __is_union(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_class : ::std::integral_constant<bool, __is_class(_Tp)>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_function : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) volatile  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) volatile  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) volatile  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) volatile  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const volatile  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ...) const volatile  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const volatile > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const volatile  &> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._ArgTypes >
  struct  is_function<_Res (_ArgTypes ..., ...) const volatile  &&> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  __is_null_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  __is_null_pointer_helper<decltype(nullptr)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_null_pointer : ::std::__is_null_pointer_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_nullptr_t : ::std::is_null_pointer<_Tp>
  {
  };
  template < typename _Tp >
  struct  is_reference : ::std::__or_< ::std::is_lvalue_reference<_Tp>, ::std::is_rvalue_reference<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_arithmetic : ::std::__or_< ::std::is_integral<_Tp>, ::std::is_floating_point<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_fundamental : ::std::__or_< ::std::is_arithmetic<_Tp>, ::std::is_void<_Tp>, ::std::is_null_pointer<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_object : ::std::__not_< ::std::__or_< ::std::is_function<_Tp>, ::std::is_reference<_Tp>, ::std::is_void<_Tp> > >::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct is_member_pointer;
  template < typename _Tp >
  struct  is_scalar : ::std::__or_< ::std::is_arithmetic<_Tp>, ::std::is_enum<_Tp>, ::std::is_pointer<_Tp>, ::std::is_member_pointer<_Tp>, ::std::is_null_pointer<_Tp> >::type
  {
  };
  template < typename _Tp >
  struct  is_compound : ::std::integral_constant<bool, !is_fundamental<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  __is_member_pointer_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Cp >
  struct  __is_member_pointer_helper<_Tp _Cp::*> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_member_pointer : ::std::__is_member_pointer_helper<typename ::std::remove_cv<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_referenceable : ::std::__or_< ::std::is_object<_Tp>, ::std::is_reference<_Tp> >::type
  {
  };
  template < typename _Res, typename ..._Args >
  struct  __is_referenceable<_Res (_Args ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Res, typename ..._Args >
  struct  __is_referenceable<_Res (_Args ..., ...)> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_const : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_const<const _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct  is_volatile : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_volatile<volatile _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_trivial : ::std::integral_constant<bool, __is_trivial(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_trivially_copyable : ::std::integral_constant<bool, __is_trivially_copyable(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_standard_layout : ::std::integral_constant<bool, __is_standard_layout(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_pod : ::std::integral_constant<bool, __is_pod(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_literal_type : ::std::integral_constant<bool, __is_literal_type(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_empty : ::std::integral_constant<bool, __is_empty(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_polymorphic : ::std::integral_constant<bool, __is_polymorphic(_Tp)>
  {
  };
  template < typename _Tp >
  struct  is_abstract : ::std::integral_constant<bool, __is_abstract(_Tp)>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_arithmetic<_Tp>::value >
  struct  __is_signed_helper : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_signed_helper<_Tp, true> : ::std::integral_constant<bool, _Tp( -1) < _Tp(0)>
  {
  };
  template < typename _Tp >
  struct  is_signed : ::std::__is_signed_helper<_Tp>::type
  {
  };
  template < typename _Tp >
  struct  is_unsigned : ::std::__and_< ::std::is_arithmetic<_Tp>, ::std::__not_< ::std::is_signed<_Tp> > >::type
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct add_rvalue_reference;
  template < typename _Tp >
  inline typename ::std::add_rvalue_reference<_Tp>::type declval() noexcept(true);
  template < typename __type_tpl__param_1_0__, unsigned int __nontype_tpl_param_1_1__ = 0 >
  struct extent;
  template < typename __type_tpl__param_1_0__ >
  struct remove_all_extents;
  template < typename _Tp >
  struct  __is_array_known_bounds : ::std::integral_constant<bool, (extent<_Tp>::value > 0)>
  {
  };
  template < typename _Tp >
  struct  __is_array_unknown_bounds : ::std::__and_< ::std::is_array<_Tp>, ::std::__not_< ::std::extent<_Tp> > >::type
  {
  };
  struct  __do_is_destructible_impl
  {
      template < typename _Tp, typename __type_tpl__param_1_1__ = decltype(declval<_Tp &>().~_Tp()) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_destructible_impl : ::std::__do_is_destructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_void<_Tp>, ::std::__is_array_unknown_bounds<_Tp>, ::std::is_function<_Tp> >::value, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_reference<_Tp>, ::std::is_scalar<_Tp> >::value >
  struct __is_destructible_safe;
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, false, false> : ::std::__is_destructible_impl<typename ::std::remove_all_extents<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, true, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_destructible_safe<_Tp, false, true> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_destructible : ::std::__is_destructible_safe<_Tp>::type
  {
  };
  struct  __do_is_nt_destructible_impl
  {
      template < typename _Tp >
      static ::std::integral_constant<bool, noexcept(declval<_Tp &>().~_Tp())> __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_nt_destructible_impl : ::std::__do_is_nt_destructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_void<_Tp>, ::std::__is_array_unknown_bounds<_Tp>, ::std::is_function<_Tp> >::value, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_reference<_Tp>, ::std::is_scalar<_Tp> >::value >
  struct __is_nt_destructible_safe;
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, false, false> : ::std::__is_nt_destructible_impl<typename ::std::remove_all_extents<_Tp>::type>::type
  {
  };
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, true, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_destructible_safe<_Tp, false, true> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_destructible : ::std::__is_nt_destructible_safe<_Tp>::type
  {
  };
  struct  __do_is_default_constructible_impl
  {
      template < typename _Tp, typename __type_tpl__param_1_1__ = decltype(_Tp()) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp >
  struct  __is_default_constructible_impl : ::std::__do_is_default_constructible_impl
  {
      typedef decltype(__test<_Tp>(0)) type;
  };
  template < typename _Tp >
  struct  __is_default_constructible_atom : ::std::__and_< ::std::__not_< ::std::is_void<_Tp> >, ::std::__is_default_constructible_impl<_Tp> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_array<_Tp>::value >
  struct __is_default_constructible_safe;
  template < typename _Tp >
  struct  __is_default_constructible_safe<_Tp, true> : ::std::__and_< ::std::__is_array_known_bounds<_Tp>, ::std::__is_default_constructible_atom<typename ::std::remove_all_extents<_Tp>::type> >::type
  {
  };
  template < typename _Tp >
  struct  __is_default_constructible_safe<_Tp, false> : ::std::__is_default_constructible_atom<_Tp>::type
  {
  };
  template < typename _Tp >
  struct  is_default_constructible : ::std::__is_default_constructible_safe<_Tp>::type
  {
  };
  struct  __do_is_static_castable_impl
  {
      template < typename _From, typename _To, typename __type_tpl__param_1_2__ = decltype(static_cast<_To>(declval<_From>())) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _From, typename _To >
  struct  __is_static_castable_impl : ::std::__do_is_static_castable_impl
  {
      typedef decltype(__test<_From, _To>(0)) type;
  };
  template < typename _From, typename _To >
  struct  __is_static_castable_safe : ::std::__is_static_castable_impl<_From, _To>::type
  {
  };
  template < typename _From, typename _To >
  struct  __is_static_castable : ::std::integral_constant<bool, __is_static_castable_safe<_From, _To>::value>
  {
  };
  struct  __do_is_direct_constructible_impl
  {
      template < typename _Tp, typename _Arg, typename __type_tpl__param_1_2__ = decltype(::new _Tp(declval<_Arg>())) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_impl : ::std::__do_is_direct_constructible_impl
  {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_new_safe : ::std::__and_< ::std::is_destructible<_Tp>, ::std::__is_direct_constructible_impl<_Tp, _Arg> >::type
  {
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct is_same;
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct is_base_of;
  template < typename __type_tpl__param_1_0__ >
  struct remove_reference;
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __not_< ::std::__or_< ::std::is_void<_From>, ::std::is_function<_From> > >::value >
  struct __is_base_to_derived_ref;
  template < typename _From, typename _To >
  struct  __is_base_to_derived_ref<_From, _To, true>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_From>::type>::type __src_t;
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_To>::type>::type __dst_t;
      typedef ::std::__and_< ::std::__not_< ::std::is_same<typename ::std::__is_base_to_derived_ref<_From, _To, true>::__src_t, typename ::std::__is_base_to_derived_ref<_From, _To, true>::__dst_t> >, ::std::is_base_of<typename ::std::__is_base_to_derived_ref<_From, _To, true>::__src_t, typename ::std::__is_base_to_derived_ref<_From, _To, true>::__dst_t> > type;
      static constexpr const bool value = type::value;
  };
  template < typename _From, typename _To >
  struct  __is_base_to_derived_ref<_From, _To, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __and_< ::std::is_lvalue_reference<_From>, ::std::is_rvalue_reference<_To> >::value >
  struct __is_lvalue_to_rvalue_ref;
  template < typename _From, typename _To >
  struct  __is_lvalue_to_rvalue_ref<_From, _To, true>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_From>::type>::type __src_t;
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_To>::type>::type __dst_t;
      typedef ::std::__and_< ::std::__not_< ::std::is_function<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t> >, ::std::__or_< ::std::is_same<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t, typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__dst_t>, ::std::is_base_of<typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__dst_t, typename ::std::__is_lvalue_to_rvalue_ref<_From, _To, true>::__src_t> > > type;
      static constexpr const bool value = type::value;
  };
  template < typename _From, typename _To >
  struct  __is_lvalue_to_rvalue_ref<_From, _To, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_ref_cast : ::std::__and_< ::std::__is_static_castable<_Arg, _Tp>, ::std::__not_< ::std::__or_< ::std::__is_base_to_derived_ref<_Arg, _Tp>, ::std::__is_lvalue_to_rvalue_ref<_Arg, _Tp> > > >::type
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible_new : ::std::conditional<is_reference<_Tp>::value, ::std::__is_direct_constructible_ref_cast<_Tp, _Arg>, ::std::__is_direct_constructible_new_safe<_Tp, _Arg> >::type
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_direct_constructible : ::std::__is_direct_constructible_new<_Tp, _Arg>::type
  {
  };
  struct  __do_is_nary_constructible_impl
  {
      template < typename _Tp, typename ..._Args, typename __type_tpl__param_1_2__ = decltype(_Tp(declval<_Args>() ...)) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ >
      static ::std::false_type __test(...);
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nary_constructible_impl : ::std::__do_is_nary_constructible_impl
  {
      typedef decltype(__test<_Tp, _Args ...>(0)) type;
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nary_constructible : ::std::__is_nary_constructible_impl<_Tp, _Args ...>::type
  {
      static_assert((sizeof...(_Args)) > 1, "Only useful for > 1 arguments");
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_constructible_impl : ::std::__is_nary_constructible<_Tp, _Args ...>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_constructible_impl<_Tp, _Arg> : ::std::__is_direct_constructible<_Tp, _Arg>
  {
  };
  template < typename _Tp >
  struct  __is_constructible_impl<_Tp> : ::std::is_default_constructible<_Tp>
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  is_constructible : ::std::__is_constructible_impl<_Tp, _Args ...>::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_copy_constructible_impl;
  template < typename _Tp >
  struct  __is_copy_constructible_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_copy_constructible_impl<_Tp, true> : ::std::is_constructible<_Tp, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_copy_constructible : ::std::__is_copy_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_move_constructible_impl;
  template < typename _Tp >
  struct  __is_move_constructible_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_move_constructible_impl<_Tp, true> : ::std::is_constructible<_Tp, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_move_constructible : ::std::__is_move_constructible_impl<_Tp>
  {
  };
  template < typename _Tp >
  struct  __is_nt_default_constructible_atom : ::std::integral_constant<bool, noexcept(_Tp())>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = is_array<_Tp>::value >
  struct __is_nt_default_constructible_impl;
  template < typename _Tp >
  struct  __is_nt_default_constructible_impl<_Tp, true> : ::std::__and_< ::std::__is_array_known_bounds<_Tp>, ::std::__is_nt_default_constructible_atom<typename ::std::remove_all_extents<_Tp>::type> >::type
  {
  };
  template < typename _Tp >
  struct  __is_nt_default_constructible_impl<_Tp, false> : ::std::__is_nt_default_constructible_atom<_Tp>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_default_constructible : ::std::__and_< ::std::is_default_constructible<_Tp>, ::std::__is_nt_default_constructible_impl<_Tp> >::type
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  __is_nt_constructible_impl : ::std::integral_constant<bool, noexcept(_Tp(declval<_Args>() ...))>
  {
  };
  template < typename _Tp, typename _Arg >
  struct  __is_nt_constructible_impl<_Tp, _Arg> : ::std::integral_constant<bool, noexcept(static_cast<_Tp>(declval<_Arg>()))>
  {
  };
  template < typename _Tp >
  struct  __is_nt_constructible_impl<_Tp> : ::std::is_nothrow_default_constructible<_Tp>
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  is_nothrow_constructible : ::std::__and_< ::std::is_constructible<_Tp, _Args ...>, ::std::__is_nt_constructible_impl<_Tp, _Args ...> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_nothrow_copy_constructible_impl;
  template < typename _Tp >
  struct  __is_nothrow_copy_constructible_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nothrow_copy_constructible_impl<_Tp, true> : ::std::is_nothrow_constructible<_Tp, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_copy_constructible : ::std::__is_nothrow_copy_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_nothrow_move_constructible_impl;
  template < typename _Tp >
  struct  __is_nothrow_move_constructible_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nothrow_move_constructible_impl<_Tp, true> : ::std::is_nothrow_constructible<_Tp, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_move_constructible : ::std::__is_nothrow_move_constructible_impl<_Tp>
  {
  };
  template < typename _Tp, typename _Up >
  class  __is_assignable_helper
  {
      template < typename _Tp1, typename _Up1, typename __type_tpl__param_2_2__ = decltype(declval<_Tp1>() = declval<_Up1>()) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static ::std::false_type __test(...);
    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
  };
  template < typename _Tp, typename _Up >
  struct  is_assignable : ::std::__is_assignable_helper<_Tp, _Up>::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_copy_assignable_impl;
  template < typename _Tp >
  struct  __is_copy_assignable_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_copy_assignable_impl<_Tp, true> : ::std::is_assignable<_Tp &, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_copy_assignable : ::std::__is_copy_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_move_assignable_impl;
  template < typename _Tp >
  struct  __is_move_assignable_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_move_assignable_impl<_Tp, true> : ::std::is_assignable<_Tp &, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_move_assignable : ::std::__is_move_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, typename _Up >
  struct  __is_nt_assignable_impl : ::std::integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
  {
  };
  template < typename _Tp, typename _Up >
  struct  is_nothrow_assignable : ::std::__and_< ::std::is_assignable<_Tp, _Up>, ::std::__is_nt_assignable_impl<_Tp, _Up> >::type
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_nt_copy_assignable_impl;
  template < typename _Tp >
  struct  __is_nt_copy_assignable_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_copy_assignable_impl<_Tp, true> : ::std::is_nothrow_assignable<_Tp &, const _Tp &>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_copy_assignable : ::std::__is_nt_copy_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct __is_nt_move_assignable_impl;
  template < typename _Tp >
  struct  __is_nt_move_assignable_impl<_Tp, false> : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __is_nt_move_assignable_impl<_Tp, true> : ::std::is_nothrow_assignable<_Tp &, _Tp &&>
  {
  };
  template < typename _Tp >
  struct  is_nothrow_move_assignable : ::std::__is_nt_move_assignable_impl<_Tp>
  {
  };
  template < typename _Tp, typename ..._Args >
  struct  is_trivially_constructible : ::std::__and_< ::std::is_constructible<_Tp, _Args ...>, ::std::integral_constant<bool, __is_trivially_constructible(_Tp, _Args ...)> >::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_default_constructible : ::std::is_trivially_constructible<_Tp>::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_copy_constructible : ::std::__and_< ::std::is_copy_constructible<_Tp>, ::std::integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp &)> >::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_move_constructible : ::std::__and_< ::std::is_move_constructible<_Tp>, ::std::integral_constant<bool, __is_trivially_constructible(_Tp, _Tp &&)> >::type
  {
  };
  template < typename _Tp, typename _Up >
  struct  is_trivially_assignable : ::std::__and_< ::std::is_assignable<_Tp, _Up>, ::std::integral_constant<bool, __is_trivially_assignable(_Tp, _Up)> >::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_copy_assignable : ::std::__and_< ::std::is_copy_assignable<_Tp>, ::std::integral_constant<bool, __is_trivially_assignable(_Tp &, const _Tp &)> >::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_move_assignable : ::std::__and_< ::std::is_move_assignable<_Tp>, ::std::integral_constant<bool, __is_trivially_assignable(_Tp &, _Tp &&)> >::type
  {
  };
  template < typename _Tp >
  struct  is_trivially_destructible : ::std::__and_< ::std::is_destructible<_Tp>, ::std::integral_constant<bool, __has_trivial_destructor(_Tp)> >::type
  {
  };
  template < typename _Tp >
  struct __attribute__((__deprecated__))  has_trivial_default_constructor : ::std::integral_constant<bool, __has_trivial_constructor(_Tp)>
  {
  };
  template < typename _Tp >
  struct __attribute__((__deprecated__))  has_trivial_copy_constructor : ::std::integral_constant<bool, __has_trivial_copy(_Tp)>
  {
  };
  template < typename _Tp >
  struct __attribute__((__deprecated__))  has_trivial_copy_assign : ::std::integral_constant<bool, __has_trivial_assign(_Tp)>
  {
  };
  template < typename _Tp >
  struct  has_virtual_destructor : ::std::integral_constant<bool, __has_virtual_destructor(_Tp)>
  {
  };
  template < typename _Tp >
  struct  alignment_of : ::std::integral_constant<unsigned long int, alignof(_Tp)>
  {
  };
 /* Instantiation of class template '::std::integral_constant<unsigned long int, 0>' */ 
  template < typename __type_tpl__param_1_0__ >
  struct  rank : ::std::integral_constant<unsigned long int, 0>
  {
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  rank<_Tp [_Size]> : ::std::integral_constant<unsigned long int, 1 + rank<_Tp>::value>
  {
  };
  template < typename _Tp >
  struct  rank<_Tp []> : ::std::integral_constant<unsigned long int, 1 + rank<_Tp>::value>
  {
  };
  template < typename __type_tpl__param_1_0__, unsigned int _Uint >
  struct  extent : ::std::integral_constant<unsigned long int, 0>
  {
  };
  template < typename _Tp, unsigned int _Uint, ::std::size_t _Size >
  struct  extent<_Tp [_Size], _Uint> : ::std::integral_constant<unsigned long int, _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value>
  {
  };
  template < typename _Tp, unsigned int _Uint >
  struct  extent<_Tp [], _Uint> : ::std::integral_constant<unsigned long int, _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value>
  {
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  is_same : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_same<_Tp, _Tp> : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Base, typename _Derived >
  struct  is_base_of : ::std::integral_constant<bool, __is_base_of(_Base, _Derived)>
  {
  };
  template < typename _From, typename _To, bool __nontype_tpl_param_1_2__ = __or_< ::std::is_void<_From>, ::std::is_function<_To>, ::std::is_array<_To> >::value >
  struct  __is_convertible_helper
  {
      typedef typename ::std::is_void<_To>::type type;
  };
  template < typename _From, typename _To >
  class  __is_convertible_helper<_From, _To, false>
  {
      template < typename _To1 >
      static void __test_aux(_To1);
      template < typename _From1, typename _To1, typename __type_tpl__param_2_2__ = decltype(__test_aux<_To1>(std::declval<_From1>())) >
      static ::std::true_type __test(int);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static ::std::false_type __test(...);
    public:
      typedef decltype(__test<_From, _To>(0)) type;
  };
  template < typename _From, typename _To >
  struct  is_convertible : ::std::__is_convertible_helper<_From, _To>::type
  {
  };
  template < typename _Tp >
  struct  remove_const
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_const<const _Tp>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_volatile
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_volatile<volatile _Tp>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_cv
  {
      typedef typename ::std::remove_const<typename ::std::remove_volatile<_Tp>::type>::type type;
  };
  template < typename _Tp >
  struct  add_const
  {
      typedef const _Tp type;
  };
  template < typename _Tp >
  struct  add_volatile
  {
      typedef volatile _Tp type;
  };
  template < typename _Tp >
  struct  add_cv
  {
      typedef typename ::std::add_const<typename ::std::add_volatile<_Tp>::type>::type type;
  };
  template < typename _Tp >
  struct  remove_reference
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_reference<_Tp &>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_reference<_Tp &&>
  {
      typedef _Tp type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct  __add_lvalue_reference_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_lvalue_reference_helper<_Tp, true>
  {
      typedef _Tp &type;
  };
  template < typename _Tp >
  struct  add_lvalue_reference : ::std::__add_lvalue_reference_helper<_Tp>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __is_referenceable<_Tp>::value >
  struct  __add_rvalue_reference_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_rvalue_reference_helper<_Tp, true>
  {
      typedef _Tp &&type;
  };
  template < typename _Tp >
  struct  add_rvalue_reference : ::std::__add_rvalue_reference_helper<_Tp>
  {
  };
  template < typename _Unqualified, bool _IsConst, bool _IsVol >
  struct __cv_selector;
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, false, false>
  {
      typedef _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, false, true>
  {
      typedef volatile _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, true, false>
  {
      typedef const _Unqualified __type;
  };
  template < typename _Unqualified >
  struct  __cv_selector<_Unqualified, true, true>
  {
      typedef const volatile _Unqualified __type;
  };
  template < typename _Qualified, typename _Unqualified, bool _IsConst = is_const<_Qualified>::value, bool _IsVol = is_volatile<_Qualified>::value >
  class  __match_cv_qualifiers
  {
      typedef ::std::__cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
      typedef typename ::std::__cv_selector<_Unqualified, _IsConst, _IsVol>::__type __type;
  };
  template < typename _Tp >
  struct  __make_unsigned
  {
      typedef _Tp __type;
  };
  template <>
  struct  __make_unsigned<char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __make_unsigned<signed char>
  {
      typedef unsigned char __type;
  };
  template <>
  struct  __make_unsigned<short int>
  {
      typedef unsigned short int __type;
  };
  template <>
  struct  __make_unsigned<int>
  {
      typedef unsigned int __type;
  };
  template <>
  struct  __make_unsigned<long int>
  {
      typedef unsigned long int __type;
  };
  template <>
  struct  __make_unsigned<long long int>
  {
      typedef unsigned long long int __type;
  };
  template < typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value >
  class __make_unsigned_selector;
  template < typename _Tp >
  class  __make_unsigned_selector<_Tp, true, false>
  {
      typedef ::std::__make_unsigned<typename ::std::remove_cv<_Tp>::type> __unsignedt;
      typedef typename ::std::__make_unsigned<typename ::std::remove_cv<_Tp>::type>::__type __unsigned_type;
      typedef ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_unsigned_selector<_Tp, true, false>::__unsigned_type> __cv_unsigned;
    public:
      typedef typename ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_unsigned_selector<_Tp, true, false>::__unsigned_type>::__type __type;
  };
  template < typename _Tp >
  class  __make_unsigned_selector<_Tp, false, true>
  {
      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(typename ::std::__make_unsigned_selector<_Tp, false, true>::__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short int);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b2, unsigned int, unsigned long int> __cond2;
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b2, unsigned int, unsigned long int>::type __cond2_type;
      typedef ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b1, unsigned short int, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond2_type> __cond1;
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b1, unsigned short int, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond2_type>::type __cond1_type;
    public:
      typedef typename ::std::conditional< ::std::__make_unsigned_selector<_Tp, false, true>::__b0, unsigned char, typename ::std::__make_unsigned_selector<_Tp, false, true>::__cond1_type>::type __type;
  };
  template < typename _Tp >
  struct  make_unsigned
  {
      typedef typename ::std::__make_unsigned_selector<_Tp>::__type type;
  };
  template <>
  struct make_unsigned<bool>;
  template < typename _Tp >
  struct  __make_signed
  {
      typedef _Tp __type;
  };
  template <>
  struct  __make_signed<char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __make_signed<unsigned char>
  {
      typedef signed char __type;
  };
  template <>
  struct  __make_signed<unsigned short int>
  {
      typedef short int __type;
  };
  template <>
  struct  __make_signed<unsigned int>
  {
      typedef int __type;
  };
  template <>
  struct  __make_signed<unsigned long int>
  {
      typedef long int __type;
  };
  template <>
  struct  __make_signed<unsigned long long int>
  {
      typedef long long int __type;
  };
  template <>
  struct  __make_signed<wchar_t> : ::std::__make_signed<unsigned int>
  {
  };
  template <>
  struct  __make_signed<char16_t> : ::std::__make_signed<unsigned short int>
  {
  };
  template <>
  struct  __make_signed<char32_t> : ::std::__make_signed<unsigned int>
  {
  };
  template < typename _Tp, bool _IsInt = is_integral<_Tp>::value, bool _IsEnum = is_enum<_Tp>::value >
  class __make_signed_selector;
  template < typename _Tp >
  class  __make_signed_selector<_Tp, true, false>
  {
      typedef ::std::__make_signed<typename ::std::remove_cv<_Tp>::type> __signedt;
      typedef typename ::std::__make_signed<typename ::std::remove_cv<_Tp>::type>::__type __signed_type;
      typedef ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_signed_selector<_Tp, true, false>::__signed_type> __cv_signed;
    public:
      typedef typename ::std::__match_cv_qualifiers<_Tp, typename ::std::__make_signed_selector<_Tp, true, false>::__signed_type>::__type __type;
  };
  template < typename _Tp >
  class  __make_signed_selector<_Tp, false, true>
  {
      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(typename ::std::__make_signed_selector<_Tp, false, true>::__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(short int);
      static const bool __b2 = sizeof(_Tp) <= sizeof(int);
      typedef ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b2, int, long int> __cond2;
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b2, int, long int>::type __cond2_type;
      typedef ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b1, short int, typename ::std::__make_signed_selector<_Tp, false, true>::__cond2_type> __cond1;
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b1, short int, typename ::std::__make_signed_selector<_Tp, false, true>::__cond2_type>::type __cond1_type;
    public:
      typedef typename ::std::conditional< ::std::__make_signed_selector<_Tp, false, true>::__b0, signed char, typename ::std::__make_signed_selector<_Tp, false, true>::__cond1_type>::type __type;
  };
  template < typename _Tp >
  struct  make_signed
  {
      typedef typename ::std::__make_signed_selector<_Tp>::__type type;
  };
  template <>
  struct make_signed<bool>;
  template < typename _Tp >
  struct  remove_extent
  {
      typedef _Tp type;
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  remove_extent<_Tp [_Size]>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_extent<_Tp []>
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  remove_all_extents
  {
      typedef _Tp type;
  };
  template < typename _Tp, ::std::size_t _Size >
  struct  remove_all_extents<_Tp [_Size]>
  {
      typedef typename ::std::remove_all_extents<_Tp>::type type;
  };
  template < typename _Tp >
  struct  remove_all_extents<_Tp []>
  {
      typedef typename ::std::remove_all_extents<_Tp>::type type;
  };
  template < typename _Tp, typename __type_tpl__param_1_1__ >
  struct  __remove_pointer_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp, typename _Up >
  struct  __remove_pointer_helper<_Tp, _Up *>
  {
      typedef _Up type;
  };
  template < typename _Tp >
  struct  remove_pointer : ::std::__remove_pointer_helper<_Tp, typename ::std::remove_cv<_Tp>::type>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::__is_referenceable<_Tp>, ::std::is_void<_Tp> >::value >
  struct  __add_pointer_helper
  {
      typedef _Tp type;
  };
  template < typename _Tp >
  struct  __add_pointer_helper<_Tp, true>
  {
      typedef typename ::std::remove_reference<_Tp>::type *type;
  };
  template < typename _Tp >
  struct  add_pointer : ::std::__add_pointer_helper<_Tp>
  {
  };
  template < ::std::size_t _Len >
  struct  __aligned_storage_msa
  {
      union  __type
      {
          unsigned char __data[_Len];
          struct __attribute__((__aligned__))  mcc_struct_anon_68
          {
          };
          typename ::std::__aligned_storage_msa<_Len>::__type::mcc_struct_anon_68 __align;
      };
  };
  template < ::std::size_t _Len, ::std::size_t _Align = alignof(typename ::std::__aligned_storage_msa<_Len>::__type) >
  struct  aligned_storage
  {
      union  type
      {
          unsigned char __data[_Len];
          struct __attribute__((aligned(/* ??? */_Align)))  mcc_struct_anon_69
          {
          };
          typename ::std::aligned_storage<_Len, _Align>::type::mcc_struct_anon_69 __align;
      };
  };
  template < typename ..._Types >
  struct  __strictest_alignment
  {
      static const ::std::size_t _S_alignment = 0;
      static const ::std::size_t _S_size = 0;
  };
  template < typename _Tp, typename ..._Types >
  struct  __strictest_alignment<_Tp, _Types ...>
  {
      static const ::std::size_t _S_alignment = (alignof(_Tp)) > __strictest_alignment<_Types ...>::_S_alignment ? alignof(_Tp) : __strictest_alignment<_Types ...>::_S_alignment;
      static const ::std::size_t _S_size = sizeof(_Tp) > __strictest_alignment<_Types ...>::_S_size ? sizeof(_Tp) : __strictest_alignment<_Types ...>::_S_size;
  };
  template < ::std::size_t _Len, typename ..._Types >
  struct  aligned_union
  {
    private:
      static_assert((sizeof...(_Types)) != 0, "At least one type is required");
      typedef ::std::__strictest_alignment<_Types ...> __strictest;
      static const ::std::size_t _S_len = _Len > __strictest::_S_size ? _Len : __strictest::_S_size;
    public:
      static const ::std::size_t alignment_value = __strictest::_S_alignment;
      typedef typename ::std::aligned_storage< ::std::aligned_union<_Len, _Types ...>::_S_len, ::std::aligned_union<_Len, _Types ...>::alignment_value>::type type;
  };
  template < typename _Up, bool _IsArray = is_array<_Up>::value, bool _IsFunction = is_function<_Up>::value >
  struct __decay_selector;
  template < typename _Up >
  struct  __decay_selector<_Up, false, false>
  {
      typedef typename ::std::remove_cv<_Up>::type __type;
  };
  template < typename _Up >
  struct  __decay_selector<_Up, true, false>
  {
      typedef typename ::std::remove_extent<_Up>::type *__type;
  };
  template < typename _Up >
  struct  __decay_selector<_Up, false, true>
  {
      typedef typename ::std::add_pointer<_Up>::type __type;
  };
  template < typename _Tp >
  class  decay
  {
      typedef typename ::std::remove_reference<_Tp>::type __remove_type;
    public:
      typedef typename ::std::__decay_selector<typename ::std::decay<_Tp>::__remove_type>::__type type;
  };
  template < typename _Tp >
  class reference_wrapper;
  template < typename _Tp >
  struct  __strip_reference_wrapper
  {
      typedef _Tp __type;
  };
  template < typename _Tp >
  struct  __strip_reference_wrapper< ::std::reference_wrapper<_Tp> >
  {
      typedef _Tp &__type;
  };
  template < typename _Tp >
  struct  __decay_and_strip
  {
      typedef typename ::std::__strip_reference_wrapper<typename ::std::decay<_Tp>::type>::__type __type;
  };
  template < bool __nontype_tpl_param_1_0__, typename _Tp = void >
  struct  enable_if
  {
  };
  template < typename _Tp >
  struct  enable_if<true, _Tp>
  {
      typedef _Tp type;
  };
  template < typename ..._Cond >
  using _Require = typename ::std::enable_if<__and_<_Cond ...>::value>::type;
  template < bool _Cond, typename _Iftrue, typename _Iffalse >
  struct  conditional
  {
      typedef _Iftrue type;
  };
  template < typename _Iftrue, typename _Iffalse >
  struct  conditional<false, _Iftrue, _Iffalse>
  {
      typedef _Iffalse type;
  };
  template < typename ..._Tp >
  struct common_type;
  struct  __do_common_type_impl
  {
      template < typename _Tp, typename _Up >
      static ::std::__success_type<typename ::std::decay<decltype(true ? std::declval<_Tp>() : std::declval<_Up>())>::type> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Tp, typename _Up >
  struct  __common_type_impl : private ::std::__do_common_type_impl
  {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
  };
  struct  __do_member_type_wrapper
  {
      template < typename _Tp >
      static ::std::__success_type<typename _Tp::type> _S_test(int);
      template < typename __type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Tp >
  struct  __member_type_wrapper : private ::std::__do_member_type_wrapper
  {
      typedef decltype(_S_test<_Tp>(0)) type;
  };
  template < typename _CTp, typename ..._Args >
  struct  __expanded_common_type_wrapper
  {
      typedef ::std::common_type<typename _CTp::type, _Args ...> type;
  };
  template < typename ..._Args >
  struct  __expanded_common_type_wrapper< ::std::__failure_type, _Args ...>
  {
      typedef ::std::__failure_type type;
  };
  template < typename _Tp >
  struct  common_type<_Tp>
  {
      typedef typename ::std::decay<_Tp>::type type;
  };
  template < typename _Tp, typename _Up >
  struct  common_type<_Tp, _Up> : ::std::__common_type_impl<_Tp, _Up>::type
  {
  };
  template < typename _Tp, typename _Up, typename ..._Vp >
  struct  common_type<_Tp, _Up, _Vp ...> : ::std::__expanded_common_type_wrapper<typename ::std::__member_type_wrapper< ::std::common_type<_Tp, _Up> >::type, _Vp ...>::type
  {
  };
  template < typename _Tp >
  struct  underlying_type
  {
      typedef __underlying_type(_Tp) type;
  };
  template < typename _Tp >
  struct  __declval_protector
  {
      static const bool __stop = false;
      static typename ::std::add_rvalue_reference<_Tp>::type __delegate();
  };
  template < typename _Tp >
  inline typename ::std::add_rvalue_reference<_Tp>::type declval() noexcept(true)
  {
    static_assert(__declval_protector<_Tp>::__stop, "declval() must not be used!");
    return __declval_protector<_Tp>::__delegate();
  }
  template < typename _Signature >
  class result_of;
  struct  __result_of_memfun_ref_impl
  {
      template < typename _Fp, typename _Tp1, typename ..._Args >
      static ::std::__success_type<decltype((std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_memfun_ref : private ::std::__result_of_memfun_ref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args ...>(0)) type;
  };
  struct  __result_of_memfun_deref_impl
  {
      template < typename _Fp, typename _Tp1, typename ..._Args >
      static ::std::__success_type<decltype((*std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_memfun_deref : private ::std::__result_of_memfun_deref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args ...>(0)) type;
  };
  struct  __result_of_memobj_ref_impl
  {
      template < typename _Fp, typename _Tp1 >
      static ::std::__success_type<decltype(std::declval<_Tp1>().*std::declval<_Fp>())> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_memobj_ref : private ::std::__result_of_memobj_ref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };
  struct  __result_of_memobj_deref_impl
  {
      template < typename _Fp, typename _Tp1 >
      static ::std::__success_type<decltype(*std::declval<_Tp1>().*std::declval<_Fp>())> _S_test(int);
      template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_memobj_deref : private ::std::__result_of_memobj_deref_impl
  {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
  };
  template < typename _MemPtr, typename _Arg >
  struct __result_of_memobj;
  template < typename _Res, typename _Class, typename _Arg >
  struct  __result_of_memobj<_Res _Class::*, _Arg>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_Arg>::type>::type _Argval;
      typedef _Res _Class::*_MemPtr;
      typedef typename ::std::conditional<__or_< ::std::is_same<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_Argval, _Class>, ::std::is_base_of<_Class, typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_Argval> >::value, ::std::__result_of_memobj_ref<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_MemPtr, _Arg>, ::std::__result_of_memobj_deref<typename ::std::__result_of_memobj<_Res _Class::*, _Arg>::_MemPtr, _Arg> >::type::type type;
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct __result_of_memfun;
  template < typename _Res, typename _Class, typename _Arg, typename ..._Args >
  struct  __result_of_memfun<_Res _Class::*, _Arg, _Args ...>
  {
      typedef typename ::std::remove_cv<typename ::std::remove_reference<_Arg>::type>::type _Argval;
      typedef _Res _Class::*_MemPtr;
      typedef typename ::std::conditional<__or_< ::std::is_same<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_Argval, _Class>, ::std::is_base_of<_Class, typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_Argval> >::value, ::std::__result_of_memfun_ref<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_MemPtr, _Arg, _Args ...>, ::std::__result_of_memfun_deref<typename ::std::__result_of_memfun<_Res _Class::*, _Arg, _Args ...>::_MemPtr, _Arg, _Args ...> >::type::type type;
  };
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename _Functor, typename ..._ArgTypes >
  struct  __result_of_impl
  {
      typedef ::std::__failure_type type;
  };
  template < typename _MemPtr, typename _Arg >
  struct  __result_of_impl<true, false, _MemPtr, _Arg> : ::std::__result_of_memobj<typename ::std::decay<_MemPtr>::type, _Arg>
  {
  };
  template < typename _MemPtr, typename _Arg, typename ..._Args >
  struct  __result_of_impl<false, true, _MemPtr, _Arg, _Args ...> : ::std::__result_of_memfun<typename ::std::decay<_MemPtr>::type, _Arg, _Args ...>
  {
  };
  struct  __result_of_other_impl
  {
      template < typename _Fn, typename ..._Args >
      static ::std::__success_type<decltype(std::declval<_Fn>()(std::declval<_Args>() ...))> _S_test(int);
      template < typename ...__type_tpl__param_1_0__ >
      static ::std::__failure_type _S_test(...);
  };
  template < typename _Functor, typename ..._ArgTypes >
  struct  __result_of_impl<false, false, _Functor, _ArgTypes ...> : private ::std::__result_of_other_impl
  {
      typedef decltype(_S_test<_Functor, _ArgTypes ...>(0)) type;
  };
  template < typename _Functor, typename ..._ArgTypes >
  struct  result_of<_Functor (_ArgTypes ...)> : ::std::__result_of_impl<is_member_object_pointer<typename ::std::remove_reference<_Functor>::type>::value, is_member_function_pointer<typename ::std::remove_reference<_Functor>::type>::value, _Functor, _ArgTypes ...>::type
  {
  };
  template < typename ...__type_tpl__param_1_0__ >
  using __void_t = void;
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &__t) noexcept(true);
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &__t) noexcept(true)
  {
    return static_cast<_Tp &&>(__t);
  }
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &&__t) noexcept(true);
  template < typename _Tp >
  inline constexpr _Tp &&forward(typename ::std::remove_reference<_Tp>::type &&__t) noexcept(true)
  {
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument substituting _Tp is an lvalue reference type");
    return static_cast<_Tp &&>(__t);
  }
  template < typename _Tp >
  inline constexpr typename ::std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept(true);
  template < typename _Tp >
  inline constexpr typename ::std::remove_reference<_Tp>::type &&move(_Tp &&__t) noexcept(true)
  {
    return static_cast<typename ::std::remove_reference<_Tp>::type &&>(__t);
  }
  template < typename _Tp >
  struct  __move_if_noexcept_cond : ::std::__and_< ::std::__not_< ::std::is_nothrow_move_constructible<_Tp> >, ::std::is_copy_constructible<_Tp> >::type
  {
  };
  template < typename _Tp >
  inline constexpr typename ::std::conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept(true);
  template < typename _Tp >
  inline constexpr typename ::std::conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp &, _Tp &&>::type move_if_noexcept(_Tp &__x) noexcept(true)
  {
    return std::move(__x);
  }
  template < typename _Tp >
  inline _Tp *addressof(_Tp &__r) noexcept(true);
  template < typename _Tp >
  inline _Tp *addressof(_Tp &__r) noexcept(true)
  {
    return std::__addressof(__r);
  }
  template < typename _Tp, typename _Up = _Tp >
  inline _Tp __exchange(_Tp &__obj, _Up &&__new_val);
  template < typename _Tp, typename _Up >
  inline _Tp __exchange(_Tp &__obj, _Up &&__new_val)
  {
    _Tp __old_val = std::move(__obj);
    __obj = std::forward<_Up>(__new_val);
    return __old_val;
  }
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b) noexcept(__and_< ::std::is_nothrow_move_constructible<_Tp>, ::std::is_nothrow_move_assignable<_Tp> >::value);
  template < typename _Tp >
  inline void swap(_Tp &__a, _Tp &__b) noexcept(__and_< ::std::is_nothrow_move_constructible<_Tp>, ::std::is_nothrow_move_assignable<_Tp> >::value)
  {
    _Tp __tmp = std::move(__a);
    __a = std::move(__b);
    __b = std::move(__tmp);
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*__a, *__b)));
  template < typename _Tp, ::std::size_t _Nm >
  inline void swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*__a, *__b)))
  {
    for (::std::size_t __n(0); __n < _Nm;  ++__n)
      {
        swap(__a[__n], __b[__n]);
      }
  }
  struct  piecewise_construct_t
  {
  };
  constexpr const ::std::piecewise_construct_t piecewise_construct((::std::piecewise_construct_t()));
  template < typename ...__type_tpl__param_1_0__ >
  class tuple;
  template < ::std::size_t ... __nontype_tpl_param_1_0__ >
  struct _Index_tuple;
  template < typename _T1, typename _T2 >
  struct  pair
  {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      inline constexpr pair()
        : first(), second()
      {
      }
      inline constexpr pair(const _T1 &__a, const _T2 &__b)
        : first(__a), second(__b)
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<const _U1 &, _T1>, ::std::is_convertible<const _U2 &, _T2> >::value>::type >
      inline constexpr pair(const ::std::pair<_U1, _U2> &__p)
        : first(__p.first), second(__p.second)
      {
      }
      inline constexpr pair(const ::std::pair<_T1, _T2> &) = default ;
      inline constexpr pair(::std::pair<_T1, _T2> &&) = default ;
      template < typename _U1, typename __type_tpl__param_2_1__ = typename ::std::enable_if<is_convertible<_U1, _T1>::value>::type >
      inline constexpr pair(_U1 &&__x, const _T2 &__y)
        : first(std::forward<_U1>(__x)), second(__y)
      {
      }
      template < typename _U2, typename __type_tpl__param_2_1__ = typename ::std::enable_if<is_convertible<_U2, _T2>::value>::type >
      inline constexpr pair(const _T1 &__x, _U2 &&__y)
        : first(__x), second(std::forward<_U2>(__y))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr pair(_U1 &&__x, _U2 &&__y)
        : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
      {
      }
      template < typename _U1, typename _U2, typename __type_tpl__param_2_2__ = typename ::std::enable_if<__and_< ::std::is_convertible<_U1, _T1>, ::std::is_convertible<_U2, _T2> >::value>::type >
      inline constexpr pair(::std::pair<_U1, _U2> &&__p)
        : first(std::forward<_U1>(__p.first)), second(std::forward<_U2>(__p.second))
      {
      }
      template < typename ..._Args1, typename ..._Args2 >
      pair(::std::piecewise_construct_t, ::std::tuple<_Args1 ...>, ::std::tuple<_Args2 ...>);
      inline ::std::pair<_T1, _T2> &operator =(const ::std::pair<_T1, _T2> &__p)
      {
        ::std::pair<_T1, _T2>::first = __p.first;
        ::std::pair<_T1, _T2>::second = __p.second;
        return *this;
      }
      inline ::std::pair<_T1, _T2> &operator =(::std::pair<_T1, _T2> &&__p) noexcept(__and_< ::std::is_nothrow_move_assignable<_T1>, ::std::is_nothrow_move_assignable<_T2> >::value)
      {
        ::std::pair<_T1, _T2>::first = std::forward<typename ::std::pair<_T1, _T2>::first_type>(__p.first);
        ::std::pair<_T1, _T2>::second = std::forward<typename ::std::pair<_T1, _T2>::second_type>(__p.second);
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::pair<_T1, _T2> &operator =(const ::std::pair<_U1, _U2> &__p)
      {
        ::std::pair<_T1, _T2>::first = __p.first;
        ::std::pair<_T1, _T2>::second = __p.second;
        return *this;
      }
      template < typename _U1, typename _U2 >
      inline ::std::pair<_T1, _T2> &operator =(::std::pair<_U1, _U2> &&__p)
      {
        ::std::pair<_T1, _T2>::first = std::forward<_U1>(__p.first);
        ::std::pair<_T1, _T2>::second = std::forward<_U2>(__p.second);
        return *this;
      }
      inline void swap(::std::pair<_T1, _T2> &__p) noexcept((noexcept(swap(::std::pair<_T1, _T2>::first, __p.first))) && (noexcept(swap(::std::pair<_T1, _T2>::second, __p.second))))
      {
        using ::std::swap;
        swap(::std::pair<_T1, _T2>::first, __p.first);
        swap(::std::pair<_T1, _T2>::second, __p.second);
      }
    private:
      template < typename ..._Args1, ::std::size_t ... _Indexes1, typename ..._Args2, ::std::size_t ... _Indexes2 >
      pair(::std::tuple<_Args1 ...> &, ::std::tuple<_Args2 ...> &, ::std::_Index_tuple<_Indexes1 ...>, ::std::_Index_tuple<_Indexes2 ...>);
  };
  template < typename _T1, typename _T2 >
  inline constexpr bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator ==(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first == __y.first && __x.second == __y.second;
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator !=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x == __y);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return __y < __x;
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator <=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__y < __x);
  }
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y);
  template < typename _T1, typename _T2 >
  inline constexpr bool operator >=(const ::std::pair<_T1, _T2> &__x, const ::std::pair<_T1, _T2> &__y)
  {
    return !(__x < __y);
  }
  template < typename _T1, typename _T2 >
  inline void swap(::std::pair<_T1, _T2> &__x, ::std::pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)));
  template < typename _T1, typename _T2 >
  inline void swap(::std::pair<_T1, _T2> &__x, ::std::pair<_T1, _T2> &__y) noexcept(noexcept(__x.swap(__y)))
  {
    __x.swap(__y);
  }
  template < typename _T1, typename _T2 >
  inline constexpr ::std::pair<typename ::std::__decay_and_strip<_T1>::__type, typename ::std::__decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y);
  template < typename _T1, typename _T2 >
  inline constexpr ::std::pair<typename ::std::__decay_and_strip<_T1>::__type, typename ::std::__decay_and_strip<_T2>::__type> make_pair(_T1 &&__x, _T2 &&__y)
  {
    typedef typename ::std::__decay_and_strip<_T1>::__type __ds_type1;
    typedef typename ::std::__decay_and_strip<_T2>::__type __ds_type2;
    typedef ::std::pair<__ds_type1, __ds_type2> __pair_type;
    return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
  }
  struct  input_iterator_tag
  {
  };
  struct  output_iterator_tag
  {
  };
  struct  forward_iterator_tag : ::std::input_iterator_tag
  {
  };
  struct  bidirectional_iterator_tag : ::std::forward_iterator_tag
  {
  };
  struct  random_access_iterator_tag : ::std::bidirectional_iterator_tag
  {
  };
  template < typename _Category, typename _Tp, typename _Distance = ::std::ptrdiff_t, typename _Pointer = _Tp *, typename _Reference = _Tp & >
  struct  iterator
  {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
  };
  template < typename _Iterator, typename __type_tpl__param_1_1__ = ::std::__void_t<> >
  struct  __iterator_traits
  {
  };
  template < typename _Iterator >
  struct  __iterator_traits<_Iterator, ::std::__void_t<typename _Iterator::iterator_category, typename _Iterator::value_type, typename _Iterator::difference_type, typename _Iterator::pointer, typename _Iterator::reference> >
  {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
  };
  template < typename _Iterator >
  struct  iterator_traits : ::std::__iterator_traits<_Iterator>
  {
  };
  template < typename _Tp >
  struct  iterator_traits<_Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef _Tp &reference;
  };
  template < typename _Tp >
  struct  iterator_traits<const _Tp *>
  {
      typedef ::std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef const _Tp *pointer;
      typedef const _Tp &reference;
  };
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &);
  template < typename _Iter >
  inline typename ::std::iterator_traits<_Iter>::iterator_category __iterator_category(const _Iter &)
  {
    return typename ::std::iterator_traits<_Iter>::iterator_category();
  }
  template < typename _Iterator, bool _HasBase >
  struct  _Iter_base
  {
      typedef _Iterator iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, _HasBase>::iterator_type _S_base(_Iterator __it)
      {
        return __it;
      }
  };
  template < typename _Iterator >
  struct  _Iter_base<_Iterator, true>
  {
      typedef typename _Iterator::iterator_type iterator_type;
      static inline typename ::std::_Iter_base<_Iterator, true>::iterator_type _S_base(_Iterator __it)
      {
        return __it.base();
      }
  };
  template < typename _InIter >
  using _RequireInputIter = typename ::std::enable_if<is_convertible<typename ::std::iterator_traits<_InIter>::iterator_category, ::std::input_iterator_tag>::value>::type;
  namespace __debug { }
}
namespace __gnu_debug {
  using namespace ::std::__debug;
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type __distance(_InputIterator __first, _InputIterator __last, ::std::input_iterator_tag)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last)
      {
         ++__first;
         ++__n;
      }
    return __n;
  }
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator >
  inline typename ::std::iterator_traits<_RandomAccessIterator>::difference_type __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, ::std::random_access_iterator_tag)
  {
    return __last - __first;
  }
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last);
  template < typename _InputIterator >
  inline typename ::std::iterator_traits<_InputIterator>::difference_type distance(_InputIterator __first, _InputIterator __last)
  {
    return std::__distance(__first, __last, std::__iterator_category(__first));
  }
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag);
  template < typename _InputIterator, typename _Distance >
  inline void __advance(_InputIterator &__i, _Distance __n, ::std::input_iterator_tag)
  {
    ;
    while (__n--)
      {
         ++__i;
      }
  }
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag);
  template < typename _BidirectionalIterator, typename _Distance >
  inline void __advance(_BidirectionalIterator &__i, _Distance __n, ::std::bidirectional_iterator_tag)
  {
    if (__n > 0)
      {
        while (__n--)
          {
             ++__i;
          }
      }
    else
      {
        while (__n++)
          {
             --__i;
          }
      }
  }
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag);
  template < typename _RandomAccessIterator, typename _Distance >
  inline void __advance(_RandomAccessIterator &__i, _Distance __n, ::std::random_access_iterator_tag)
  {
    __i += __n;
  }
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n);
  template < typename _InputIterator, typename _Distance >
  inline void advance(_InputIterator &__i, _Distance __n)
  {
    typename ::std::iterator_traits<_InputIterator>::difference_type __d = __n;
    std::__advance(__i, __d, std::__iterator_category(__i));
  }
  template < typename _ForwardIterator >
  inline _ForwardIterator next(_ForwardIterator __x, typename ::std::iterator_traits<_ForwardIterator>::difference_type __n  = (1));
  template < typename _ForwardIterator >
  inline _ForwardIterator next(_ForwardIterator __x, typename ::std::iterator_traits<_ForwardIterator>::difference_type __n)
  {
    std::advance(__x, __n);
    return __x;
  }
  template < typename _BidirectionalIterator >
  inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename ::std::iterator_traits<_BidirectionalIterator>::difference_type __n  = (1));
  template < typename _BidirectionalIterator >
  inline _BidirectionalIterator prev(_BidirectionalIterator __x, typename ::std::iterator_traits<_BidirectionalIterator>::difference_type __n)
  {
    std::advance(__x,  -__n);
    return __x;
  }
  template < typename _Tp, typename __type_tpl__param_1_1__ = ::std::__void_t<> >
  struct  __has_element_type : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __has_element_type<_Tp, ::std::__void_t<typename _Tp::element_type> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp, typename __type_tpl__param_1_1__ = ::std::__void_t<> >
  struct  __has_difference_type : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __has_difference_type<_Tp, ::std::__void_t<typename _Tp::difference_type> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __has_element_type<_Tp>::value >
  struct __ptrtr_elt_type;
  template < typename _Tp >
  struct  __ptrtr_elt_type<_Tp, true>
  {
      typedef typename _Tp::element_type __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _SomePtr, typename _Tp, typename ..._Args >
  struct  __ptrtr_elt_type<_SomePtr<_Tp, _Args ...>, false>
  {
      typedef _Tp __type;
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __has_difference_type<_Tp>::value >
  struct  __ptrtr_diff_type
  {
      typedef typename _Tp::difference_type __type;
  };
  template < typename _Tp >
  struct  __ptrtr_diff_type<_Tp, false>
  {
      typedef ::std::ptrdiff_t __type;
  };
  template < typename _Ptr, typename _Up >
  class  __ptrtr_rebind_helper
  {
      template < typename _Ptr2, typename _Up2 >
      static inline constexpr ::std::true_type _S_chk(typename _Ptr2::template rebind< _Up2> *);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static inline constexpr ::std::false_type _S_chk(...);
    public:
      typedef decltype(_S_chk<_Ptr, _Up>(nullptr)) __type;
  };
  template < typename _Tp, typename _Up, bool __nontype_tpl_param_1_2__ = __ptrtr_rebind_helper<_Tp, _Up>::__type::value >
  struct __ptrtr_rebind;
  template < typename _Tp, typename _Up >
  struct  __ptrtr_rebind<_Tp, _Up, true>
  {
      typedef typename _Tp::template rebind< _Up> __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _SomePtr, typename _Up, typename _Tp, typename ..._Args >
  struct  __ptrtr_rebind<_SomePtr<_Tp, _Args ...>, _Up, false>
  {
      typedef _SomePtr<_Up, _Args ...> __type;
  };
  template < typename _Tp, typename __type_tpl__param_1_1__ = typename ::std::remove_cv<_Tp>::type >
  struct  __ptrtr_not_void
  {
      typedef _Tp __type;
  };
  template < typename _Tp >
  struct  __ptrtr_not_void<_Tp, void>
  {
      struct  __type
      {
      };
  };
  template < typename _Ptr >
  class  __ptrtr_pointer_to
  {
      typedef typename ::std::__ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename ::std::__ptrtr_not_void<typename ::std::__ptrtr_pointer_to<_Ptr>::__orig_type>::__type __element_type;
    public:
      static inline _Ptr pointer_to(typename ::std::__ptrtr_pointer_to<_Ptr>::__element_type &__e)
      {
        return _Ptr::pointer_to(__e);
      }
  };
  template < typename _Ptr >
  struct  pointer_traits : ::std::__ptrtr_pointer_to<_Ptr>
  {
      typedef _Ptr pointer;
      typedef typename ::std::__ptrtr_elt_type<_Ptr>::__type element_type;
      typedef typename ::std::__ptrtr_diff_type<_Ptr>::__type difference_type;
      template < typename _Up >
      using rebind = typename ::std::__ptrtr_rebind<_Ptr, _Up>::__type;
  };
  template < typename _Tp >
  struct  pointer_traits<_Tp *>
  {
      typedef _Tp *pointer;
      typedef _Tp element_type;
      typedef ::std::ptrdiff_t difference_type;
      template < typename _Up >
      using rebind = _Up *;
      static inline typename ::std::pointer_traits<_Tp *>::pointer pointer_to(typename ::std::__ptrtr_not_void<typename ::std::pointer_traits<_Tp *>::element_type>::__type &__r) noexcept(true)
      {
        return std::addressof(__r);
      }
  };
  template < typename _Iterator >
  class  reverse_iterator : public ::std::iterator<typename ::std::iterator_traits<_Iterator>::iterator_category, typename ::std::iterator_traits<_Iterator>::value_type, typename ::std::iterator_traits<_Iterator>::difference_type, typename ::std::iterator_traits<_Iterator>::pointer, typename ::std::iterator_traits<_Iterator>::reference>
  {
    protected:
      _Iterator current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      inline reverse_iterator()
        : current()
      {
      }
      inline explicit reverse_iterator(typename ::std::reverse_iterator<_Iterator>::iterator_type __x)
        : current(__x)
      {
      }
      inline reverse_iterator(const ::std::reverse_iterator<_Iterator> &__x)
        : current(__x.current)
      {
      }
      template < typename _Iter >
      inline reverse_iterator(const ::std::reverse_iterator<_Iter> &__x)
        : current(__x.base())
      {
      }
      inline typename ::std::reverse_iterator<_Iterator>::iterator_type base() const 
      {
        return ::std::reverse_iterator<_Iterator>::current;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator *() const 
      {
        _Iterator __tmp = ::std::reverse_iterator<_Iterator>::current;
        return * --__tmp;
      }
      inline typename ::std::reverse_iterator<_Iterator>::pointer operator ->() const 
      {
        return &(*this).operator *();
      }
      inline ::std::reverse_iterator<_Iterator> &operator ++()
      {
         --::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator ++(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         --::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> &operator --()
      {
         ++::std::reverse_iterator<_Iterator>::current;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator --(int)
      {
        ::std::reverse_iterator<_Iterator> __tmp = *this;
         ++::std::reverse_iterator<_Iterator>::current;
        return __tmp;
      }
      inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current - __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator +=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current -= __n;
        return *this;
      }
      inline ::std::reverse_iterator<_Iterator> operator -(typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::reverse_iterator<_Iterator>(::std::reverse_iterator<_Iterator>::current + __n);
      }
      inline ::std::reverse_iterator<_Iterator> &operator -=(typename ::std::reverse_iterator<_Iterator>::difference_type __n)
      {
        ::std::reverse_iterator<_Iterator>::current += __n;
        return *this;
      }
      inline typename ::std::reverse_iterator<_Iterator>::reference operator [](typename ::std::reverse_iterator<_Iterator>::difference_type __n) const 
      {
        return *(*this + __n);
      }
  };
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline typename ::std::reverse_iterator<_Iterator>::difference_type operator -(const ::std::reverse_iterator<_Iterator> &__x, const ::std::reverse_iterator<_Iterator> &__y)
  {
    return __y.base() - __x.base();
  }
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::reverse_iterator<_Iterator> operator +(typename ::std::reverse_iterator<_Iterator>::difference_type __n, const ::std::reverse_iterator<_Iterator> &__x)
  {
    return ::std::reverse_iterator<_Iterator>(__x.base() - __n);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y.base() < __x.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base());
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::reverse_iterator<_IteratorL> &__x, const ::std::reverse_iterator<_IteratorR> &__y) -> decltype(__y.base() - __x.base())
  {
    return __y.base() - __x.base();
  }
 /* Instantiation of class template '::std::iterator< ::std::output_iterator_tag, void, void, void, void>' */ 
  template < typename _Container >
  class  back_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit back_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::back_insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::back_insert_iterator<_Container>::container->push_back(__value);
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::back_insert_iterator<_Container>::container->push_back(std::move(__value));
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::back_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::back_insert_iterator<_Container> back_inserter(_Container &__x)
  {
    return ::std::back_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  front_insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
    public:
      typedef _Container container_type;
      inline explicit front_insert_iterator(_Container &__x)
        : container(&__x)
      {
      }
      inline ::std::front_insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::front_insert_iterator<_Container>::container->push_front(__value);
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::front_insert_iterator<_Container>::container->push_front(std::move(__value));
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::front_insert_iterator<_Container> operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x);
  template < typename _Container >
  inline ::std::front_insert_iterator<_Container> front_inserter(_Container &__x)
  {
    return ::std::front_insert_iterator<_Container>(__x);
  }
  template < typename _Container >
  class  insert_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    protected:
      _Container *container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      inline insert_iterator(_Container &__x, typename _Container::iterator __i)
        : container(&__x), iter(__i)
      {
      }
      inline ::std::insert_iterator<_Container> &operator =(const typename _Container::value_type &__value)
      {
        ::std::insert_iterator<_Container>::iter = ::std::insert_iterator<_Container>::container->insert(::std::insert_iterator<_Container>::iter, __value);
         ++::std::insert_iterator<_Container>::iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator =(typename _Container::value_type &&__value)
      {
        ::std::insert_iterator<_Container>::iter = ::std::insert_iterator<_Container>::container->insert(::std::insert_iterator<_Container>::iter, std::move(__value));
         ++::std::insert_iterator<_Container>::iter;
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator *()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++()
      {
        return *this;
      }
      inline ::std::insert_iterator<_Container> &operator ++(int)
      {
        return *this;
      }
  };
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i);
  template < typename _Container, typename _Iterator >
  inline ::std::insert_iterator<_Container> inserter(_Container &__x, _Iterator __i)
  {
    return ::std::insert_iterator<_Container>(__x, typename _Container::iterator(__i));
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::iterator_traits;
  using ::std::iterator;
  template < typename _Iterator, typename _Container >
  class  __normal_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef typename ::std::iterator_traits<_Iterator>::reference reference;
      typedef typename ::std::iterator_traits<_Iterator>::pointer pointer;
      inline constexpr __normal_iterator() noexcept(true)
        : _M_current(_Iterator())
      {
      }
      inline explicit __normal_iterator(const _Iterator &__i) noexcept(true)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline __normal_iterator(const ::__gnu_cxx::__normal_iterator<_Iter, typename ::__gnu_cxx::__enable_if<std::__are_same<_Iter, typename _Container::pointer>::__value, _Container>::__type> &__i) noexcept(true)
        : _M_current(__i.base())
      {
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator *() const  noexcept(true)
      {
        return *::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::pointer operator ->() const  noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator ++() noexcept(true)
      {
         ++::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator ++(int) noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current++);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator --() noexcept(true)
      {
         --::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator --(int) noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current--);
      }
      inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::reference operator [](typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const  noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current[__n];
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator +=(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) noexcept(true)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current += __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const  noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current + __n);
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &operator -=(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) noexcept(true)
      {
        ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current -= __n;
        return *this;
      }
      inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator -(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n) const  noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current - __n);
      }
      inline const _Iterator &base() const  noexcept(true)
      {
        return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::_M_current;
      }
  };
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator ==(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() == __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator !=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() != __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator <(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() < __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator >(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() > __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator <=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() <= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true);
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline bool operator >=(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() >= __rhs.base();
  }
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline auto operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true) -> decltype(__lhs.base() - __rhs.base());
  template < typename _IteratorL, typename _IteratorR, typename _Container >
  inline auto operator -(const ::__gnu_cxx::__normal_iterator<_IteratorL, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_IteratorR, _Container> &__rhs) noexcept(true) -> decltype(__lhs.base() - __rhs.base())
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type operator -(const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__lhs, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__rhs) noexcept(true)
  {
    return __lhs.base() - __rhs.base();
  }
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i) noexcept(true);
  template < typename _Iterator, typename _Container >
  inline ::__gnu_cxx::__normal_iterator<_Iterator, _Container> operator +(typename ::__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type __n, const ::__gnu_cxx::__normal_iterator<_Iterator, _Container> &__i) noexcept(true)
  {
    return ::__gnu_cxx::__normal_iterator<_Iterator, _Container>(__i.base() + __n);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Iterator >
  class  move_iterator
  {
    protected:
      _Iterator _M_current;
      typedef ::std::iterator_traits<_Iterator> __traits_type;
      typedef typename ::std::iterator_traits<_Iterator>::reference __base_ref;
    public:
      typedef _Iterator iterator_type;
      typedef typename ::std::iterator_traits<_Iterator>::iterator_category iterator_category;
      typedef typename ::std::iterator_traits<_Iterator>::value_type value_type;
      typedef typename ::std::iterator_traits<_Iterator>::difference_type difference_type;
      typedef _Iterator pointer;
      typedef typename ::std::conditional<is_reference<typename ::std::move_iterator<_Iterator>::__base_ref>::value, typename ::std::remove_reference<typename ::std::move_iterator<_Iterator>::__base_ref>::type &&, typename ::std::move_iterator<_Iterator>::__base_ref>::type reference;
      inline move_iterator()
        : _M_current()
      {
      }
      inline explicit move_iterator(typename ::std::move_iterator<_Iterator>::iterator_type __i)
        : _M_current(__i)
      {
      }
      template < typename _Iter >
      inline move_iterator(const ::std::move_iterator<_Iter> &__i)
        : _M_current(__i.base())
      {
      }
      inline typename ::std::move_iterator<_Iterator>::iterator_type base() const 
      {
        return ::std::move_iterator<_Iterator>::_M_current;
      }
      inline typename ::std::move_iterator<_Iterator>::reference operator *() const 
      {
        return static_cast<typename ::std::move_iterator<_Iterator>::reference>(*::std::move_iterator<_Iterator>::_M_current);
      }
      inline typename ::std::move_iterator<_Iterator>::pointer operator ->() const 
      {
        return ::std::move_iterator<_Iterator>::_M_current;
      }
      inline ::std::move_iterator<_Iterator> &operator ++()
      {
         ++::std::move_iterator<_Iterator>::_M_current;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator ++(int)
      {
        ::std::move_iterator<_Iterator> __tmp = *this;
         ++::std::move_iterator<_Iterator>::_M_current;
        return __tmp;
      }
      inline ::std::move_iterator<_Iterator> &operator --()
      {
         --::std::move_iterator<_Iterator>::_M_current;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator --(int)
      {
        ::std::move_iterator<_Iterator> __tmp = *this;
         --::std::move_iterator<_Iterator>::_M_current;
        return __tmp;
      }
      inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::move_iterator<_Iterator>(::std::move_iterator<_Iterator>::_M_current + __n);
      }
      inline ::std::move_iterator<_Iterator> &operator +=(typename ::std::move_iterator<_Iterator>::difference_type __n)
      {
        ::std::move_iterator<_Iterator>::_M_current += __n;
        return *this;
      }
      inline ::std::move_iterator<_Iterator> operator -(typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return ::std::move_iterator<_Iterator>(::std::move_iterator<_Iterator>::_M_current - __n);
      }
      inline ::std::move_iterator<_Iterator> &operator -=(typename ::std::move_iterator<_Iterator>::difference_type __n)
      {
        ::std::move_iterator<_Iterator>::_M_current -= __n;
        return *this;
      }
      inline typename ::std::move_iterator<_Iterator>::reference operator [](typename ::std::move_iterator<_Iterator>::difference_type __n) const 
      {
        return std::move(::std::move_iterator<_Iterator>::_M_current[__n]);
      }
  };
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator ==(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _Iterator >
  inline bool operator ==(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator ==(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __x.base() == __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator !=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__x == __y);
  }
  template < typename _Iterator >
  inline bool operator !=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator !=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__x == __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __x.base() < __y.base();
  }
  template < typename _Iterator >
  inline bool operator <(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __x.base() < __y.base();
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator <=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__y < __x);
  }
  template < typename _Iterator >
  inline bool operator <=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator <=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__y < __x);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return __y < __x;
  }
  template < typename _Iterator >
  inline bool operator >(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return __y < __x;
  }
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y);
  template < typename _IteratorL, typename _IteratorR >
  inline bool operator >=(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y)
  {
    return !(__x < __y);
  }
  template < typename _Iterator >
  inline bool operator >=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y);
  template < typename _Iterator >
  inline bool operator >=(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y)
  {
    return !(__x < __y);
  }
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base());
  template < typename _IteratorL, typename _IteratorR >
  inline auto operator -(const ::std::move_iterator<_IteratorL> &__x, const ::std::move_iterator<_IteratorR> &__y) -> decltype(__x.base() - __y.base())
  {
    return __x.base() - __y.base();
  }
  template < typename _Iterator >
  inline auto operator -(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y) -> decltype(__x.base() - __y.base());
  template < typename _Iterator >
  inline auto operator -(const ::std::move_iterator<_Iterator> &__x, const ::std::move_iterator<_Iterator> &__y) -> decltype(__x.base() - __y.base())
  {
    return __x.base() - __y.base();
  }
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n, const ::std::move_iterator<_Iterator> &__x);
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> operator +(typename ::std::move_iterator<_Iterator>::difference_type __n, const ::std::move_iterator<_Iterator> &__x)
  {
    return __x + __n;
  }
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> make_move_iterator(_Iterator __i);
  template < typename _Iterator >
  inline ::std::move_iterator<_Iterator> make_move_iterator(_Iterator __i)
  {
    return ::std::move_iterator<_Iterator>(__i);
  }
  template < typename _Iterator, typename _ReturnType = typename ::std::conditional<__move_if_noexcept_cond<typename ::std::iterator_traits<_Iterator>::value_type>::value, _Iterator, ::std::move_iterator<_Iterator> >::type >
  inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i);
  template < typename _Iterator, typename _ReturnType >
  inline _ReturnType __make_move_if_noexcept_iterator(_Iterator __i)
  {
    return _ReturnType(__i);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  namespace __ops {
    struct  _Iter_less_iter
    {
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2) const 
        {
          return *__it1 < *__it2;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_less_iter __iter_less_iter()
    {
      return ::__gnu_cxx::__ops::_Iter_less_iter();
    }
    struct  _Iter_less_val
    {
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val) const 
        {
          return *__it < __val;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_less_val __iter_less_val()
    {
      return ::__gnu_cxx::__ops::_Iter_less_val();
    }
    inline ::__gnu_cxx::__ops::_Iter_less_val __iter_comp_val(::__gnu_cxx::__ops::_Iter_less_iter)
    {
      return ::__gnu_cxx::__ops::_Iter_less_val();
    }
    struct  _Val_less_iter
    {
        template < typename _Value, typename _Iterator >
        inline bool operator ()(_Value &__val, _Iterator __it) const 
        {
          return __val < *__it;
        }
    };
    inline ::__gnu_cxx::__ops::_Val_less_iter __val_less_iter()
    {
      return ::__gnu_cxx::__ops::_Val_less_iter();
    }
    inline ::__gnu_cxx::__ops::_Val_less_iter __val_comp_iter(::__gnu_cxx::__ops::_Iter_less_iter)
    {
      return ::__gnu_cxx::__ops::_Val_less_iter();
    }
    struct  _Iter_equal_to_iter
    {
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2) const 
        {
          return *__it1 == *__it2;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_equal_to_iter __iter_equal_to_iter()
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_iter();
    }
    struct  _Iter_equal_to_val
    {
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val) const 
        {
          return *__it == __val;
        }
    };
    inline ::__gnu_cxx::__ops::_Iter_equal_to_val __iter_equal_to_val()
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_val();
    }
    inline ::__gnu_cxx::__ops::_Iter_equal_to_val __iter_comp_val(::__gnu_cxx::__ops::_Iter_equal_to_iter)
    {
      return ::__gnu_cxx::__ops::_Iter_equal_to_val();
    }
    template < typename _Compare >
    struct  _Iter_comp_iter
    {
        _Compare _M_comp;
        inline _Iter_comp_iter(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        template < typename _Iterator1, typename _Iterator2 >
        inline bool operator ()(_Iterator1 __it1, _Iterator2 __it2)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare>::_M_comp(*__it1, *__it2));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __iter_comp_iter(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_iter<_Compare>(__comp);
    }
    template < typename _Compare >
    struct  _Iter_comp_val
    {
        _Compare _M_comp;
        inline _Iter_comp_val(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        template < typename _Iterator, typename _Value >
        inline bool operator ()(_Iterator __it, _Value &__val)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_val<_Compare>::_M_comp(*__it, __val));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_val<_Compare>(__comp);
    }
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Iter_comp_val<_Compare> __iter_comp_val(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_val<_Compare>(__comp._M_comp);
    }
    template < typename _Compare >
    struct  _Val_comp_iter
    {
        _Compare _M_comp;
        inline _Val_comp_iter(_Compare __comp)
          : _M_comp(__comp)
        {
        }
        template < typename _Value, typename _Iterator >
        inline bool operator ()(_Value &__val, _Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Val_comp_iter<_Compare>::_M_comp(__val, *__it));
        }
    };
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(_Compare __comp)
    {
      return ::__gnu_cxx::__ops::_Val_comp_iter<_Compare>(__comp);
    }
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp);
    template < typename _Compare >
    inline ::__gnu_cxx::__ops::_Val_comp_iter<_Compare> __val_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp)
    {
      return ::__gnu_cxx::__ops::_Val_comp_iter<_Compare>(__comp._M_comp);
    }
    template < typename _Value >
    struct  _Iter_equals_val
    {
        _Value &_M_value;
        inline _Iter_equals_val(_Value &__value)
          : _M_value(__value)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return *__it == ::__gnu_cxx::__ops::_Iter_equals_val<_Value>::_M_value;
        }
    };
    template < typename _Value >
    inline ::__gnu_cxx::__ops::_Iter_equals_val<_Value> __iter_equals_val(_Value &__val);
    template < typename _Value >
    inline ::__gnu_cxx::__ops::_Iter_equals_val<_Value> __iter_equals_val(_Value &__val)
    {
      return ::__gnu_cxx::__ops::_Iter_equals_val<_Value>(__val);
    }
    template < typename _Iterator1 >
    struct  _Iter_equals_iter
    {
        typename ::std::iterator_traits<_Iterator1>::reference _M_ref;
        inline _Iter_equals_iter(_Iterator1 __it1)
          : _M_ref(*__it1)
        {
        }
        template < typename _Iterator2 >
        inline bool operator ()(_Iterator2 __it2)
        {
          return *__it2 == ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::_M_ref;
        }
    };
    template < typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it);
    template < typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator __it)
    {
      return ::__gnu_cxx::__ops::_Iter_equals_iter<_Iterator>(__it);
    }
    template < typename _Predicate >
    struct  _Iter_pred
    {
        _Predicate _M_pred;
        inline _Iter_pred(_Predicate __pred)
          : _M_pred(__pred)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Iter_pred<_Predicate>::_M_pred(*__it));
        }
    };
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred_iter(_Predicate __pred);
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred_iter(_Predicate __pred)
    {
      return ::__gnu_cxx::__ops::_Iter_pred<_Predicate>(__pred);
    }
    template < typename _Compare, typename _Value >
    struct  _Iter_comp_to_val
    {
        _Compare _M_comp;
        _Value &_M_value;
        inline _Iter_comp_to_val(_Compare __comp, _Value &__value)
          : _M_comp(__comp), _M_value(__value)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>::_M_comp(*__it, ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>::_M_value));
        }
    };
    template < typename _Compare, typename _Value >
    ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val);
    template < typename _Compare, typename _Value >
    ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value> __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_to_val<_Compare, _Value>(__comp, __val);
    }
    template < typename _Compare, typename _Iterator1 >
    struct  _Iter_comp_to_iter
    {
        _Compare _M_comp;
        typename ::std::iterator_traits<_Iterator1>::reference _M_ref;
        inline _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
          : _M_comp(__comp), _M_ref(*__it1)
        {
        }
        template < typename _Iterator2 >
        inline bool operator ()(_Iterator2 __it2)
        {
          return bool(::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator1>::_M_comp(*__it2, ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator1>::_M_ref));
        }
    };
    template < typename _Compare, typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp, _Iterator __it);
    template < typename _Compare, typename _Iterator >
    inline ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator> __iter_comp_iter(::__gnu_cxx::__ops::_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return ::__gnu_cxx::__ops::_Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it);
    }
    template < typename _Predicate >
    struct  _Iter_negate
    {
        _Predicate _M_pred;
        inline _Iter_negate(_Predicate __pred)
          : _M_pred(__pred)
        {
        }
        template < typename _Iterator >
        inline bool operator ()(_Iterator __it)
        {
          return !bool(::__gnu_cxx::__ops::_Iter_negate<_Predicate>::_M_pred(*__it));
        }
    };
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_negate<_Predicate> __negate(::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred);
    template < typename _Predicate >
    inline ::__gnu_cxx::__ops::_Iter_negate<_Predicate> __negate(::__gnu_cxx::__ops::_Iter_pred<_Predicate> __pred)
    {
      return ::__gnu_cxx::__ops::_Iter_negate<_Predicate>(__pred._M_pred);
    }
  }
}
namespace std __attribute__((__visibility__("default"))) {
   template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  inline void iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
  {
    swap(*__a, *__b);
  }
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2);
  template < typename _ForwardIterator1, typename _ForwardIterator2 >
  _ForwardIterator2 swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        std::iter_swap(__first1, __first2);
      }
    return __first2;
  }
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b)
  {
    if (__b < __a)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b);
  template < typename _Tp >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b)
  {
    if (__a < __b)
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &min(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__b, __a))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp);
  template < typename _Tp, typename _Compare >
  inline const _Tp &max(const _Tp &__a, const _Tp &__b, _Compare __comp)
  {
    if (__comp(__a, __b))
      {
        return __b;
      }
    return __a;
  }
  template < typename _Iterator >
  struct  _Niter_base : ::std::_Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Niter_base<_Iterator>::iterator_type __niter_base(_Iterator __it)
  {
    return std::_Niter_base<_Iterator>::_S_base(__it);
  }
  template < typename _Iterator >
  struct  _Miter_base : ::std::_Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
  {
  };
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it);
  template < typename _Iterator >
  inline typename ::std::_Miter_base<_Iterator>::iterator_type __miter_base(_Iterator __it)
  {
    return std::_Miter_base<_Iterator>::_S_base(__it);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; ( ++__result,  ++__first))
          {
            *__result = *__first;
          }
        return __result;
      }
  };
  template < typename _Category >
  struct  __copy_move<true, false, _Category>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        for (; __first != __last; ( ++__result,  ++__first))
          {
            *__result = std::move(*__first);
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0;  --__n)
          {
            *__result = *__first;
             ++__first;
             ++__result;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move<true, false, ::std::random_access_iterator_tag>
  {
      template < typename _II, typename _OI >
      static inline _OI __copy_m(_II __first, _II __last, _OI __result)
      {
        typedef typename ::std::iterator_traits<_II>::difference_type _Distance;
        for (_Distance __n = __last - __first; __n > 0;  --__n)
          {
            *__result = std::move(*__first);
             ++__first;
             ++__result;
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_m(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        static_assert(is_copy_assignable<_Tp>::value, "type is not assignable");
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
          }
        return __result + _Num;
      }
  };
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a(_II __first, _II __last, _OI __result)
  {
    typedef typename ::std::iterator_traits<_II>::value_type _ValueTypeI;
    typedef typename ::std::iterator_traits<_OI>::value_type _ValueTypeO;
    typedef typename ::std::iterator_traits<_II>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueTypeI)) && __is_pointer<_II>::__value) && __is_pointer<_OI>::__value) && __are_same<_ValueTypeI, _ValueTypeO>::__value;
    return std::__copy_move<_IsMove, __simple, _Category>::__copy_m(__first, __last, __result);
  }
  template < typename _CharT >
  struct char_traits;
  template < typename _CharT, typename _Traits >
  class istreambuf_iterator;
  template < typename _CharT, typename _Traits >
  class ostreambuf_iterator;
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __result);
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __first, ::std::istreambuf_iterator<_CharT, ::std::char_traits<_CharT> > __last, _CharT *__result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result);
  template < bool _IsMove, typename _II, typename _OI >
  inline _OI __copy_move_a2(_II __first, _II __last, _OI __result)
  {
    return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI copy(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<__is_move_iterator<_II>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _II, typename _OI >
  inline _OI move(_II __first, _II __last, _OI __result);
  template < typename _II, typename _OI >
  inline _OI move(_II __first, _II __last, _OI __result)
  {
    ;
    return std::__copy_move_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < bool __nontype_tpl_param_1_0__, bool __nontype_tpl_param_1_1__, typename __type_tpl__param_1_2__ >
  struct  __copy_move_backward
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template < typename _Category >
  struct  __copy_move_backward<true, false, _Category>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        while (__first != __last)
          {
            * --__result = std::move(* --__last);
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<false, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0;  --__n)
          {
            * --__result = * --__last;
          }
        return __result;
      }
  };
  template <>
  struct  __copy_move_backward<true, false, ::std::random_access_iterator_tag>
  {
      template < typename _BI1, typename _BI2 >
      static inline _BI2 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
      {
        typename ::std::iterator_traits<_BI1>::difference_type __n;
        for (__n = __last - __first; __n > 0;  --__n)
          {
            * --__result = std::move(* --__last);
          }
        return __result;
      }
  };
  template < bool _IsMove >
  struct  __copy_move_backward<_IsMove, true, ::std::random_access_iterator_tag>
  {
      template < typename _Tp >
      static inline _Tp *__copy_move_b(const _Tp *__first, const _Tp *__last, _Tp *__result)
      {
        static_assert(is_copy_assignable<_Tp>::value, "type is not assignable");
        const ::std::ptrdiff_t _Num = __last - __first;
        if (_Num)
          {
            __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
          }
        return __result - _Num;
      }
  };
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    typedef typename ::std::iterator_traits<_BI1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_BI2>::value_type _ValueType2;
    typedef typename ::std::iterator_traits<_BI1>::iterator_category _Category;
    const bool __simple = (((__is_trivial(_ValueType1)) && __is_pointer<_BI1>::__value) && __is_pointer<_BI2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__copy_move_backward<_IsMove, __simple, _Category>::__copy_move_b(__first, __last, __result);
  }
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result);
  template < bool _IsMove, typename _BI1, typename _BI2 >
  inline _BI2 __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    return _BI2(std::__copy_move_backward_a<_IsMove>(std::__niter_base(__first), std::__niter_base(__last), std::__niter_base(__result)));
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _BI1, typename _BI2 >
  inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result);
  template < typename _BI1, typename _BI2 >
  inline _BI2 move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
  {
    ;
    return std::__copy_move_backward_a2<true>(std::__miter_base(__first), std::__miter_base(__last), __result);
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    for (; __first != __last;  ++__first)
      {
        *__first = __value;
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type __fill_a(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (; __first != __last;  ++__first)
      {
        *__first = __tmp;
      }
  }
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c);
  template < typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type __fill_a(_Tp *__first, _Tp *__last, const _Tp &__c)
  {
    const _Tp __tmp = __c;
    if (const ::std::size_t __len = __last - __first)
      {
        __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
      }
  }
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value);
  template < typename _ForwardIterator, typename _Tp >
  inline void fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)
  {
    ;
    std::__fill_a(std::__niter_base(__first), std::__niter_base(__last), __value);
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    for (decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __value;
      }
    return __first;
  }
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value);
  template < typename _OutputIterator, typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type __fill_n_a(_OutputIterator __first, _Size __n, const _Tp &__value)
  {
    const _Tp __tmp = __value;
    for (decltype(__n + 0) __niter = __n; __niter > 0; ( --__niter,  ++__first))
      {
        *__first = __tmp;
      }
    return __first;
  }
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c);
  template < typename _Size, typename _Tp >
  inline typename ::__gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp *>::__type __fill_n_a(_Tp *__first, _Size __n, const _Tp &__c)
  {
    std::__fill_a(__first, __first + __n, __c);
    return __first + __n;
  }
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value);
  template < typename _OI, typename _Size, typename _Tp >
  inline _OI fill_n(_OI __first, _Size __n, const _Tp &__value)
  {
    return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
  }
  template < bool _BoolType >
  struct  __equal
  {
      template < typename _II1, typename _II2 >
      static inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
      {
        for (; __first1 != __last1; ( ++__first1,  ++__first2))
          {
            if (!(*__first1 == *__first2))
              {
                return false;
              }
          }
        return true;
      }
  };
  template <>
  struct  __equal<true>
  {
      template < typename _Tp >
      static inline bool equal(const _Tp *__first1, const _Tp *__last1, const _Tp *__first2)
      {
        if (const ::std::size_t __len = __last1 - __first1)
          {
            return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
          }
        return true;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = (((__is_integer<_ValueType1>::__value || __is_pointer<_ValueType1>::__value) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value) && __are_same<_ValueType1, _ValueType2>::__value;
    return std::__equal<__simple>::equal(__first1, __last1, __first2);
  }
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct  __lc_rai
  {
      template < typename _II1, typename _II2 >
      static inline _II1 __newlast1(_II1, _II1 __last1, _II2, _II2)
      {
        return __last1;
      }
      template < typename _II >
      static inline bool __cnd2(_II __first, _II __last)
      {
        return __first != __last;
      }
  };
  template <>
  struct  __lc_rai< ::std::random_access_iterator_tag, ::std::random_access_iterator_tag>
  {
      template < typename _RAI1, typename _RAI2 >
      static inline _RAI1 __newlast1(_RAI1 __first1, _RAI1 __last1, _RAI2 __first2, _RAI2 __last2)
      {
        const typename ::std::iterator_traits<_RAI1>::difference_type __diff1 = __last1 - __first1;
        const typename ::std::iterator_traits<_RAI2>::difference_type __diff2 = __last2 - __first2;
        return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
      }
      template < typename _RAI >
      static inline bool __cnd2(_RAI, _RAI)
      {
        return true;
      }
  };
  template < typename _II1, typename _II2, typename _Compare >
  bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  bool __lexicographical_compare_impl(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_II1>::iterator_category _Category1;
    typedef typename ::std::iterator_traits<_II2>::iterator_category _Category2;
    typedef ::std::__lc_rai<_Category1, _Category2> __rai_type;
    __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
    for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2); ( ++__first1,  ++__first2))
      {
        if (__comp(__first1, __first2))
          {
            return true;
          }
        if (__comp(__first2, __first1))
          {
            return false;
          }
      }
    return __first1 == __last1 && __first2 != __last2;
  }
  template < bool _BoolType >
  struct  __lexicographical_compare
  {
      template < typename _II1, typename _II2 >
      static bool __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  };
  template < bool _BoolType >
  template < typename _II1, typename _II2 >
  bool __lexicographical_compare<_BoolType>::__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_less_iter());
  }
  template <>
  struct  __lexicographical_compare<true>
  {
      template < typename _Tp, typename _Up >
      static inline bool __lc(const _Tp *__first1, const _Tp *__last1, const _Up *__first2, const _Up *__last2)
      {
        const ::std::size_t __len1 = __last1 - __first1;
        const ::std::size_t __len2 = __last2 - __first2;
        if (const ::std::size_t __len = std::min(__len1, __len2))
          {
            if (int __result = __builtin_memcmp(__first1, __first2, __len))
              {
                return __result < 0;
              }
          }
        return __len1 < __len2;
      }
  };
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool __lexicographical_compare_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    typedef typename ::std::iterator_traits<_II1>::value_type _ValueType1;
    typedef typename ::std::iterator_traits<_II2>::value_type _ValueType2;
    const bool __simple = ((((__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value) && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed) && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed) && __is_pointer<_II1>::__value) && __is_pointer<_II2>::__value;
    return std::__lexicographical_compare<__simple>::__lc(__first1, __last1, __first2, __last2);
  }
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp);
  template < typename _ForwardIterator, typename _Tp, typename _Compare >
  _ForwardIterator __lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)
  {
    typedef typename ::std::iterator_traits<_ForwardIterator>::difference_type _DistanceType;
    _DistanceType __len = std::distance(__first, __last);
    while (__len > 0)
      {
        _DistanceType __half = __len >> 1;
        _ForwardIterator __middle = __first;
        std::advance(__middle, __half);
        if (__comp(__middle, __val))
          {
            __first = __middle;
             ++__first;
            __len = __len - __half - 1;
          }
        else
          {
            __len = __half;
          }
      }
    return __first;
  }
  template < typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val);
  template < typename _ForwardIterator, typename _Tp >
  inline _ForwardIterator lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)
  {
    ;
    return std::__lower_bound(__first, __last, __val, __gnu_cxx::__ops::__iter_less_val());
  }
  inline constexpr int __lg(int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline constexpr unsigned int __lg(unsigned int __n)
  {
    return sizeof(int) * 8 - 1 - __builtin_clz(__n);
  }
  inline constexpr long int __lg(long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline constexpr unsigned long int __lg(unsigned long int __n)
  {
    return sizeof(long int) * 8 - 1 - __builtin_clzl(__n);
  }
  inline constexpr long long int __lg(long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  inline constexpr unsigned long long int __lg(unsigned long long int __n)
  {
    return sizeof(long long int) * 8 - 1 - __builtin_clzll(__n);
  }
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2);
  template < typename _II1, typename _II2 >
  inline bool equal(_II1 __first1, _II1 __last1, _II2 __first2)
  {
    ;
    return std::__equal_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2));
  }
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred);
  template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
  inline bool equal(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    for (; __first1 != __last1; ( ++__first1,  ++__first2))
      {
        if (!bool(__binary_pred(*__first1, *__first2)))
          {
            return false;
          }
      }
    return true;
  }
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2);
  template < typename _II1, typename _II2 >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
  {
    ;
    ;
    return std::__lexicographical_compare_aux(std::__niter_base(__first1), std::__niter_base(__last1), std::__niter_base(__first2), std::__niter_base(__last2));
  }
  template < typename _II1, typename _II2, typename _Compare >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp);
  template < typename _II1, typename _II2, typename _Compare >
  inline bool lexicographical_compare(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
  {
    ;
    ;
    return std::__lexicographical_compare_impl(__first1, __last1, __first2, __last2, __gnu_cxx::__ops::__iter_comp_iter(__comp));
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  ::std::pair<_InputIterator1, _InputIterator2> __mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    while (__first1 != __last1 && __binary_pred(__first1, __first2))
      {
         ++__first1;
         ++__first2;
      }
    return ::std::pair<_InputIterator1, _InputIterator2>(__first1, __first2);
  }
  template < typename _InputIterator1, typename _InputIterator2 >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2);
  template < typename _InputIterator1, typename _InputIterator2 >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
  {
    ;
    return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_equal_to_iter());
  }
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred);
  template < typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate >
  inline ::std::pair<_InputIterator1, _InputIterator2> mismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
  {
    ;
    return std::__mismatch(__first1, __last1, __first2, __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  _Char_types
  {
      typedef unsigned long int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
  };
  template < typename _CharT >
  struct  char_traits
  {
      typedef _CharT char_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::int_type int_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::pos_type pos_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::off_type off_type;
      typedef typename ::__gnu_cxx::_Char_types<_CharT>::state_type state_type;
      static inline void assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c2)
      {
        return __c1 < __c2;
      }
      static int compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static ::std::size_t length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p);
      static const typename ::__gnu_cxx::char_traits<_CharT>::char_type *find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n);
      static typename ::__gnu_cxx::char_traits<_CharT>::char_type *assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a);
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::char_type to_char_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::char_type>(__c);
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type to_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__c)
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>(__c);
      }
      static inline constexpr bool eq_int_type(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c1, const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c2)
      {
        return __c1 == __c2;
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type eof()
      {
        return static_cast<typename ::__gnu_cxx::char_traits<_CharT>::int_type>( -1);
      }
      static inline constexpr typename ::__gnu_cxx::char_traits<_CharT>::int_type not_eof(const typename ::__gnu_cxx::char_traits<_CharT>::int_type &__c)
      {
        return !eq_int_type(__c, eof()) ? __c : to_int_type(((typename ::__gnu_cxx::char_traits<_CharT>::char_type())));
      }
  };
  template < typename _CharT >
  int char_traits<_CharT>::compare(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (lt(__s1[__i], __s2[__i]))
          {
            return  -1;
          }
        else
          {
            if (lt(__s2[__i], __s1[__i]))
              {
                return 1;
              }
          }
      }
    return 0;
  }
  template < typename _CharT >
  ::std::size_t char_traits<_CharT>::length(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__p)
  {
    ::std::size_t __i(0);
    while (!eq(__p[__i], ((typename ::__gnu_cxx::char_traits<_CharT>::char_type()))))
      {
         ++__i;
      }
    return __i;
  }
  template < typename _CharT >
  const typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::find(const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, const typename ::__gnu_cxx::char_traits<_CharT>::char_type &__a)
  {
    for (::std::size_t __i(0); __i < __n;  ++__i)
      {
        if (eq(__s[__i], __a))
          {
            return __s + __i;
          }
      }
    return 0;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::move(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    return static_cast<_CharT *>(__builtin_memmove(__s1, __s2, __n * sizeof(typename ::__gnu_cxx::char_traits<_CharT>::char_type)));
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::copy(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s1, const typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s2, ::std::size_t __n)
  {
    std::copy(__s2, __s2 + __n, __s1);
    return __s1;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::char_traits<_CharT>::char_type *char_traits<_CharT>::assign(typename ::__gnu_cxx::char_traits<_CharT>::char_type *__s, ::std::size_t __n, typename ::__gnu_cxx::char_traits<_CharT>::char_type __a)
  {
    std::fill_n(__s, __n, __a);
    return __s;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT >
  struct  char_traits : ::__gnu_cxx::char_traits<_CharT>
  {
  };
  template <>
  struct  char_traits<char>
  {
      typedef char char_type;
      typedef int int_type;
      typedef ::std::streampos pos_type;
      typedef ::std::streamoff off_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char>::char_type &__c1, const ::std::char_traits<char>::char_type &__c2) noexcept(true)
      {
        return static_cast<unsigned char>(__c1) < static_cast<unsigned char>(__c2);
      }
      static inline int compare(const ::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return 0;
          }
        return __builtin_memcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<char>::char_type *__s)
      {
        return __builtin_strlen(__s);
      }
      static inline const ::std::char_traits<char>::char_type *find(const ::std::char_traits<char>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char>::char_type &__a)
      {
        if (__n == 0)
          {
            return 0;
          }
        return static_cast<const ::std::char_traits<char>::char_type *>(__builtin_memchr(__s, __a, __n));
      }
      static inline ::std::char_traits<char>::char_type *move(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memmove(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *copy(::std::char_traits<char>::char_type *__s1, const ::std::char_traits<char>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memcpy(__s1, __s2, __n));
      }
      static inline ::std::char_traits<char>::char_type *assign(::std::char_traits<char>::char_type *__s, ::std::size_t __n, ::std::char_traits<char>::char_type __a)
      {
        if (__n == 0)
          {
            return __s;
          }
        return static_cast< ::std::char_traits<char>::char_type *>(__builtin_memset(__s, __a, __n));
      }
      static inline constexpr ::std::char_traits<char>::char_type to_char_type(const ::std::char_traits<char>::int_type &__c) noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::char_type>(__c);
      }
      static inline constexpr ::std::char_traits<char>::int_type to_int_type(const ::std::char_traits<char>::char_type &__c) noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::int_type>(static_cast<unsigned char>(__c));
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char>::int_type &__c1, const ::std::char_traits<char>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char>::int_type not_eof(const ::std::char_traits<char>::int_type &__c) noexcept(true)
      {
        return __c == ::std::char_traits<char>::eof() ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<wchar_t>
  {
      typedef wchar_t char_type;
      typedef ::wint_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::wstreampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<wchar_t>::char_type &__c1, const ::std::char_traits<wchar_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return 0;
          }
        return ::std::wmemcmp(__s1, __s2, __n);
      }
      static inline ::std::size_t length(const ::std::char_traits<wchar_t>::char_type *__s)
      {
        return ::std::wcslen(__s);
      }
      static inline const ::std::char_traits<wchar_t>::char_type *find(const ::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<wchar_t>::char_type &__a)
      {
        if (__n == 0)
          {
            return 0;
          }
        return ::std::wmemchr(__s, __a, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *move(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return ::std::wmemmove(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *copy(::std::char_traits<wchar_t>::char_type *__s1, const ::std::char_traits<wchar_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return ::std::wmemcpy(__s1, __s2, __n);
      }
      static inline ::std::char_traits<wchar_t>::char_type *assign(::std::char_traits<wchar_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<wchar_t>::char_type __a)
      {
        if (__n == 0)
          {
            return __s;
          }
        return ::std::wmemset(__s, __a, __n);
      }
      static inline constexpr ::std::char_traits<wchar_t>::char_type to_char_type(const ::std::char_traits<wchar_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<wchar_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type to_int_type(const ::std::char_traits<wchar_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<wchar_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<wchar_t>::int_type &__c1, const ::std::char_traits<wchar_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<wchar_t>::int_type>(4294967295U);
      }
      static inline constexpr ::std::char_traits<wchar_t>::int_type not_eof(const ::std::char_traits<wchar_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<wchar_t>::eq_int_type(__c, ::std::char_traits<wchar_t>::eof()) ? 0 : __c;
      }
  };
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;
  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;
  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;
  using ::intmax_t;
  using ::intptr_t;
  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;
  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;
  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;
  using ::uintmax_t;
  using ::uintptr_t;
  template <>
  struct  char_traits<char16_t>
  {
      typedef char16_t char_type;
      typedef ::uint_least16_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::u16streampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char16_t>::char_type &__c1, const ::std::char_traits<char16_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char16_t>::lt(__s1[__i], __s2[__i]))
              {
                return  -1;
              }
            else
              {
                if (::std::char_traits<char16_t>::lt(__s2[__i], __s1[__i]))
                  {
                    return 1;
                  }
              }
          }
        return 0;
      }
      static inline ::std::size_t length(const ::std::char_traits<char16_t>::char_type *__s)
      {
        ::std::size_t __i(0);
        while (!::std::char_traits<char16_t>::eq(__s[__i], ::std::char_traits<char16_t>::char_type()))
          {
             ++__i;
          }
        return __i;
      }
      static inline const ::std::char_traits<char16_t>::char_type *find(const ::std::char_traits<char16_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char16_t>::char_type &__a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char16_t>::eq(__s[__i], __a))
              {
                return __s + __i;
              }
          }
        return 0;
      }
      static inline ::std::char_traits<char16_t>::char_type *move(::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char16_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(::std::char_traits<char16_t>::char_type)));
      }
      static inline ::std::char_traits<char16_t>::char_type *copy(::std::char_traits<char16_t>::char_type *__s1, const ::std::char_traits<char16_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char16_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(::std::char_traits<char16_t>::char_type)));
      }
      static inline ::std::char_traits<char16_t>::char_type *assign(::std::char_traits<char16_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<char16_t>::char_type __a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            ::std::char_traits<char16_t>::assign(__s[__i], __a);
          }
        return __s;
      }
      static inline constexpr ::std::char_traits<char16_t>::char_type to_char_type(const ::std::char_traits<char16_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<char16_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type to_int_type(const ::std::char_traits<char16_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<char16_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char16_t>::int_type &__c1, const ::std::char_traits<char16_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char16_t>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char16_t>::int_type not_eof(const ::std::char_traits<char16_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<char16_t>::eq_int_type(__c, ::std::char_traits<char16_t>::eof()) ? 0 : __c;
      }
  };
  template <>
  struct  char_traits<char32_t>
  {
      typedef char32_t char_type;
      typedef ::uint_least32_t int_type;
      typedef ::std::streamoff off_type;
      typedef ::std::u32streampos pos_type;
      typedef ::mbstate_t state_type;
      static inline void assign(::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        __c1 = __c2;
      }
      static inline constexpr bool eq(const ::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr bool lt(const ::std::char_traits<char32_t>::char_type &__c1, const ::std::char_traits<char32_t>::char_type &__c2) noexcept(true)
      {
        return __c1 < __c2;
      }
      static inline int compare(const ::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char32_t>::lt(__s1[__i], __s2[__i]))
              {
                return  -1;
              }
            else
              {
                if (::std::char_traits<char32_t>::lt(__s2[__i], __s1[__i]))
                  {
                    return 1;
                  }
              }
          }
        return 0;
      }
      static inline ::std::size_t length(const ::std::char_traits<char32_t>::char_type *__s)
      {
        ::std::size_t __i(0);
        while (!::std::char_traits<char32_t>::eq(__s[__i], ::std::char_traits<char32_t>::char_type()))
          {
             ++__i;
          }
        return __i;
      }
      static inline const ::std::char_traits<char32_t>::char_type *find(const ::std::char_traits<char32_t>::char_type *__s, ::std::size_t __n, const ::std::char_traits<char32_t>::char_type &__a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            if (::std::char_traits<char32_t>::eq(__s[__i], __a))
              {
                return __s + __i;
              }
          }
        return 0;
      }
      static inline ::std::char_traits<char32_t>::char_type *move(::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char32_t>::char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(::std::char_traits<char32_t>::char_type)));
      }
      static inline ::std::char_traits<char32_t>::char_type *copy(::std::char_traits<char32_t>::char_type *__s1, const ::std::char_traits<char32_t>::char_type *__s2, ::std::size_t __n)
      {
        if (__n == 0)
          {
            return __s1;
          }
        return static_cast< ::std::char_traits<char32_t>::char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(::std::char_traits<char32_t>::char_type)));
      }
      static inline ::std::char_traits<char32_t>::char_type *assign(::std::char_traits<char32_t>::char_type *__s, ::std::size_t __n, ::std::char_traits<char32_t>::char_type __a)
      {
        for (::std::size_t __i(0); __i < __n;  ++__i)
          {
            ::std::char_traits<char32_t>::assign(__s[__i], __a);
          }
        return __s;
      }
      static inline constexpr ::std::char_traits<char32_t>::char_type to_char_type(const ::std::char_traits<char32_t>::int_type &__c) noexcept(true)
      {
        return (::std::char_traits<char32_t>::char_type)__c;
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type to_int_type(const ::std::char_traits<char32_t>::char_type &__c) noexcept(true)
      {
        return (::std::char_traits<char32_t>::int_type)__c;
      }
      static inline constexpr bool eq_int_type(const ::std::char_traits<char32_t>::int_type &__c1, const ::std::char_traits<char32_t>::int_type &__c2) noexcept(true)
      {
        return __c1 == __c2;
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type eof() noexcept(true)
      {
        return static_cast< ::std::char_traits<char32_t>::int_type>( -1);
      }
      static inline constexpr ::std::char_traits<char32_t>::int_type not_eof(const ::std::char_traits<char32_t>::int_type &__c) noexcept(true)
      {
        return ::std::char_traits<char32_t>::eq_int_type(__c, ::std::char_traits<char32_t>::eof()) ? 0 : __c;
      }
  };
}
struct  lconv
{
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    char int_p_cs_precedes;
    char int_p_sep_by_space;
    char int_n_cs_precedes;
    char int_n_sep_by_space;
    char int_p_sign_posn;
    char int_n_sign_posn;
};
extern "C"
{
  extern char *setlocale(int __category, const char *__locale) throw();
}
extern "C"
{
  extern ::lconv *localeconv() throw();
}
extern "C"
{
  extern ::__locale_t newlocale(int __category_mask, const char *__locale, ::__locale_t __base) throw();
}
extern "C"
{
  extern ::__locale_t duplocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern void freelocale(::__locale_t __dataset) throw();
}
extern "C"
{
  extern ::__locale_t uselocale(::__locale_t __dataset) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
extern "C"
  {
    ::__locale_t __uselocale(::__locale_t) throw();
  }
}
namespace std __attribute__((__visibility__("default"))) {
  typedef ::__locale_t __c_locale;
  inline int __convert_from_v(const ::std::__c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt, ...)
  {
    ::std::__c_locale __old(__gnu_cxx::__uselocale(__cloc));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __ret(__builtin_vsnprintf(__out, __size, __fmt, __args));
    __builtin_va_end(__args);
    __gnu_cxx::__uselocale(__old);
    return __ret;
  }
}
extern "C"
{
  static inline unsigned int __bswap_32(unsigned int __bsx)
  {
    return __builtin_bswap32(__bsx);
  }
}
extern "C"
{
  static inline ::__uint64_t __bswap_64(::__uint64_t __bsx)
  {
    return __builtin_bswap64(__bsx);
  }
}
enum mcc_enum_anon_54
{
  _ISupper = 0 < 8 ? 1 << 0 << 8 : 1 << 0 >> 8,
  _ISlower = 1 < 8 ? 1 << 1 << 8 : 1 << 1 >> 8,
  _ISalpha = 2 < 8 ? 1 << 2 << 8 : 1 << 2 >> 8,
  _ISdigit = 3 < 8 ? 1 << 3 << 8 : 1 << 3 >> 8,
  _ISxdigit = 4 < 8 ? 1 << 4 << 8 : 1 << 4 >> 8,
  _ISspace = 5 < 8 ? 1 << 5 << 8 : 1 << 5 >> 8,
  _ISprint = 6 < 8 ? 1 << 6 << 8 : 1 << 6 >> 8,
  _ISgraph = 7 < 8 ? 1 << 7 << 8 : 1 << 7 >> 8,
  _ISblank = 8 < 8 ? 1 << 8 << 8 : 1 << 8 >> 8,
  _IScntrl = 9 < 8 ? 1 << 9 << 8 : 1 << 9 >> 8,
  _ISpunct = 10 < 8 ? 1 << 10 << 8 : 1 << 10 >> 8,
  _ISalnum = 11 < 8 ? 1 << 11 << 8 : 1 << 11 >> 8
};
extern "C"
{
  extern const unsigned short int **__ctype_b_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_tolower_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern const ::__int32_t **__ctype_toupper_loc() throw() __attribute__((__const__));
}
extern "C"
{
  extern int isalnum(int) throw();
}
extern "C"
{
  extern int isalpha(int) throw();
}
extern "C"
{
  extern int iscntrl(int) throw();
}
extern "C"
{
  extern int isdigit(int) throw();
}
extern "C"
{
  extern int islower(int) throw();
}
extern "C"
{
  extern int isgraph(int) throw();
}
extern "C"
{
  extern int isprint(int) throw();
}
extern "C"
{
  extern int ispunct(int) throw();
}
extern "C"
{
  extern int isspace(int) throw();
}
extern "C"
{
  extern int isupper(int) throw();
}
extern "C"
{
  extern int isxdigit(int) throw();
}
extern "C"
{
  extern int tolower(int __c) throw();
}
extern "C"
{
  extern int toupper(int __c) throw();
}
extern "C"
{
  extern int isblank(int) throw();
}
extern "C"
{
  extern int isctype(int __c, int __mask) throw();
}
extern "C"
{
  extern int isascii(int __c) throw();
}
extern "C"
{
  extern int toascii(int __c) throw();
}
extern "C"
{
  extern int _toupper(int) throw();
}
extern "C"
{
  extern int _tolower(int) throw();
}
extern "C"
{
  extern int isalnum_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isalpha_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int iscntrl_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int islower_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isgraph_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isprint_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int ispunct_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isspace_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isupper_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isxdigit_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int isblank_l(int, ::__locale_t) throw();
}
extern "C"
{
  extern int __tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int tolower_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int __toupper_l(int __c, ::__locale_t __l) throw();
}
extern "C"
{
  extern int toupper_l(int __c, ::__locale_t __l) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
  using ::isblank;
  class locale;
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw();
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline bool isblank(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc);
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc);
  struct ctype_base;
  template < typename _CharT >
  class ctype;
  template <>
  class ctype<char>;
  template <>
  class ctype<wchar_t>;
  template < typename _CharT >
  class ctype_byname;
  class codecvt_base;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt;
  template <>
  class codecvt<char, char, ::__mbstate_t>;
  template <>
  class codecvt<wchar_t, char, ::__mbstate_t>;
  template < typename _InternT, typename _ExternT, typename _StateT >
  class codecvt_byname;
  template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
  class num_get;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class num_put;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class numpunct;
    template < typename _CharT >
    class numpunct_byname;
    template < typename _CharT >
    class collate;
    template < typename _CharT >
    class collate_byname;
  }
  class time_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class time_get;
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class time_get_byname;
  }
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put;
  template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
  class time_put_byname;
  class money_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _InIter = ::std::istreambuf_iterator<_CharT> >
    class money_get;
    template < typename _CharT, typename _OutIter = ::std::ostreambuf_iterator<_CharT> >
    class money_put;
    template < typename _CharT, bool _Intl = false >
    class moneypunct;
    template < typename _CharT, bool _Intl = false >
    class moneypunct_byname;
  }
  class messages_base;
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class messages;
    template < typename _CharT >
    class messages_byname;
  }
}
#pragma GCC visibility push(default)
typedef ::__time_t time_t;
struct  timespec
{
    ::__time_t tv_sec;
    ::__syscall_slong_t tv_nsec;
};
typedef ::__pid_t pid_t;
struct  sched_param
{
    int __sched_priority;
};
extern "C"
{
  extern int clone(int (*__fn)(void *), void *__child_stack, int __flags, void *__arg, ...) throw();
}
extern "C"
{
  extern int unshare(int __flags) throw();
}
extern "C"
{
  extern int sched_getcpu() throw();
}
extern "C"
{
  extern int setns(int __fd, int __nstype) throw();
}
struct  __sched_param
{
    int __sched_priority;
};
typedef unsigned long int __cpu_mask;
struct  cpu_set_t
{
    ::__cpu_mask __bits[16L];
};
extern "C"
{
  extern int __sched_cpucount(::size_t __setsize, const ::cpu_set_t *__setp) throw();
}
extern "C"
{
  extern ::cpu_set_t *__sched_cpualloc(::size_t __count) throw();
}
extern "C"
{
  extern void __sched_cpufree(::cpu_set_t *__set) throw();
}
extern "C"
{
  extern int sched_setparam(::__pid_t __pid, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getparam(::__pid_t __pid, ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_setscheduler(::__pid_t __pid, int __policy, const ::sched_param *__param) throw();
}
extern "C"
{
  extern int sched_getscheduler(::__pid_t __pid) throw();
}
extern "C"
{
  extern int sched_yield() throw();
}
extern "C"
{
  extern int sched_get_priority_max(int __algorithm) throw();
}
extern "C"
{
  extern int sched_get_priority_min(int __algorithm) throw();
}
extern "C"
{
  extern int sched_rr_get_interval(::__pid_t __pid, ::timespec *__t) throw();
}
extern "C"
{
  extern int sched_setaffinity(::__pid_t __pid, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw();
}
extern "C"
{
  extern int sched_getaffinity(::__pid_t __pid, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw();
}
struct  timeval
{
    ::__time_t tv_sec;
    ::__suseconds_t tv_usec;
};
struct  timex
{
    unsigned int modes;
    ::__syscall_slong_t offset;
    ::__syscall_slong_t freq;
    ::__syscall_slong_t maxerror;
    ::__syscall_slong_t esterror;
    int status;
    ::__syscall_slong_t constant;
    ::__syscall_slong_t precision;
    ::__syscall_slong_t tolerance;
    ::timeval time;
    ::__syscall_slong_t tick;
    ::__syscall_slong_t ppsfreq;
    ::__syscall_slong_t jitter;
    int shift;
    ::__syscall_slong_t stabil;
    ::__syscall_slong_t jitcnt;
    ::__syscall_slong_t calcnt;
    ::__syscall_slong_t errcnt;
    ::__syscall_slong_t stbcnt;
    int tai;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
    int:32;
};
extern "C"
{
  extern int clock_adjtime(::__clockid_t __clock_id, ::timex *__utx) throw();
}
typedef ::__clock_t clock_t;
typedef ::__clockid_t clockid_t;
typedef ::__timer_t timer_t;
struct  tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
    long int tm_gmtoff;
    const char *tm_zone;
};
struct  itimerspec
{
    ::timespec it_interval;
    ::timespec it_value;
};
struct sigevent;
extern "C"
{
  extern ::clock_t clock() throw();
}
extern "C"
{
  extern ::time_t time(::time_t *__timer) throw();
}
extern "C"
{
  extern double difftime(::time_t __time1, ::time_t __time0) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::time_t mktime(::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *strptime(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp) throw();
}
extern "C"
{
  extern ::size_t strftime_l(char *__restrict __s, ::size_t __maxsize, const char *__restrict __format, const ::tm *__restrict __tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern char *strptime_l(const char *__restrict __s, const char *__restrict __fmt, ::tm *__tp, ::__locale_t __loc) throw();
}
extern "C"
{
  extern ::tm *gmtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *localtime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern ::tm *gmtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern ::tm *localtime_r(const ::time_t *__restrict __timer, ::tm *__restrict __tp) throw();
}
extern "C"
{
  extern char *asctime(const ::tm *__tp) throw();
}
extern "C"
{
  extern char *ctime(const ::time_t *__timer) throw();
}
extern "C"
{
  extern char *asctime_r(const ::tm *__restrict __tp, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *ctime_r(const ::time_t *__restrict __timer, char *__restrict __buf) throw();
}
extern "C"
{
  extern char *__tzname[2L];
}
extern "C"
{
  extern int __daylight;
}
extern "C"
{
  extern long int __timezone;
}
extern "C"
{
  extern char *tzname[2L];
}
extern "C"
{
  extern void tzset() throw();
}
extern "C"
{
  extern int daylight;
}
extern "C"
{
  extern long int timezone;
}
extern "C"
{
  extern int stime(const ::time_t *__when) throw();
}
extern "C"
{
  extern ::time_t timegm(::tm *__tp) throw();
}
extern "C"
{
  extern ::time_t timelocal(::tm *__tp) throw();
}
extern "C"
{
  extern int dysize(int __year) throw() __attribute__((__const__));
}
extern "C"
{
  extern int nanosleep(const ::timespec *__requested_time, ::timespec *__remaining);
}
extern "C"
{
  extern int clock_getres(::clockid_t __clock_id, ::timespec *__res) throw();
}
extern "C"
{
  extern int clock_gettime(::clockid_t __clock_id, ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_settime(::clockid_t __clock_id, const ::timespec *__tp) throw();
}
extern "C"
{
  extern int clock_nanosleep(::clockid_t __clock_id, int __flags, const ::timespec *__req, ::timespec *__rem);
}
extern "C"
{
  extern int clock_getcpuclockid(::pid_t __pid, ::clockid_t *__clock_id) throw();
}
extern "C"
{
  extern int timer_create(::clockid_t __clock_id, ::sigevent *__restrict __evp, ::timer_t *__restrict __timerid) throw();
}
extern "C"
{
  extern int timer_delete(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timer_settime(::timer_t __timerid, int __flags, const ::itimerspec *__restrict __value, ::itimerspec *__restrict __ovalue) throw();
}
extern "C"
{
  extern int timer_gettime(::timer_t __timerid, ::itimerspec *__value) throw();
}
extern "C"
{
  extern int timer_getoverrun(::timer_t __timerid) throw();
}
extern "C"
{
  extern int timespec_get(::timespec *__ts, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getdate_err;
}
extern "C"
{
  extern ::tm *getdate(const char *__string);
}
extern "C"
{
  extern int getdate_r(const char *__restrict __string, ::tm *__restrict __resbufp);
}
typedef unsigned long int pthread_t;
union  pthread_attr_t
{
    char __size[64L];
    long int __align;
};
struct __pthread_internal_list;
struct  __pthread_internal_list
{
    ::__pthread_internal_list *__prev;
    ::__pthread_internal_list *__next;
};
typedef ::__pthread_internal_list __pthread_list_t;
union  pthread_mutex_t
{
    struct  __pthread_mutex_s
    {
        int __lock;
        unsigned int __count;
        int __owner;
        unsigned int __nusers;
        int __kind;
        int __spins;
        ::__pthread_list_t __list;
    };
    ::pthread_mutex_t::__pthread_mutex_s __data;
    char __size[48L];
    long int __align;
};
union  pthread_mutexattr_t
{
    char __size[8L];
    long int __align;
};
union  pthread_cond_t
{
    struct  mcc_struct_anon_74
    {
        int __lock;
        unsigned int __futex;
        __extension__ unsigned long long int __total_seq;
        __extension__ unsigned long long int __wakeup_seq;
        __extension__ unsigned long long int __woken_seq;
        void *__mutex;
        unsigned int __nwaiters;
        unsigned int __broadcast_seq;
    };
    ::pthread_cond_t::mcc_struct_anon_74 __data;
    char __size[48L];
    long int __align;
};
union  pthread_condattr_t
{
    char __size[8L];
    int __align;
};
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
union  pthread_rwlock_t
{
    struct  mcc_struct_anon_77
    {
        int __lock;
        unsigned int __nr_readers;
        unsigned int __readers_wakeup;
        unsigned int __writer_wakeup;
        unsigned int __nr_readers_queued;
        unsigned int __nr_writers_queued;
        int __writer;
        int __shared;
        unsigned long int __pad1;
        unsigned long int __pad2;
        unsigned int __flags;
    };
    ::pthread_rwlock_t::mcc_struct_anon_77 __data;
    char __size[56L];
    long int __align;
};
union  pthread_rwlockattr_t
{
    char __size[8L];
    long int __align;
};
typedef volatile int pthread_spinlock_t;
union  pthread_barrier_t
{
    char __size[32L];
    long int __align;
};
union  pthread_barrierattr_t
{
    char __size[8L];
    int __align;
};
__extension__ typedef unsigned long long int __jmp_buf[22L];
enum mcc_enum_anon_55
{
  PTHREAD_CREATE_JOINABLE = 0,
  PTHREAD_CREATE_DETACHED = 1
};
enum mcc_enum_anon_56
{
  PTHREAD_MUTEX_TIMED_NP = 0,
  PTHREAD_MUTEX_RECURSIVE_NP = 1,
  PTHREAD_MUTEX_ERRORCHECK_NP = 2,
  PTHREAD_MUTEX_ADAPTIVE_NP = 3,
  PTHREAD_MUTEX_NORMAL = ::PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = ::PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = ::PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = ::PTHREAD_MUTEX_NORMAL,
  PTHREAD_MUTEX_FAST_NP = ::PTHREAD_MUTEX_TIMED_NP
};
enum mcc_enum_anon_57
{
  PTHREAD_MUTEX_STALLED = 0,
  PTHREAD_MUTEX_STALLED_NP = ::PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST = 1,
  PTHREAD_MUTEX_ROBUST_NP = ::PTHREAD_MUTEX_ROBUST
};
enum mcc_enum_anon_58
{
  PTHREAD_PRIO_NONE = 0,
  PTHREAD_PRIO_INHERIT = 1,
  PTHREAD_PRIO_PROTECT = 2
};
enum mcc_enum_anon_59
{
  PTHREAD_RWLOCK_PREFER_READER_NP = 0,
  PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
  PTHREAD_RWLOCK_DEFAULT_NP = ::PTHREAD_RWLOCK_PREFER_READER_NP
};
enum mcc_enum_anon_60
{
  PTHREAD_INHERIT_SCHED = 0,
  PTHREAD_EXPLICIT_SCHED = 1
};
enum mcc_enum_anon_61
{
  PTHREAD_SCOPE_SYSTEM = 0,
  PTHREAD_SCOPE_PROCESS = 1
};
enum mcc_enum_anon_62
{
  PTHREAD_PROCESS_PRIVATE = 0,
  PTHREAD_PROCESS_SHARED = 1
};
struct _pthread_cleanup_buffer;
struct  _pthread_cleanup_buffer
{
    void (*__routine)(void *);
    void *__arg;
    int __canceltype;
    ::_pthread_cleanup_buffer *__prev;
};
enum mcc_enum_anon_63
{
  PTHREAD_CANCEL_ENABLE = 0,
  PTHREAD_CANCEL_DISABLE = 1
};
enum mcc_enum_anon_64
{
  PTHREAD_CANCEL_DEFERRED = 0,
  PTHREAD_CANCEL_ASYNCHRONOUS = 1
};
extern "C"
{
  extern int pthread_create(::pthread_t *__restrict __newthread, const ::pthread_attr_t *__restrict __attr, void *(*__start_routine)(void *), void *__restrict __arg) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern void pthread_exit(void *__retval) __attribute__((__noreturn__));
}
extern "C"
{
  extern int pthread_join(::pthread_t __th, void **__thread_return);
}
extern "C"
{
  extern int pthread_tryjoin_np(::pthread_t __th, void **__thread_return) throw();
}
extern "C"
{
  extern int pthread_timedjoin_np(::pthread_t __th, void **__thread_return, const ::timespec *__abstime);
}
extern "C"
{
  extern int pthread_detach(::pthread_t __th) throw();
}
extern "C"
{
  extern ::pthread_t pthread_self() throw() __attribute__((__const__));
}
extern "C"
{
  extern inline int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern int pthread_attr_init(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_destroy(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getdetachstate(const ::pthread_attr_t *__attr, int *__detachstate) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setdetachstate(::pthread_attr_t *__attr, int __detachstate) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getguardsize(const ::pthread_attr_t *__attr, ::size_t *__guardsize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setguardsize(::pthread_attr_t *__attr, ::size_t __guardsize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getschedparam(const ::pthread_attr_t *__restrict __attr, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedparam(::pthread_attr_t *__restrict __attr, const ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_getschedpolicy(const ::pthread_attr_t *__restrict __attr, int *__restrict __policy) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setschedpolicy(::pthread_attr_t *__attr, int __policy) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getinheritsched(const ::pthread_attr_t *__restrict __attr, int *__restrict __inherit) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setinheritsched(::pthread_attr_t *__attr, int __inherit) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getscope(const ::pthread_attr_t *__restrict __attr, int *__restrict __scope) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setscope(::pthread_attr_t *__attr, int __scope) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstackaddr(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr) throw() __attribute__((__nonnull__(1, 2))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_setstackaddr(::pthread_attr_t *__attr, void *__stackaddr) throw() __attribute__((__nonnull__(1))) __attribute__((__deprecated__));
}
extern "C"
{
  extern int pthread_attr_getstacksize(const ::pthread_attr_t *__restrict __attr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_attr_setstacksize(::pthread_attr_t *__attr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_getstack(const ::pthread_attr_t *__restrict __attr, void **__restrict __stackaddr, ::size_t *__restrict __stacksize) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_attr_setstack(::pthread_attr_t *__attr, void *__stackaddr, ::size_t __stacksize) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_attr_setaffinity_np(::pthread_attr_t *__attr, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_attr_getaffinity_np(const ::pthread_attr_t *__attr, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_getattr_default_np(::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_setattr_default_np(const ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_getattr_np(::pthread_t __th, ::pthread_attr_t *__attr) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setschedparam(::pthread_t __target_thread, int __policy, const ::sched_param *__param) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getschedparam(::pthread_t __target_thread, int *__restrict __policy, ::sched_param *__restrict __param) throw() __attribute__((__nonnull__(2, 3)));
}
extern "C"
{
  extern int pthread_setschedprio(::pthread_t __target_thread, int __prio) throw();
}
extern "C"
{
  extern int pthread_getname_np(::pthread_t __target_thread, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_setname_np(::pthread_t __target_thread, const char *__name) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_getconcurrency() throw();
}
extern "C"
{
  extern int pthread_setconcurrency(int __level) throw();
}
extern "C"
{
  extern int pthread_yield() throw();
}
extern "C"
{
  extern int pthread_setaffinity_np(::pthread_t __th, ::size_t __cpusetsize, const ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_getaffinity_np(::pthread_t __th, ::size_t __cpusetsize, ::cpu_set_t *__cpuset) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int pthread_once(::pthread_once_t *__once_control, void (*__init_routine)()) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_setcancelstate(int __state, int *__oldstate);
}
extern "C"
{
  extern int pthread_setcanceltype(int __type, int *__oldtype);
}
extern "C"
{
  extern int pthread_cancel(::pthread_t __th);
}
extern "C"
{
  extern void pthread_testcancel();
}
struct __attribute__((__aligned__))  __pthread_unwind_buf_t
{
    struct  mcc_struct_anon_82
    {
        ::__jmp_buf __cancel_jmp_buf;
        int __mask_was_saved;
    };
    ::__pthread_unwind_buf_t::mcc_struct_anon_82 __cancel_jmp_buf[1L];
    void *__pad[4L];
};
struct  __pthread_cleanup_frame
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
};
class  __pthread_cleanup_class
{
    void (*__cancel_routine)(void *);
    void *__cancel_arg;
    int __do_it;
    int __cancel_type;
  public:
    inline __pthread_cleanup_class(void (*__fct)(void *), void *__arg)
      : __cancel_routine(__fct), __cancel_arg(__arg), __do_it(1)
    {
    }
    inline ~__pthread_cleanup_class()
    {
      if ((*this).__do_it)
        {
          (*this).__cancel_routine((*this).__cancel_arg);
        }
    }
    inline void __setdoit(int __newval)
    {
      (*this).__do_it = __newval;
    }
    inline void __defer()
    {
      ::pthread_setcanceltype(::PTHREAD_CANCEL_DEFERRED, &(*this).__cancel_type);
    }
    inline void __restore() const 
    {
      ::pthread_setcanceltype((*this).__cancel_type, 0);
    }
};
struct __jmp_buf_tag;
extern "C"
{
  extern int __sigsetjmp(::__jmp_buf_tag *__env, int __savemask) throw();
}
extern "C"
{
  extern int pthread_mutex_init(::pthread_mutex_t *__mutex, const ::pthread_mutexattr_t *__mutexattr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_destroy(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_trylock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_lock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_timedlock(::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_unlock(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_getprioceiling(const ::pthread_mutex_t *__restrict __mutex, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutex_setprioceiling(::pthread_mutex_t *__restrict __mutex, int __prioceiling, int *__restrict __old_ceiling) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern int pthread_mutex_consistent(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutex_consistent_np(::pthread_mutex_t *__mutex) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_init(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_destroy(::pthread_mutexattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getpshared(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setpshared(::pthread_mutexattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_gettype(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __kind) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_settype(::pthread_mutexattr_t *__attr, int __kind) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprotocol(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __protocol) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprotocol(::pthread_mutexattr_t *__attr, int __protocol) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getprioceiling(const ::pthread_mutexattr_t *__restrict __attr, int *__restrict __prioceiling) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setprioceiling(::pthread_mutexattr_t *__attr, int __prioceiling) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_getrobust_np(const ::pthread_mutexattr_t *__attr, int *__robustness) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_mutexattr_setrobust_np(::pthread_mutexattr_t *__attr, int __robustness) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_init(::pthread_rwlock_t *__restrict __rwlock, const ::pthread_rwlockattr_t *__restrict __attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_destroy(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_rdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_tryrdlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedrdlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_wrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_trywrlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlock_timedwrlock(::pthread_rwlock_t *__restrict __rwlock, const ::timespec *__restrict __abstime) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlock_unlock(::pthread_rwlock_t *__rwlock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_init(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_destroy(::pthread_rwlockattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getpshared(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setpshared(::pthread_rwlockattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_rwlockattr_getkind_np(const ::pthread_rwlockattr_t *__restrict __attr, int *__restrict __pref) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_rwlockattr_setkind_np(::pthread_rwlockattr_t *__attr, int __pref) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_init(::pthread_cond_t *__restrict __cond, const ::pthread_condattr_t *__restrict __cond_attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_destroy(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_signal(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_broadcast(::pthread_cond_t *__cond) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_cond_wait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex) __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_cond_timedwait(::pthread_cond_t *__restrict __cond, ::pthread_mutex_t *__restrict __mutex, const ::timespec *__restrict __abstime) __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern int pthread_condattr_init(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_destroy(::pthread_condattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getpshared(const ::pthread_condattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setpshared(::pthread_condattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_condattr_getclock(const ::pthread_condattr_t *__restrict __attr, ::__clockid_t *__restrict __clock_id) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_condattr_setclock(::pthread_condattr_t *__attr, ::__clockid_t __clock_id) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_init(::pthread_spinlock_t *__lock, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_destroy(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_lock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_trylock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_spin_unlock(::pthread_spinlock_t *__lock) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_init(::pthread_barrier_t *__restrict __barrier, const ::pthread_barrierattr_t *__restrict __attr, unsigned int __count) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_destroy(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrier_wait(::pthread_barrier_t *__barrier) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_init(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_destroy(::pthread_barrierattr_t *__attr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_barrierattr_getpshared(const ::pthread_barrierattr_t *__restrict __attr, int *__restrict __pshared) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int pthread_barrierattr_setpshared(::pthread_barrierattr_t *__attr, int __pshared) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_create(::pthread_key_t *__key, void (*__destr_function)(void *)) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int pthread_key_delete(::pthread_key_t __key) throw();
}
extern "C"
{
  extern void *pthread_getspecific(::pthread_key_t __key) throw();
}
extern "C"
{
  extern int pthread_setspecific(::pthread_key_t __key, const void *__pointer) throw();
}
extern "C"
{
  extern int pthread_getcpuclockid(::pthread_t __thread_id, ::__clockid_t *__clock_id) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int pthread_atfork(void (*__prepare)(), void (*__parent)(), void (*__child)()) throw();
}
extern "C"
{
  extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int pthread_equal(::pthread_t __thread1, ::pthread_t __thread2) throw()
  {
    return __thread1 == __thread2;
  }
}
typedef ::pthread_t __gthread_t;
typedef ::pthread_key_t __gthread_key_t;
typedef ::pthread_once_t __gthread_once_t;
typedef ::pthread_mutex_t __gthread_mutex_t;
typedef ::pthread_mutex_t __gthread_recursive_mutex_t;
typedef ::pthread_cond_t __gthread_cond_t;
typedef ::timespec __gthread_time_t;
static int __gthrw_pthread_once(::pthread_once_t *, void (*)()) throw() __attribute__((__weakref__("pthread_once")));
static void *__gthrw_pthread_getspecific(::pthread_key_t) throw() __attribute__((__weakref__("pthread_getspecific")));
static int __gthrw_pthread_setspecific(::pthread_key_t, const void *) throw() __attribute__((__weakref__("pthread_setspecific")));
static int __gthrw_pthread_create(::pthread_t *__restrict , const ::pthread_attr_t *__restrict , void *(*)(void *), void *__restrict ) throw() __attribute__((__weakref__("pthread_create")));
static int __gthrw_pthread_join(::pthread_t, void **) throw() __attribute__((__weakref__("pthread_join")));
static int __gthrw_pthread_equal(::pthread_t, ::pthread_t) throw() __attribute__((__weakref__("pthread_equal")));
static ::pthread_t __gthrw_pthread_self() throw() __attribute__((__weakref__("pthread_self")));
static int __gthrw_pthread_detach(::pthread_t) throw() __attribute__((__weakref__("pthread_detach")));
static int __gthrw_pthread_cancel(::pthread_t) throw() __attribute__((__weakref__("pthread_cancel")));
static int __gthrw_sched_yield() throw() __attribute__((__weakref__("sched_yield")));
static int __gthrw_pthread_mutex_lock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_lock")));
static int __gthrw_pthread_mutex_trylock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_trylock")));
static int __gthrw_pthread_mutex_timedlock(::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_mutex_timedlock")));
static int __gthrw_pthread_mutex_unlock(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_unlock")));
static int __gthrw_pthread_mutex_init(::pthread_mutex_t *, const ::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutex_init")));
static int __gthrw_pthread_mutex_destroy(::pthread_mutex_t *) throw() __attribute__((__weakref__("pthread_mutex_destroy")));
static int __gthrw_pthread_cond_init(::pthread_cond_t *__restrict , const ::pthread_condattr_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_init")));
static int __gthrw_pthread_cond_broadcast(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_broadcast")));
static int __gthrw_pthread_cond_signal(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_signal")));
static int __gthrw_pthread_cond_wait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict ) throw() __attribute__((__weakref__("pthread_cond_wait")));
static int __gthrw_pthread_cond_timedwait(::pthread_cond_t *__restrict , ::pthread_mutex_t *__restrict , const ::timespec *__restrict ) throw() __attribute__((__weakref__("pthread_cond_timedwait")));
static int __gthrw_pthread_cond_destroy(::pthread_cond_t *) throw() __attribute__((__weakref__("pthread_cond_destroy")));
static int __gthrw_pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("pthread_key_create")));
static int __gthrw_pthread_key_delete(::pthread_key_t) throw() __attribute__((__weakref__("pthread_key_delete")));
static int __gthrw_pthread_mutexattr_init(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_init")));
static int __gthrw_pthread_mutexattr_settype(::pthread_mutexattr_t *, int) throw() __attribute__((__weakref__("pthread_mutexattr_settype")));
static int __gthrw_pthread_mutexattr_destroy(::pthread_mutexattr_t *) throw() __attribute__((__weakref__("pthread_mutexattr_destroy")));
static int __gthrw___pthread_key_create(::pthread_key_t *, void (*)(void *)) throw() __attribute__((__weakref__("__pthread_key_create")));
static inline int __gthread_active_p()
{
  static void *const __gthread_active_ptr((void *)::__gthrw___pthread_key_create);
  return __gthread_active_ptr != 0;
}
static inline int __gthread_create(::__gthread_t *__threadid, void *(*__func)(void *), void *__args)
{
  return ::__gthrw_pthread_create(__threadid, 0L, __func, __args);
}
static inline int __gthread_join(::__gthread_t __threadid, void **__value_ptr)
{
  return ::__gthrw_pthread_join(__threadid, __value_ptr);
}
static inline int __gthread_detach(::__gthread_t __threadid)
{
  return ::__gthrw_pthread_detach(__threadid);
}
static inline int __gthread_equal(::__gthread_t __t1, ::__gthread_t __t2)
{
  return ::__gthrw_pthread_equal(__t1, __t2);
}
static inline ::__gthread_t __gthread_self()
{
  return ::__gthrw_pthread_self();
}
static inline int __gthread_yield()
{
  return ::__gthrw_sched_yield();
}
static inline int __gthread_once(::__gthread_once_t *__once, void (*__func)())
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_once(__once, __func);
    }
  else
    {
      return  -1;
    }
}
static inline int __gthread_key_create(::__gthread_key_t *__key, void (*__dtor)(void *))
{
  return ::__gthrw_pthread_key_create(__key, __dtor);
}
static inline int __gthread_key_delete(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_key_delete(__key);
}
static inline void *__gthread_getspecific(::__gthread_key_t __key)
{
  return ::__gthrw_pthread_getspecific(__key);
}
static inline int __gthread_setspecific(::__gthread_key_t __key, const void *__ptr)
{
  return ::__gthrw_pthread_setspecific(__key, __ptr);
}
static inline void __gthread_mutex_init_function(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      ::__gthrw_pthread_mutex_init(__mutex, 0L);
    }
}
static inline int __gthread_mutex_destroy(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_destroy(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_lock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_lock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_trylock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_trylock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_timedlock(::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_timedlock(__mutex, __abs_timeout);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_mutex_unlock(::__gthread_mutex_t *__mutex)
{
  if (::__gthread_active_p())
    {
      return ::__gthrw_pthread_mutex_unlock(__mutex);
    }
  else
    {
      return 0;
    }
}
static inline int __gthread_recursive_mutex_lock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_lock(__mutex);
}
static inline int __gthread_recursive_mutex_trylock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_trylock(__mutex);
}
static inline int __gthread_recursive_mutex_timedlock(::__gthread_recursive_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthread_mutex_timedlock(__mutex, __abs_timeout);
}
static inline int __gthread_recursive_mutex_unlock(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_unlock(__mutex);
}
static inline int __gthread_recursive_mutex_destroy(::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_mutex_destroy(__mutex);
}
static inline int __gthread_cond_broadcast(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_broadcast(__cond);
}
static inline int __gthread_cond_signal(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_signal(__cond);
}
static inline int __gthread_cond_wait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex)
{
  return ::__gthrw_pthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_timedwait(::__gthread_cond_t *__cond, ::__gthread_mutex_t *__mutex, const ::__gthread_time_t *__abs_timeout)
{
  return ::__gthrw_pthread_cond_timedwait(__cond, __mutex, __abs_timeout);
}
static inline int __gthread_cond_wait_recursive(::__gthread_cond_t *__cond, ::__gthread_recursive_mutex_t *__mutex)
{
  return ::__gthread_cond_wait(__cond, __mutex);
}
static inline int __gthread_cond_destroy(::__gthread_cond_t *__cond)
{
  return ::__gthrw_pthread_cond_destroy(__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  static inline ::_Atomic_word __exchange_and_add(volatile ::_Atomic_word *__mem, int __val)
  {
    return __atomic_fetch_add(__mem, __val, 4);
  }
  static inline void __atomic_add(volatile ::_Atomic_word *__mem, int __val)
  {
    __atomic_fetch_add(__mem, __val, 4);
  }
  static inline ::_Atomic_word __exchange_and_add_single(::_Atomic_word *__mem, int __val)
  {
    ::_Atomic_word __result(*__mem);
    *__mem += __val;
    return __result;
  }
  static inline void __atomic_add_single(::_Atomic_word *__mem, int __val)
  {
    *__mem += __val;
  }
  static inline __attribute__((__unused__)) ::_Atomic_word __exchange_and_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        return ::__gnu_cxx::__exchange_and_add(__mem, __val);
      }
    else
      {
        return ::__gnu_cxx::__exchange_and_add_single(__mem, __val);
      }
  }
  static inline __attribute__((__unused__)) void __atomic_add_dispatch(::_Atomic_word *__mem, int __val)
  {
    if (::__gthread_active_p())
      {
        ::__gnu_cxx::__atomic_add(__mem, __val);
      }
    else
      {
        ::__gnu_cxx::__atomic_add_single(__mem, __val);
      }
  }
}
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  class  bad_alloc : public ::std::exception
  {
    public:
      inline bad_alloc() throw()
      {
      }
      virtual ~bad_alloc() throw();
      virtual const char *what() const  throw();
  };
  class  bad_array_new_length : public ::std::bad_alloc
  {
    public:
      inline bad_array_new_length() throw()
      {
      }
      virtual ~bad_array_new_length() throw();
      virtual const char *what() const  throw();
  };
  struct  nothrow_t
  {
  };
  extern const ::std::nothrow_t nothrow;
  typedef void (*new_handler)();
  ::std::new_handler set_new_handler(::std::new_handler) throw();
  ::std::new_handler get_new_handler() noexcept(true);
}
void *operator new(::std::size_t, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void *operator new[](::std::size_t, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void operator delete(void *, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
void operator delete[](void *, const ::std::nothrow_t &) noexcept(true) __attribute__((__externally_visible__));
inline void *operator new(::std::size_t, void *__p) noexcept(true)
{
  return __p;
}
inline void *operator new[](::std::size_t, void *__p) noexcept(true)
{
  return __p;
}
inline void operator delete(void *, void *) noexcept(true)
{
}
inline void operator delete[](void *, void *) noexcept(true)
{
}
#pragma GCC visibility pop
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::std::size_t;
  using ::std::ptrdiff_t;
  template < typename _Tp >
  class  new_allocator
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::__gnu_cxx::new_allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
      inline new_allocator() noexcept(true)
      {
      }
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp> &) noexcept(true)
      {
      }
      template < typename _Tp1 >
      inline new_allocator(const ::__gnu_cxx::new_allocator<_Tp1> &) noexcept(true)
      {
      }
      inline ~new_allocator() noexcept(true)
      {
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::reference __x) const  noexcept(true)
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::const_pointer address(typename ::__gnu_cxx::new_allocator<_Tp>::const_reference __x) const  noexcept(true)
      {
        return std::__addressof(__x);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::pointer allocate(typename ::__gnu_cxx::new_allocator<_Tp>::size_type __n, const void *  = (0))
      {
        if (__n > this->max_size())
          {
            std::__throw_bad_alloc();
          }
        return static_cast<_Tp *>(::operator new(__n * sizeof(_Tp)));
      }
      inline void deallocate(typename ::__gnu_cxx::new_allocator<_Tp>::pointer __p, typename ::__gnu_cxx::new_allocator<_Tp>::size_type)
      {
        ::operator delete(__p);
      }
      inline typename ::__gnu_cxx::new_allocator<_Tp>::size_type max_size() const  noexcept(true)
      {
        return (::std::size_t) -1 / sizeof(_Tp);
      }
      template < typename _Up, typename ..._Args >
      inline void construct(_Up *__p, _Args &&...__args)
      {
        ::new ((void *)__p)_Up(std::forward<_Args>(__args) ...);
      }
      template < typename _Up >
      inline void destroy(_Up *__p)
      {
        __p->~_Up();
      }
  };
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator ==(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &);
  template < typename _Tp >
  inline bool operator !=(const ::__gnu_cxx::new_allocator<_Tp> &, const ::__gnu_cxx::new_allocator<_Tp> &)
  {
    return false;
  }
}
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Tp >
  using __allocator_base = ::__gnu_cxx::new_allocator<_Tp>;
  template <>
  class  allocator<void>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef void *pointer;
      typedef const void *const_pointer;
      typedef void value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
  };
  template < typename _Tp >
  class  allocator : public ::std::__allocator_base<_Tp>
  {
    public:
      typedef ::std::size_t size_type;
      typedef ::std::ptrdiff_t difference_type;
      typedef _Tp *pointer;
      typedef const _Tp *const_pointer;
      typedef _Tp &reference;
      typedef const _Tp &const_reference;
      typedef _Tp value_type;
      template < typename _Tp1 >
      struct  rebind
      {
          typedef ::std::allocator<_Tp1> other;
      };
      typedef ::std::true_type propagate_on_container_move_assignment;
      inline allocator() throw()
      {
      }
      inline allocator(const ::std::allocator<_Tp> &__a) throw()
        : __allocator_base<_Tp>(__a)
      {
      }
      template < typename _Tp1 >
      inline allocator(const ::std::allocator<_Tp1> &) throw()
      {
      }
      inline ~allocator() throw()
      {
      }
  };
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) noexcept(true);
  template < typename _T1, typename _T2 >
  inline bool operator ==(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) noexcept(true)
  {
    return true;
  }
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) noexcept(true);
  template < typename _Tp >
  inline bool operator ==(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) noexcept(true)
  {
    return true;
  }
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) noexcept(true);
  template < typename _T1, typename _T2 >
  inline bool operator !=(const ::std::allocator<_T1> &, const ::std::allocator<_T2> &) noexcept(true)
  {
    return false;
  }
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) noexcept(true);
  template < typename _Tp >
  inline bool operator !=(const ::std::allocator<_Tp> &, const ::std::allocator<_Tp> &) noexcept(true)
  {
    return false;
  }
  extern template class ::std::allocator<char>;
  extern template class ::std::allocator<wchar_t>;
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_swap
  {
      static inline void _S_do_it(_Alloc &, _Alloc &) noexcept(true)
      {
      }
  };
  template < typename _Alloc >
  struct  __alloc_swap<_Alloc, false>
  {
      static inline void _S_do_it(_Alloc &__one, _Alloc &__two) noexcept(true)
      {
        if (__one != __two)
          {
            swap(__one, __two);
          }
      }
  };
  template < typename _Alloc, bool __nontype_tpl_param_1_1__ = __is_empty(_Alloc) >
  struct  __alloc_neq
  {
      static inline bool _S_do_it(const _Alloc &, const _Alloc &)
      {
        return false;
      }
  };
  template < typename _Alloc >
  struct  __alloc_neq<_Alloc, false>
  {
      static inline bool _S_do_it(const _Alloc &__one, const _Alloc &__two)
      {
        return __one != __two;
      }
  };
  template < typename _Tp, bool __nontype_tpl_param_1_1__ = __or_< ::std::is_copy_constructible<typename _Tp::value_type>, ::std::is_nothrow_move_constructible<typename _Tp::value_type> >::value >
  struct  __shrink_to_fit_aux
  {
      static inline bool _S_do_it(_Tp &) noexcept(true)
      {
        return false;
      }
  };
  template < typename _Tp >
  struct  __shrink_to_fit_aux<_Tp, true>
  {
      static inline bool _S_do_it(_Tp &__c) noexcept(true)
      {
        try
        {
          _Tp(__make_move_if_noexcept_iterator(__c.begin()), __make_move_if_noexcept_iterator(__c.end()), __c.get_allocator()).swap(__c);
          return true;
        }
        catch (...)
        {
          return false;
        }
      }
  };
}
#pragma GCC visibility push(default)
namespace __cxxabiv1 {
  class  __forced_unwind
  {
      virtual ~__forced_unwind() throw();
      virtual void __pure_dummy() = 0 ;
    public:
  };
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_write(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const ::std::streamsize __put = __out.rdbuf()->sputn(__s, __n);
    if (__put != __n)
      {
        __out.setstate(__ios_base::badbit);
      }
  }
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  inline void __ostream_fill(::std::basic_ostream<_CharT, _Traits> &__out, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    const _CharT __c = __out.fill();
    for (; __n > 0;  --__n)
      {
        const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
        if (_Traits::eq_int_type(__put, _Traits::eof()))
          {
            __out.setstate(__ios_base::badbit);
            break;
          }
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n);
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &__ostream_insert(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s, ::std::streamsize __n)
  {
    typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
    typedef typename ::std::basic_ostream<_CharT, _Traits>::ios_base __ios_base;
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(__out);
    if (__cerb)
      {
        try
        {
          const ::std::streamsize __w = __out.width();
          if (__w > __n)
            {
              const bool __left = (__out.flags() & __ios_base::adjustfield) == __ios_base::left;
              if (!__left)
                {
                  __ostream_fill(__out, __w - __n);
                }
              if (__out.good())
                {
                  __ostream_write(__out, __s, __n);
                }
              if (__left && __out.good())
                {
                  __ostream_fill(__out, __w - __n);
                }
            }
          else
            {
              __ostream_write(__out, __s, __n);
            }
          __out.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(__ios_base::badbit);
        }
      }
    return __out;
  }
  extern template ::std::basic_ostream<char> &__ostream_insert(::std::basic_ostream<char> &, const char *, long int);
  extern template ::std::basic_ostream<wchar_t> &__ostream_insert(::std::basic_ostream<wchar_t> &, const wchar_t *, long int);
  template < typename _Arg, typename _Result >
  struct  unary_function
  {
      typedef _Arg argument_type;
      typedef _Result result_type;
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  struct  binary_function
  {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
  };
  template < typename _Tp >
  struct  plus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x + __y;
      }
  };
  template < typename _Tp >
  struct  minus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x - __y;
      }
  };
  template < typename _Tp >
  struct  multiplies : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x * __y;
      }
  };
  template < typename _Tp >
  struct  divides : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x / __y;
      }
  };
  template < typename _Tp >
  struct  modulus : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x % __y;
      }
  };
  template < typename _Tp >
  struct  negate : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return  -__x;
      }
  };
  template < typename _Tp >
  struct  equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x == __y;
      }
  };
  template < typename _Tp >
  struct  not_equal_to : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x != __y;
      }
  };
  template < typename _Tp >
  struct  greater : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x > __y;
      }
  };
  template < typename _Tp >
  struct  less : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x < __y;
      }
  };
  template < typename _Tp >
  struct  greater_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x >= __y;
      }
  };
  template < typename _Tp >
  struct  less_equal : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x <= __y;
      }
  };
  template < typename _Tp >
  struct  logical_and : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x && __y;
      }
  };
  template < typename _Tp >
  struct  logical_or : ::std::binary_function<_Tp, _Tp, bool>
  {
      inline bool operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x || __y;
      }
  };
  template < typename _Tp >
  struct  logical_not : ::std::unary_function<_Tp, bool>
  {
      inline bool operator ()(const _Tp &__x) const 
      {
        return !__x;
      }
  };
  template < typename _Tp >
  struct  bit_and : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x & __y;
      }
  };
  template < typename _Tp >
  struct  bit_or : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x | __y;
      }
  };
  template < typename _Tp >
  struct  bit_xor : ::std::binary_function<_Tp, _Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x, const _Tp &__y) const 
      {
        return __x ^ __y;
      }
  };
  template < typename _Tp >
  struct  bit_not : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp operator ()(const _Tp &__x) const 
      {
        return ~__x;
      }
  };
  template < typename _Predicate >
  class  unary_negate : public ::std::unary_function<typename _Predicate::argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit unary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::argument_type &__x) const 
      {
        return !::std::unary_negate<_Predicate>::_M_pred(__x);
      }
  };
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::unary_negate<_Predicate> not1(const _Predicate &__pred)
  {
    return ::std::unary_negate<_Predicate>(__pred);
  }
  template < typename _Predicate >
  class  binary_negate : public ::std::binary_function<typename _Predicate::first_argument_type, typename _Predicate::second_argument_type, bool>
  {
    protected:
      _Predicate _M_pred;
    public:
      inline explicit binary_negate(const _Predicate &__x)
        : _M_pred(__x)
      {
      }
      inline bool operator ()(const typename _Predicate::first_argument_type &__x, const typename _Predicate::second_argument_type &__y) const 
      {
        return !::std::binary_negate<_Predicate>::_M_pred(__x, __y);
      }
  };
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred);
  template < typename _Predicate >
  inline ::std::binary_negate<_Predicate> not2(const _Predicate &__pred)
  {
    return ::std::binary_negate<_Predicate>(__pred);
  }
  template < typename _Arg, typename _Result >
  class  pointer_to_unary_function : public ::std::unary_function<_Arg, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      inline pointer_to_unary_function()
      {
      }
      inline explicit pointer_to_unary_function(_Result (*__x)(_Arg))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg __x) const 
      {
        return ::std::pointer_to_unary_function<_Arg, _Result>::_M_ptr(__x);
      }
  };
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg));
  template < typename _Arg, typename _Result >
  inline ::std::pointer_to_unary_function<_Arg, _Result> ptr_fun(_Result (*__x)(_Arg))
  {
    return ::std::pointer_to_unary_function<_Arg, _Result>(__x);
  }
  template < typename _Arg1, typename _Arg2, typename _Result >
  class  pointer_to_binary_function : public ::std::binary_function<_Arg1, _Arg2, _Result>
  {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      inline pointer_to_binary_function()
      {
      }
      inline explicit pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
        : _M_ptr(__x)
      {
      }
      inline _Result operator ()(_Arg1 __x, _Arg2 __y) const 
      {
        return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>::_M_ptr(__x, __y);
      }
  };
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2));
  template < typename _Arg1, typename _Arg2, typename _Result >
  inline ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result> ptr_fun(_Result (*__x)(_Arg1, _Arg2))
  {
    return ::std::pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x);
  }
  template < typename _Tp >
  struct  _Identity : ::std::unary_function<_Tp, _Tp>
  {
      inline _Tp &operator ()(_Tp &__x) const 
      {
        return __x;
      }
      inline const _Tp &operator ()(const _Tp &__x) const 
      {
        return __x;
      }
  };
  template < typename _Pair >
  struct  _Select1st : ::std::unary_function<_Pair, typename _Pair::first_type>
  {
      inline typename _Pair::first_type &operator ()(_Pair &__x) const 
      {
        return __x.first;
      }
      inline const typename _Pair::first_type &operator ()(const _Pair &__x) const 
      {
        return __x.first;
      }
      template < typename _Pair2 >
      inline typename _Pair2::first_type &operator ()(_Pair2 &__x) const 
      {
        return __x.first;
      }
      template < typename _Pair2 >
      inline const typename _Pair2::first_type &operator ()(const _Pair2 &__x) const 
      {
        return __x.first;
      }
  };
  template < typename _Pair >
  struct  _Select2nd : ::std::unary_function<_Pair, typename _Pair::second_type>
  {
      inline typename _Pair::second_type &operator ()(_Pair &__x) const 
      {
        return __x.second;
      }
      inline const typename _Pair::second_type &operator ()(const _Pair &__x) const 
      {
        return __x.second;
      }
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_t : public ::std::unary_function<_Tp *, _Ret>
  {
    public:
      inline explicit mem_fun_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p) const 
      {
        return (__p->*::std::mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_t : public ::std::unary_function<const _Tp *, _Ret>
  {
    public:
      inline explicit const_mem_fun_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p) const 
      {
        return (__p->*::std::const_mem_fun_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp >
  class  mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit mem_fun_ref_t(_Ret (_Tp::*__pf)())
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r) const 
      {
        return (__r.*::std::mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template < typename _Ret, typename _Tp >
  class  const_mem_fun_ref_t : public ::std::unary_function<_Tp, _Ret>
  {
    public:
      inline explicit const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r) const 
      {
        return (__r.*::std::const_mem_fun_ref_t<_Ret, _Tp>::_M_f)();
      }
    private:
      _Ret (_Tp::*_M_f)() const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_t : public ::std::binary_function<_Tp *, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_t : public ::std::binary_function<const _Tp *, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp *__p, _Arg __x) const 
      {
        return (__p->*::std::const_mem_fun1_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(_Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
  };
  template < typename _Ret, typename _Tp, typename _Arg >
  class  const_mem_fun1_ref_t : public ::std::binary_function<_Tp, _Arg, _Ret>
  {
    public:
      inline explicit const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const )
        : _M_f(__pf)
      {
      }
      inline _Ret operator ()(const _Tp &__r, _Arg __x) const 
      {
        return (__r.*::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>::_M_f)(__x);
      }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const ;
  };
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_t<_Ret, _Tp> mem_fun(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)());
  template < typename _Ret, typename _Tp >
  inline ::std::mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)())
  {
    return ::std::mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const );
  template < typename _Ret, typename _Tp >
  inline ::std::const_mem_fun_ref_t<_Ret, _Tp> mem_fun_ref(_Ret (_Tp::*__f)() const )
  {
    return ::std::const_mem_fun_ref_t<_Ret, _Tp>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_t<_Ret, _Tp, _Arg> mem_fun(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg));
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
  {
    return ::std::mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const );
  template < typename _Ret, typename _Tp, typename _Arg >
  inline ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg> mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const )
  {
    return ::std::const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f);
  }
}
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Operation >
  class __attribute__((__deprecated__))  binder1st : public ::std::unary_function<typename _Operation::second_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      inline binder1st(const _Operation &__x, const typename _Operation::first_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::second_argument_type &__x) const 
      {
        return ::std::binder1st<_Operation>::op(::std::binder1st<_Operation>::value, __x);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder1st<_Operation> bind1st(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::first_argument_type _Arg1_type;
    return ::std::binder1st<_Operation>(__fn, _Arg1_type(__x));
  }
  template < typename _Operation >
  class __attribute__((__deprecated__))  binder2nd : public ::std::unary_function<typename _Operation::first_argument_type, typename _Operation::result_type>
  {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      inline binder2nd(const _Operation &__x, const typename _Operation::second_argument_type &__y)
        : op(__x), value(__y)
      {
      }
      inline typename _Operation::result_type operator ()(const typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
      inline typename _Operation::result_type operator ()(typename _Operation::first_argument_type &__x) const 
      {
        return ::std::binder2nd<_Operation>::op(__x, ::std::binder2nd<_Operation>::value);
      }
  };
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x);
  template < typename _Operation, typename _Tp >
  inline ::std::binder2nd<_Operation> bind2nd(const _Operation &__fn, const _Tp &__x)
  {
    typedef typename _Operation::second_argument_type _Arg2_type;
    return ::std::binder2nd<_Operation>(__fn, _Arg2_type(__x));
  }
}
#pragma GCC diagnostic pop
#pragma GCC visibility push(default)
namespace std __attribute__((__visibility__("default"))) {
  template < typename _E >
  class  initializer_list
  {
    public:
      typedef _E value_type;
      typedef const _E &reference;
      typedef const _E &const_reference;
      typedef ::std::size_t size_type;
      typedef const _E *iterator;
      typedef const _E *const_iterator;
    private:
      typename ::std::initializer_list<_E>::iterator _M_array;
      typename ::std::initializer_list<_E>::size_type _M_len;
      inline constexpr initializer_list(typename ::std::initializer_list<_E>::const_iterator __a, typename ::std::initializer_list<_E>::size_type __l)
        : _M_array(__a), _M_len(__l)
      {
      }
    public:
      inline constexpr initializer_list() noexcept(true)
        : _M_array(0), _M_len(0)
      {
      }
      inline constexpr typename ::std::initializer_list<_E>::size_type size() const  noexcept(true)
      {
        return ::std::initializer_list<_E>::_M_len;
      }
      inline constexpr typename ::std::initializer_list<_E>::const_iterator begin() const  noexcept(true)
      {
        return ::std::initializer_list<_E>::_M_array;
      }
      inline constexpr typename ::std::initializer_list<_E>::const_iterator end() const  noexcept(true)
      {
        return (*this).begin() + (*this).size();
      }
  };
  template < typename _Tp >
  inline constexpr const _Tp *begin(::std::initializer_list<_Tp> __ils) noexcept(true);
  template < typename _Tp >
  inline constexpr const _Tp *begin(::std::initializer_list<_Tp> __ils) noexcept(true)
  {
    return __ils.begin();
  }
  template < typename _Tp >
  inline constexpr const _Tp *end(::std::initializer_list<_Tp> __ils) noexcept(true);
  template < typename _Tp >
  inline constexpr const _Tp *end(::std::initializer_list<_Tp> __ils) noexcept(true)
  {
    return __ils.end();
  }
}
#pragma GCC visibility pop
namespace std __attribute__((__visibility__("default"))) {
  template < typename _Container >
  inline auto begin(_Container &__cont) -> decltype(__cont.begin());
  template < typename _Container >
  inline auto begin(_Container &__cont) -> decltype(__cont.begin())
  {
    return __cont.begin();
  }
  template < typename _Container >
  inline auto begin(const _Container &__cont) -> decltype(__cont.begin());
  template < typename _Container >
  inline auto begin(const _Container &__cont) -> decltype(__cont.begin())
  {
    return __cont.begin();
  }
  template < typename _Container >
  inline auto end(_Container &__cont) -> decltype(__cont.end());
  template < typename _Container >
  inline auto end(_Container &__cont) -> decltype(__cont.end())
  {
    return __cont.end();
  }
  template < typename _Container >
  inline auto end(const _Container &__cont) -> decltype(__cont.end());
  template < typename _Container >
  inline auto end(const _Container &__cont) -> decltype(__cont.end())
  {
    return __cont.end();
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *begin(_Tp (&__arr)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *begin(_Tp (&__arr)[_Nm])
  {
    return __arr;
  }
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *end(_Tp (&__arr)[_Nm]);
  template < typename _Tp, ::std::size_t _Nm >
  inline _Tp *end(_Tp (&__arr)[_Nm])
  {
    return __arr + _Nm;
  }
  template < typename _Alloc, typename _Tp >
  class  __alloctr_rebind_helper
  {
      template < typename _Alloc2, typename _Tp2 >
      static inline constexpr ::std::true_type _S_chk(typename _Alloc2::template rebind< _Tp2>::other *);
      template < typename __type_tpl__param_2_0__, typename __type_tpl__param_2_1__ >
      static inline constexpr ::std::false_type _S_chk(...);
    public:
      typedef decltype(_S_chk<_Alloc, _Tp>(nullptr)) __type;
  };
  template < typename _Alloc, typename _Tp, bool __nontype_tpl_param_1_2__ = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value >
  struct __alloctr_rebind;
  template < typename _Alloc, typename _Tp >
  struct  __alloctr_rebind<_Alloc, _Tp, true>
  {
      typedef typename _Alloc::template rebind< _Tp>::other __type;
  };
  template <   template < typename __type_tpl__param_1_0__, typename ...__type_tpl__param_1_1__ > class _Alloc, typename _Tp, typename _Up, typename ..._Args >
  struct  __alloctr_rebind<_Alloc<_Up, _Args ...>, _Tp, false>
  {
      typedef _Alloc<_Tp, _Args ...> __type;
  };
  template < typename _Alloc, typename _Tp >
  using __alloc_rebind = typename ::std::__alloctr_rebind<_Alloc, _Tp>::__type;
  template < typename _Alloc >
  struct  allocator_traits
  {
      typedef _Alloc allocator_type;
      typedef typename _Alloc::value_type value_type;
    private:
      template < typename _Tp >
      static typename _Tp::pointer _S_pointer_helper(_Tp *);
      static typename ::std::allocator_traits<_Alloc>::value_type *_S_pointer_helper(...);
      typedef decltype(_S_pointer_helper((_Alloc *)0)) __pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__pointer pointer;
    private:
      template < typename _Tp >
      static typename _Tp::const_pointer _S_const_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< const typename ::std::allocator_traits<_Alloc>::value_type> _S_const_pointer_helper(...);
      typedef decltype(_S_const_pointer_helper((_Alloc *)0)) __const_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__const_pointer const_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::void_pointer _S_void_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< void> _S_void_pointer_helper(...);
      typedef decltype(_S_void_pointer_helper((_Alloc *)0)) __void_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__void_pointer void_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::template rebind< const void> _S_const_void_pointer_helper(...);
      typedef decltype(_S_const_void_pointer_helper((_Alloc *)0)) __const_void_pointer;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__const_void_pointer const_void_pointer;
    private:
      template < typename _Tp >
      static typename _Tp::difference_type _S_difference_type_helper(_Tp *);
      static typename ::std::pointer_traits<typename ::std::allocator_traits<_Alloc>::pointer>::difference_type _S_difference_type_helper(...);
      typedef decltype(_S_difference_type_helper((_Alloc *)0)) __difference_type;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__difference_type difference_type;
    private:
      template < typename _Tp >
      static typename _Tp::size_type _S_size_type_helper(_Tp *);
      static typename ::std::make_unsigned<typename ::std::allocator_traits<_Alloc>::difference_type>::type _S_size_type_helper(...);
      typedef decltype(_S_size_type_helper((_Alloc *)0)) __size_type;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__size_type size_type;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_copy_assignment_helper(...);
      typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc *)0)) __propagate_on_container_copy_assignment;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_copy_assignment propagate_on_container_copy_assignment;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_move_assignment_helper(...);
      typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc *)0)) __propagate_on_container_move_assignment;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_move_assignment propagate_on_container_move_assignment;
    private:
      template < typename _Tp >
      static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp *);
      static ::std::false_type _S_propagate_on_container_swap_helper(...);
      typedef decltype(_S_propagate_on_container_swap_helper((_Alloc *)0)) __propagate_on_container_swap;
    public:
      typedef typename ::std::allocator_traits<_Alloc>::__propagate_on_container_swap propagate_on_container_swap;
      template < typename _Tp >
      using rebind_alloc = typename ::std::__alloctr_rebind<_Alloc, _Tp>::__type;
      template < typename _Tp >
      using rebind_traits = ::std::allocator_traits<typename ::std::allocator_traits<_Alloc>::template rebind_alloc<_Tp> >;
    private:
      template < typename _Alloc2 >
      struct  __allocate_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->allocate(std::declval<typename ::std::allocator_traits<_Alloc>::size_type>(), std::declval<typename ::std::allocator_traits<_Alloc>::const_void_pointer>())) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
      };
      template < typename _Alloc2 >
      using __has_allocate = typename ::std::allocator_traits<_Alloc>::template __allocate_helper< _Alloc2>::type;
      template < typename _Alloc2, typename __type_tpl__param_2_1__ = ::std::_Require<typename ::std::allocator_traits<_Alloc>::template __has_allocate<_Alloc2> > >
      static inline typename ::std::allocator_traits<_Alloc>::pointer _S_allocate(_Alloc2 &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, typename ::std::allocator_traits<_Alloc>::const_void_pointer __hint)
      {
        return __a.allocate(__n, __hint);
      }
      template < typename _Alloc2, typename _UnusedHint, typename __type_tpl__param_2_2__ = ::std::_Require< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __has_allocate<_Alloc2> > > >
      static inline typename ::std::allocator_traits<_Alloc>::pointer _S_allocate(_Alloc2 &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, _UnusedHint)
      {
        return __a.allocate(__n);
      }
      template < typename _Tp, typename ..._Args >
      struct  __construct_helper
      {
          template < typename _Alloc2, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc2 *>()->construct(std::declval<_Tp *>(), std::declval<_Args>() ...)) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
      };
      template < typename _Tp, typename ..._Args >
      using __has_construct = typename ::std::allocator_traits<_Alloc>::template __construct_helper< _Tp, _Args ...>::type;
      template < typename _Tp, typename ..._Args >
      static inline ::std::_Require<typename ::std::allocator_traits<_Alloc>::template __has_construct<_Tp, _Args ...> > _S_construct(_Alloc &__a, _Tp *__p, _Args &&...__args)
      {
        __a.construct(__p, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp, typename ..._Args >
      static inline ::std::_Require< ::std::__and_< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __has_construct<_Tp, _Args ...> >, ::std::is_constructible<_Tp, _Args ...> > > _S_construct(_Alloc &, _Tp *__p, _Args &&...__args)
      {
        ::new ((void *)__p)_Tp(std::forward<_Args>(__args) ...);
      }
      template < typename _Tp >
      struct  __destroy_helper
      {
          template < typename _Alloc2, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc2 *>()->destroy(std::declval<_Tp *>())) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc>(0)) type;
      };
      template < typename _Tp >
      using __has_destroy = typename ::std::allocator_traits<_Alloc>::template __destroy_helper< _Tp>::type;
      template < typename _Tp >
      static inline ::std::_Require<typename ::std::allocator_traits<_Alloc>::template __has_destroy<_Tp> > _S_destroy(_Alloc &__a, _Tp *__p)
      {
        __a.destroy(__p);
      }
      template < typename _Tp >
      static inline ::std::_Require< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __has_destroy<_Tp> > > _S_destroy(_Alloc &, _Tp *__p)
      {
        __p->~_Tp();
      }
      template < typename _Alloc2 >
      struct  __maxsize_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->max_size()) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc2>(0)) type;
      };
      template < typename _Alloc2 >
      using __has_max_size = typename ::std::allocator_traits<_Alloc>::template __maxsize_helper< _Alloc2>::type;
      template < typename _Alloc2, typename __type_tpl__param_2_1__ = ::std::_Require<typename ::std::allocator_traits<_Alloc>::template __has_max_size<_Alloc2> > >
      static inline typename ::std::allocator_traits<_Alloc>::size_type _S_max_size(_Alloc2 &__a, int)
      {
        return __a.max_size();
      }
      template < typename _Alloc2, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __has_max_size<_Alloc2> > > >
      static inline typename ::std::allocator_traits<_Alloc>::size_type _S_max_size(_Alloc2 &, ...)
      {
        return __gnu_cxx::__numeric_traits<typename ::std::allocator_traits<_Alloc>::size_type>::__max;
      }
      template < typename _Alloc2 >
      struct  __select_helper
      {
          template < typename _Alloc3, typename __type_tpl__param_3_1__ = decltype(std::declval<_Alloc3 *>()->select_on_container_copy_construction()) >
          static ::std::true_type __test(int);
          template < typename __type_tpl__param_3_0__ >
          static ::std::false_type __test(...);
          typedef decltype(__test<_Alloc2>(0)) type;
      };
      template < typename _Alloc2 >
      using __has_soccc = typename ::std::allocator_traits<_Alloc>::template __select_helper< _Alloc2>::type;
      template < typename _Alloc2, typename __type_tpl__param_2_1__ = ::std::_Require<typename ::std::allocator_traits<_Alloc>::template __has_soccc<_Alloc2> > >
      static inline _Alloc2 _S_select(_Alloc2 &__a, int)
      {
        return __a.select_on_container_copy_construction();
      }
      template < typename _Alloc2, typename __type_tpl__param_2_1__ = ::std::_Require< ::std::__not_<typename ::std::allocator_traits<_Alloc>::template __has_soccc<_Alloc2> > > >
      static inline _Alloc2 _S_select(_Alloc2 &__a, ...)
      {
        return __a;
      }
    public:
      static inline typename ::std::allocator_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::size_type __n)
      {
        return __a.allocate(__n);
      }
      static inline typename ::std::allocator_traits<_Alloc>::pointer allocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::size_type __n, typename ::std::allocator_traits<_Alloc>::const_void_pointer __hint)
      {
        return _S_allocate(__a, __n, __hint);
      }
      static inline void deallocate(_Alloc &__a, typename ::std::allocator_traits<_Alloc>::pointer __p, typename ::std::allocator_traits<_Alloc>::size_type __n)
      {
        __a.deallocate(__p, __n);
      }
      template < typename _Tp, typename ..._Args >
      static inline auto construct(_Alloc &__a, _Tp *__p, _Args &&...__args) -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args) ...))
      {
        _S_construct(__a, __p, std::forward<_Args>(__args) ...);
      }
      template < typename _Tp >
      static inline void destroy(_Alloc &__a, _Tp *__p)
      {
        _S_destroy(__a, __p);
      }
      static inline typename ::std::allocator_traits<_Alloc>::size_type max_size(const _Alloc &__a) noexcept(true)
      {
        return _S_max_size(__a, 0);
      }
      static inline _Alloc select_on_container_copy_construction(const _Alloc &__rhs)
      {
        return _S_select(__rhs, 0);
      }
  };
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &__one, const _Alloc &__two, ::std::true_type)
  {
    __one = __two;
  }
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_copy(_Alloc &, const _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_copy(_Alloc &__one, const _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_copy(_Alloc &__one, const _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_copy_assignment __pocca;
    __do_alloc_on_copy(__one, __two, __pocca());
  }
  template < typename _Alloc >
  inline _Alloc __alloc_on_copy(const _Alloc &__a);
  template < typename _Alloc >
  inline _Alloc __alloc_on_copy(const _Alloc &__a)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    return __traits::select_on_container_copy_construction(__a);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &__one, _Alloc &__two, ::std::true_type)
  {
    __one = std::move(__two);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &, _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_move(_Alloc &, _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_move(_Alloc &__one, _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_move(_Alloc &__one, _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_move_assignment __pocma;
    __do_alloc_on_move(__one, __two, __pocma());
  }
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, ::std::true_type);
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &__one, _Alloc &__two, ::std::true_type)
  {
    using ::std::swap;
    swap(__one, __two);
  }
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &, _Alloc &, ::std::false_type);
  template < typename _Alloc >
  inline void __do_alloc_on_swap(_Alloc &, _Alloc &, ::std::false_type)
  {
  }
  template < typename _Alloc >
  inline void __alloc_on_swap(_Alloc &__one, _Alloc &__two);
  template < typename _Alloc >
  inline void __alloc_on_swap(_Alloc &__one, _Alloc &__two)
  {
    typedef ::std::allocator_traits<_Alloc> __traits;
    typedef typename ::std::allocator_traits<_Alloc>::propagate_on_container_swap __pocs;
    __do_alloc_on_swap(__one, __two, __pocs());
  }
  template < typename _Alloc >
  class  __is_copy_insertable_impl
  {
      typedef ::std::allocator_traits<_Alloc> _Traits;
      template < typename _Up, typename __type_tpl__param_2_1__ = decltype(_Traits::construct(std::declval<_Alloc &>(), std::declval<_Up *>(), std::declval<const _Up &>())) >
      static ::std::true_type _M_select(int);
      template < typename _Up >
      static ::std::false_type _M_select(...);
    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
  };
  template < typename _Alloc >
  struct  __is_copy_insertable : ::std::__is_copy_insertable_impl<_Alloc>::type
  {
  };
  template < typename _Tp >
  struct  __is_copy_insertable< ::std::allocator<_Tp> > : ::std::is_copy_constructible<_Tp>
  {
  };
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _Alloc >
  struct  __allocator_always_compares_equal : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::std::allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__, typename __type_tpl__param_1_1__ >
  struct array_allocator;
  template < typename _Tp, typename _Array >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::array_allocator<_Tp, _Array> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct bitmap_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::bitmap_allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct malloc_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::malloc_allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct mt_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::mt_allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  class new_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::new_allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename __type_tpl__param_1_0__ >
  struct pool_allocator;
  template < typename _Tp >
  struct  __allocator_always_compares_equal< ::__gnu_cxx::pool_allocator<_Tp> > : ::std::integral_constant<bool, true>
  {
  };
  template < typename _Alloc >
  struct  __alloc_traits : ::std::allocator_traits<_Alloc>
  {
      typedef _Alloc allocator_type;
      typedef ::std::allocator_traits<_Alloc> _Base_type;
      typedef typename ::std::allocator_traits<_Alloc>::value_type value_type;
      typedef typename ::std::allocator_traits<_Alloc>::pointer pointer;
      typedef typename ::std::allocator_traits<_Alloc>::const_pointer const_pointer;
      typedef typename ::std::allocator_traits<_Alloc>::size_type size_type;
      typedef typename ::std::allocator_traits<_Alloc>::difference_type difference_type;
      typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::value_type &reference;
      typedef const typename ::__gnu_cxx::__alloc_traits<_Alloc>::value_type &const_reference;
      using ::std::allocator_traits<_Alloc>::allocate;
      using ::std::allocator_traits<_Alloc>::deallocate;
      using ::std::allocator_traits<_Alloc>::construct;
      using ::std::allocator_traits<_Alloc>::destroy;
      using ::std::allocator_traits<_Alloc>::max_size;
    private:
      template < typename _Ptr >
      using __is_custom_pointer = ::std::__and_< ::std::is_same<typename ::__gnu_cxx::__alloc_traits<_Alloc>::pointer, _Ptr>, ::std::__not_< ::std::is_pointer<_Ptr> > >;
    public:
      template < typename _Ptr, typename ..._Args >
      static inline typename ::std::enable_if<__is_custom_pointer<_Ptr>::value>::type construct(_Alloc &__a, _Ptr __p, _Args &&...__args)
      {
        _Base_type::construct(__a, std::addressof(*__p), std::forward<_Args>(__args) ...);
      }
      template < typename _Ptr >
      static inline typename ::std::enable_if<__is_custom_pointer<_Ptr>::value>::type destroy(_Alloc &__a, _Ptr __p)
      {
        _Base_type::destroy(__a, std::addressof(*__p));
      }
      static inline _Alloc _S_select_on_copy(const _Alloc &__a)
      {
        return _Base_type::select_on_container_copy_construction(__a);
      }
      static inline void _S_on_swap(_Alloc &__a, _Alloc &__b)
      {
        std::__alloc_on_swap(__a, __b);
      }
      static inline constexpr bool _S_propagate_on_copy_assign()
      {
        return _Base_type::propagate_on_container_copy_assignment::value;
      }
      static inline constexpr bool _S_propagate_on_move_assign()
      {
        return _Base_type::propagate_on_container_move_assignment::value;
      }
      static inline constexpr bool _S_propagate_on_swap()
      {
        return _Base_type::propagate_on_container_swap::value;
      }
      static inline constexpr bool _S_always_equal()
      {
        return __allocator_always_compares_equal<_Alloc>::value;
      }
      static inline constexpr bool _S_nothrow_move()
      {
        return _S_propagate_on_move_assign() || _S_always_equal();
      }
      static inline constexpr bool _S_nothrow_swap()
      {
        using ::std::swap;
        return !_S_propagate_on_swap() || (noexcept(swap(std::declval<_Alloc &>(), std::declval<_Alloc &>())));
      }
      template < typename _Tp >
      struct  rebind
      {
          typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::_Base_type::template rebind_alloc< _Tp> other;
      };
  };
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<int>, ::__gnu_cxx::__numeric_traits_floating<int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<int>' */ 
}
namespace std __attribute__((__visibility__("default"))) {
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    class  basic_string
    {
        typedef typename ::__gnu_cxx::__alloc_traits<_Alloc>::template rebind< _CharT>::other _Char_alloc_type;
        typedef ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type> _Alloc_traits;
      public:
        typedef _Traits traits_type;
        typedef typename _Traits::char_type value_type;
        typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type allocator_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::size_type size_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::difference_type difference_type;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::reference reference;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::const_reference const_reference;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::pointer pointer;
        typedef typename ::__gnu_cxx::__alloc_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Char_alloc_type>::const_pointer const_pointer;
        typedef ::__gnu_cxx::__normal_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> > iterator;
        typedef ::__gnu_cxx::__normal_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> > const_iterator;
        typedef ::std::reverse_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator> const_reverse_iterator;
        typedef ::std::reverse_iterator<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator> reverse_iterator;
        static const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type npos = static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>( -1);
      private:
        typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __const_iterator;
        struct  _Alloc_hider : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type
        {
            inline _Alloc_hider(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __dat, const _Alloc &__a  = (_Alloc()))
              : allocator_type(__a), _M_p(__dat)
            {
            }
            typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_p;
        };
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider _M_dataplus;
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_string_length;
        enum mcc_enum_anon_65
        {
          _S_local_capacity = 15 / sizeof(_CharT)
        };
        union 
        {
            _CharT _M_local_buf[::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1];
            typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_allocated_capacity;
        };
        inline void _M_data(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __p)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p = __p;
        }
        inline void _M_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __length)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length = __length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_data() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus._M_p;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_local_data()
        {
          return std::pointer_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer>::pointer_to(*::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer _M_local_data() const 
        {
          return std::pointer_traits<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer>::pointer_to(*::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf);
        }
        inline void _M_capacity(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity)
        {
          ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity = __capacity;
        }
        inline void _M_set_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          (*this)._M_length(__n);
          traits_type::assign((*this)._M_data()[__n], _CharT());
        }
        inline bool _M_is_local() const 
        {
          return (*this)._M_data() == (*this)._M_local_data();
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer _M_create(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type &__capacity, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity);
        inline void _M_dispose()
        {
          if (!(*this)._M_is_local())
            {
              (*this)._M_destroy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity);
            }
        }
        inline void _M_destroy(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size) throw()
        {
          _Alloc_traits::deallocate((*this)._M_get_allocator(), (*this)._M_data(), __size + 1);
        }
        template < typename _InIterator >
        inline void _M_construct_aux(_InIterator __beg, _InIterator __end, ::std::__false_type)
        {
          typedef typename ::std::iterator_traits<_InIterator>::iterator_category _Tag;
          (*this)._M_construct(__beg, __end, _Tag());
        }
        template < typename _Integer >
        inline void _M_construct_aux(_Integer __beg, _Integer __end, ::std::__true_type)
        {
          (*this)._M_construct_aux_2(static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>(__beg), __end);
        }
        inline void _M_construct_aux_2(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __req, _CharT __c)
        {
          (*this)._M_construct(__req, __c);
        }
        template < typename _InIterator >
        inline void _M_construct(_InIterator __beg, _InIterator __end)
        {
          typedef typename ::std::__is_integer<_InIterator>::__type _Integral;
          (*this)._M_construct_aux(__beg, __end, _Integral());
        }
        template < typename _InIterator >
        void _M_construct(_InIterator __beg, _InIterator __end, ::std::input_iterator_tag);
        template < typename _FwdIterator >
        void _M_construct(_FwdIterator __beg, _FwdIterator __end, ::std::forward_iterator_tag);
        void _M_construct(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type &_M_get_allocator()
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus;
        }
        inline const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type &_M_get_allocator() const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dataplus;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_check(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const char *__s) const 
        {
          if (__pos > this->size())
            {
              __throw_out_of_range_fmt("%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, this->size());
            }
          return __pos;
        }
        inline void _M_check_length(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, const char *__s) const 
        {
          if (this->max_size() - (this->size() - __n1) < __n2)
            {
              ::std::__throw_length_error(__s);
            }
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type _M_limit(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __off) const  noexcept(true)
        {
          const bool __testoff = __off < this->size() - __pos;
          return __testoff ? __off : this->size() - __pos;
        }
        inline bool _M_disjunct(const _CharT *__s) const  noexcept(true)
        {
          return ::std::less<const _CharT *>()(__s, (*this)._M_data()) || ::std::less<const _CharT *>()((*this)._M_data() + this->size(), __s);
        }
        static inline void _S_copy(_CharT *__d, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, *__s);
            }
          else
            {
              traits_type::copy(__d, __s, __n);
            }
        }
        static inline void _S_move(_CharT *__d, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, *__s);
            }
          else
            {
              traits_type::move(__d, __s, __n);
            }
        }
        static inline void _S_assign(_CharT *__d, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          if (__n == 1)
            {
              traits_type::assign(*__d, __c);
            }
          else
            {
              traits_type::assign(__d, __n, __c);
            }
        }
        template < typename _Iterator >
        static inline void _S_copy_chars(_CharT *__p, _Iterator __k1, _Iterator __k2) noexcept(true)
        {
          for (; __k1 != __k2; ( ++__k1,  ++__p))
            {
              traits_type::assign(*__p, *__k1);
            }
        }
        static inline void _S_copy_chars(_CharT *__p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k2) noexcept(true)
        {
          _S_copy_chars(__p, __k1.base(), __k2.base());
        }
        static inline void _S_copy_chars(_CharT *__p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2) noexcept(true)
        {
          _S_copy_chars(__p, __k1.base(), __k2.base());
        }
        static inline void _S_copy_chars(_CharT *__p, _CharT *__k1, _CharT *__k2) noexcept(true)
        {
          _S_copy(__p, __k1, __k2 - __k1);
        }
        static inline void _S_copy_chars(_CharT *__p, const _CharT *__k1, const _CharT *__k2) noexcept(true)
        {
          _S_copy(__p, __k1, __k2 - __k1);
        }
        static inline int _S_compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) noexcept(true)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::difference_type __d = ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::difference_type(__n1 - __n2)));
          if (__d > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
            {
              return ::__gnu_cxx::__numeric_traits_integer<int>::__max;
            }
          else
            {
              if (__d < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
                {
                  return ::__gnu_cxx::__numeric_traits_integer<int>::__min;
                }
              else
                {
                  return int(__d);
                }
            }
        }
        void _M_assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
        void _M_mutate(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
        void _M_erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      public:
        inline basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
          : _M_dataplus((*this)._M_local_data())
        {
          (*this)._M_set_length(0);
        }
        inline explicit basic_string(const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_set_length(0);
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
          : _M_dataplus((*this)._M_local_data(), __str._M_get_allocator())
        {
          (*this)._M_construct(__str._M_data(), __str._M_data() + __str.length());
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
          : _M_dataplus((*this)._M_local_data())
        {
          const _CharT *__start = __str._M_data() + __str._M_check(__pos, "basic_string::basic_string");
          (*this)._M_construct(__start, __start + __str._M_limit(__pos, __n));
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          const _CharT *__start = __str._M_data() + __str._M_check(__pos, "string::string");
          (*this)._M_construct(__start, __start + __str._M_limit(__pos, __n));
        }
        inline basic_string(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__s, __s + __n);
        }
        inline basic_string(const _CharT *__s, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__s, __s ? __s + traits_type::length(__s) : __s + ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos);
        }
        inline basic_string(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__n, __c);
        }
        inline basic_string(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__str) noexcept(true)
          : _M_dataplus((*this)._M_local_data(), std::move(__str._M_get_allocator()))
        {
          if (__str._M_is_local())
            {
              traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __str._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
            }
          else
            {
              (*this)._M_data(__str._M_data());
              (*this)._M_capacity(__str._M_allocated_capacity);
            }
          (*this)._M_length(__str.length());
          __str._M_data(__str._M_local_data());
          __str._M_set_length(0);
        }
        inline basic_string(::std::initializer_list<_CharT> __l, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__l.begin(), __l.end());
        }
        inline basic_string(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__str.begin(), __str.end());
        }
        inline basic_string(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__str, const _Alloc &__a)
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          if (__str.get_allocator() == __a)
            {
              *this = std::move(__str);
            }
          else
            {
              (*this)._M_construct(__str.begin(), __str.end());
            }
        }
        template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
        inline basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc &__a  = (_Alloc()))
          : _M_dataplus((*this)._M_local_data(), __a)
        {
          (*this)._M_construct(__beg, __end);
        }
        inline ~basic_string()
        {
          (*this)._M_dispose();
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->assign(__str);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(const _CharT *__s)
        {
          return this->assign(__s);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(_CharT __c)
        {
          this->assign(1, __c);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__str)
        {
          this->swap(__str);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator =(::std::initializer_list<_CharT> __l)
        {
          this->assign(__l.begin(), __l.size());
          return *this;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator begin() noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator begin() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator end() noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + this->size())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator end() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator((*this)._M_data() + this->size())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rbegin() noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->end())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rbegin() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator rend() noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reverse_iterator(this->begin())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator rend() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator cbegin() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator(this->_M_data())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator cend() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator(this->_M_data() + this->size())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator crbegin() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->end())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator crend() const  noexcept(true)
        {
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reverse_iterator(this->begin())));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type size() const  noexcept(true)
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type length() const  noexcept(true)
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_string_length;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type max_size() const  noexcept(true)
        {
          return (_Alloc_traits::max_size((*this)._M_get_allocator()) - 1) / 2;
        }
        void resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c);
        inline void resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          this->resize(__n, _CharT());
        }
        inline void shrink_to_fit() noexcept(true)
        {
          if ((*this).capacity() > (*this).size())
            {
              try
              {
                (*this).reserve(0);
              }
              catch (...)
              {
              }
            }
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type capacity() const  noexcept(true)
        {
          return (*this)._M_is_local() ? ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))) : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity;
        }
        void reserve(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __res  = (0));
        inline void clear() noexcept(true)
        {
          (*this)._M_set_length(0);
        }
        inline bool empty() const  noexcept(true)
        {
          return this->size() == 0;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference operator [](typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
        {
          ;
          return (*this)._M_data()[__pos];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference operator [](typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos)
        {
          ;
          ;
          return (*this)._M_data()[__pos];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference at(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
        {
          if (__n >= this->size())
            {
              __throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
            }
          return (*this)._M_data()[__n];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference at(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          if (__n >= (*this).size())
            {
              __throw_out_of_range_fmt("basic_string::at: __n (which is %zu) >= this->size() (which is %zu)", __n, this->size());
            }
          return (*this)._M_data()[__n];
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference front() noexcept(true)
        {
          return (*this).operator [](0);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference front() const  noexcept(true)
        {
          return (*this).operator [](0);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::reference back() noexcept(true)
        {
          return (*this).operator [](this->size() - 1);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference back() const  noexcept(true)
        {
          return (*this).operator [](this->size() - 1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->append(__str);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(const _CharT *__s)
        {
          return this->append(__s);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(_CharT __c)
        {
          this->push_back(__c);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &operator +=(::std::initializer_list<_CharT> __l)
        {
          return this->append(__l.begin(), __l.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return (*this)._M_append(__str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          return (*this)._M_append(__str._M_data() + __str._M_check(__pos, "basic_string::append"), __str._M_limit(__pos, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          (*this)._M_check_length(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
          return (*this)._M_append(__s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(const _CharT *__s)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n = traits_type::length(__s);
          (*this)._M_check_length(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, "basic_string::append");
          return (*this)._M_append(__s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux(this->size(), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, __c);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(::std::initializer_list<_CharT> __l)
        {
          return this->append(__l.begin(), __l.size());
        }
        template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &append(_InputIterator __first, _InputIterator __last)
        {
          return this->replace((*this).end(), (*this).end(), __first, __last);
        }
        inline void push_back(_CharT __c)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
          if (__size + 1 > this->capacity())
            {
              this->_M_mutate(__size, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), 0, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))));
            }
          traits_type::assign(this->_M_data()[__size], __c);
          this->_M_set_length(__size + 1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          this->_M_assign(__str);
          return *this;
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__str)
        {
          return *this = std::move(__str);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __str._M_data() + __str._M_check(__pos, "basic_string::assign"), __str._M_limit(__pos, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(const _CharT *__s)
        {
          ;
          return (*this)._M_replace(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), this->size(), __n, __c);
        }
        template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(_InputIterator __first, _InputIterator __last)
        {
          return this->replace((*this).begin(), (*this).end(), __first, __last);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &assign(::std::initializer_list<_CharT> __l)
        {
          return this->assign(__l.begin(), __l.size());
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __p, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - (*this).begin();
          this->replace(__p, __p, __n, __c);
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator(this->_M_data() + __pos)));
        }
        template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - (*this).begin();
          this->replace(__p, __p, __beg, __end);
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator(this->_M_data() + __pos)));
        }
        inline void insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __p, ::std::initializer_list<_CharT> __l)
        {
          ;
          this->insert(__p - (*this).begin(), __l.begin(), __l.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__pos1, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          return this->replace(__pos1, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __str._M_data() + __str._M_check(__pos2, "basic_string::insert"), __str._M_limit(__pos2, __n));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          return this->replace(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, const _CharT *__s)
        {
          ;
          return this->replace(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::insert"), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __n, __c);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator insert(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __p, _CharT __c)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __p - (*this).begin();
          (*this)._M_replace_aux(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))), __c);
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos))
        {
          this->_M_erase((*this)._M_check(__pos, "basic_string::erase"), (*this)._M_limit(__pos, __n));
          return *this;
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __position)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __position - (*this).begin();
          this->_M_erase(__pos, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(1))));
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator((*this)._M_data() + __pos)));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __first, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __last)
        {
          ;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos = __first - (*this).begin();
          this->_M_erase(__pos, __last - __first);
          return ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator(this->_M_data() + __pos)));
        }
        inline void pop_back() noexcept(true)
        {
          (*this)._M_erase((*this).size() - 1, 1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__pos, __n, __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
        {
          return this->replace(__pos1, __n1, __str._M_data() + __str._M_check(__pos2, "basic_string::replace"), __str._M_limit(__pos2, __n2));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2)
        {
          ;
          return (*this)._M_replace((*this)._M_check(__pos, "basic_string::replace"), (*this)._M_limit(__pos, __n1), __s, __n2);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s)
        {
          ;
          return this->replace(__pos, __n1, __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
        {
          return (*this)._M_replace_aux((*this)._M_check(__pos, "basic_string::replace"), (*this)._M_limit(__pos, __n1), __n2, __c);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
        {
          return this->replace(__i1, __i2, __str._M_data(), __str.size());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
        {
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __s, __n);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__s)
        {
          ;
          return this->replace(__i1, __i2, __s, traits_type::length(__s));
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
        {
          ;
          return (*this)._M_replace_aux(__i1 - (*this).begin(), __i2 - __i1, __n, __c);
        }
        template < typename _InputIterator, typename __type_tpl__param_2_1__ = ::std::_RequireInputIter<_InputIterator> >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2)
        {
          ;
          ;
          return this->_M_replace_dispatch(__i1, __i2, __k1, __k2, ::std::__false_type());
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, _CharT *__k1, _CharT *__k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1, __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, const _CharT *__k1, const _CharT *__k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1, __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator __k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator __i2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __k2)
        {
          ;
          ;
          return this->replace(__i1 - (*this).begin(), __i2 - __i1, __k1.base(), __k2 - __k1);
        }
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, ::std::initializer_list<_CharT> __l)
        {
          return this->replace(__i1, __i2, __l.begin(), __l.end());
        }
      private:
        template < typename _Integer >
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _Integer __n, _Integer __val, ::std::__true_type)
        {
          return (*this)._M_replace_aux(__i1 - (*this).begin(), __i2 - __i1, __n, __val);
        }
        template < typename _InputIterator >
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace_aux(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2);
        ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &_M_append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n);
      public:
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type copy(_CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const ;
        void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s) noexcept(true);
        inline const _CharT *c_str() const  noexcept(true)
        {
          return (*this)._M_data();
        }
        inline const _CharT *data() const  noexcept(true)
        {
          return (*this)._M_data();
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type get_allocator() const  noexcept(true)
        {
          return (*this)._M_get_allocator();
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
        {
          return this->find(__str.data(), __pos, __str.size());
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true);
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
        {
          return this->rfind(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->rfind(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type rfind(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true);
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
        {
          return this->find_first_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find_first_of(__s, __pos, traits_type::length(__s));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
        {
          return this->find(__c, __pos);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
        {
          return this->find_last_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->find_last_of(__s, __pos, traits_type::length(__s));
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
        {
          return this->rfind(__c, __pos);
        }
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true)
        {
          return this->find_first_not_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const 
        {
          ;
          return this->find_first_not_of(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_first_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0)) const  noexcept(true);
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true)
        {
          return this->find_last_not_of(__str.data(), __pos, __str.size());
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const ;
        inline typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          ;
          return this->find_last_not_of(__s, __pos, traits_type::length(__s));
        }
        typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type find_last_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const  noexcept(true);
        inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> substr(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos  = (0), typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n  = (::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos)) const 
        {
          return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>(*this, (*this)._M_check(__pos, "basic_string::substr"), __n);
        }
        inline int compare(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const 
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
          int __r = traits_type::compare((*this)._M_data(), __str.data(), __len);
          if (!__r)
            {
              __r = _S_compare(__size, __osize);
            }
          return __r;
        }
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
        int compare(const _CharT *__s) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const ;
        int compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const ;
    };
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, _CharT __rhs)
  {
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str(__lhs);
    __str.append(__size_type(1), __rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    const auto __size = __lhs.size() + __rhs.size();
    const bool __cond = __size > __lhs.capacity() && __size <= __rhs.capacity();
    return __cond ? std::move(__rhs.insert(0, __lhs)) : std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__rhs)
  {
    return std::move(__rhs.insert(0, 1, __lhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, const _CharT *__rhs)
  {
    return std::move(__lhs.append(__rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &&__lhs, _CharT __rhs)
  {
    return std::move(__lhs.append(1, __rhs));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::__cxx11::basic_string<_CharT> &__lhs, const ::std::__cxx11::basic_string<_CharT> &__rhs);
  template < typename _CharT >
  inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type operator ==(const ::std::__cxx11::basic_string<_CharT> &__lhs, const ::std::__cxx11::basic_string<_CharT> &__rhs)
  {
    return __lhs.size() == __rhs.size() && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(), __lhs.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator ==(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) == 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator !=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return !(__lhs == __rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) > 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) < 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator <=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, const _CharT *__rhs)
  {
    return __lhs.compare(__rhs) >= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline bool operator >=(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    return __rhs.compare(__lhs) <= 0;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline void swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__lhs, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    __lhs.swap(__rhs);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__is, ::std::__cxx11::basic_string<char> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return __ostream_insert(__os, __str.data(), __str.size());
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return std::getline(__is, __str, __is.widen('\n'));
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &&__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &&__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)
  {
    return std::getline(__is, __str, __delim);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &&__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str);
  template < typename _CharT, typename _Traits, typename _Alloc >
  inline ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &&__is, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    return std::getline(__is, __str);
  }
  template <>
  ::std::basic_istream<char> &getline<char, ::std::char_traits<char>, ::std::allocator<char> >(::std::basic_istream<char> &__in, ::std::__cxx11::basic_string<char> &__str, char __delim);
  template <>
  ::std::basic_istream<wchar_t> &getline<wchar_t, ::std::char_traits<wchar_t>, ::std::allocator<wchar_t> >(::std::basic_istream<wchar_t> &__in, ::std::__cxx11::basic_string<wchar_t> &__str, wchar_t __delim);
}
union  wait
{
    int w_status;
    struct  mcc_struct_anon_84
    {
        unsigned int __w_termsig:7;
        unsigned int __w_coredump:1;
        unsigned int __w_retcode:8;
        unsigned int:16;
    };
    ::wait::mcc_struct_anon_84 __wait_terminated;
    struct  mcc_struct_anon_85
    {
        unsigned int __w_stopval:8;
        unsigned int __w_stopsig:8;
        unsigned int:16;
    };
    ::wait::mcc_struct_anon_85 __wait_stopped;
};
struct  div_t
{
    int quot;
    int rem;
};
struct  ldiv_t
{
    long int quot;
    long int rem;
};
__extension__ struct  lldiv_t
{
    __extension__ long long int quot;
    __extension__ long long int rem;
};
extern "C"
{
  extern ::size_t __ctype_get_mb_cur_max() throw();
}
extern "C"
{
  extern inline double atof(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline int atoi(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long int atol(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline long long int atoll(const char *__nptr) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern double strtod(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern float strtof(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long double strtold(const char *__restrict __nptr, char **__restrict __endptr) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long int strtoul(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtouq(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long long int strtoll(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern unsigned long long int strtoull(const char *__restrict __nptr, char **__restrict __endptr, int __base) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int strtol_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long int strtoul_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern long long int strtoll_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern unsigned long long int strtoull_l(const char *__restrict __nptr, char **__restrict __endptr, int __base, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern double strtod_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern float strtof_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern long double strtold_l(const char *__restrict __nptr, char **__restrict __endptr, ::__locale_t __loc) throw() __attribute__((__nonnull__(1, 3)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) int atoi(const char *__nptr) throw()
  {
    return (int)::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long int atol(const char *__nptr) throw()
  {
    return ::strtol(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) long long int atoll(const char *__nptr) throw()
  {
    return ::strtoll(__nptr, (char **)0L, 10);
  }
}
extern "C"
{
  extern char *l64a(long int __n) throw();
}
extern "C"
{
  extern long int a64l(const char *__s) throw() __attribute__((__pure__)) __attribute__((__nonnull__(1)));
}
typedef ::__u_char u_char;
typedef ::__u_short u_short;
typedef ::__u_int u_int;
typedef ::__u_long u_long;
typedef ::__quad_t quad_t;
typedef ::__u_quad_t u_quad_t;
typedef ::__fsid_t fsid_t;
typedef ::__loff_t loff_t;
typedef ::__ino_t ino_t;
typedef ::__ino64_t ino64_t;
typedef ::__dev_t dev_t;
typedef ::__gid_t gid_t;
typedef ::__mode_t mode_t;
typedef ::__nlink_t nlink_t;
typedef ::__uid_t uid_t;
typedef ::__id_t id_t;
typedef ::__daddr_t daddr_t;
typedef ::__caddr_t caddr_t;
typedef ::__key_t key_t;
typedef ::__useconds_t useconds_t;
typedef ::__suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned char u_int8_t;
typedef unsigned short int u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long int u_int64_t;
typedef long int register_t;
typedef int __sig_atomic_t;
struct  __sigset_t
{
    unsigned long int __val[16L];
};
typedef ::__sigset_t sigset_t;
typedef long int __fd_mask;
struct  fd_set
{
    ::__fd_mask fds_bits[16L];
};
typedef ::__fd_mask fd_mask;
extern "C"
{
  extern int select(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, ::timeval *__restrict __timeout);
}
extern "C"
{
  extern int pselect(int __nfds, ::fd_set *__restrict __readfds, ::fd_set *__restrict __writefds, ::fd_set *__restrict __exceptfds, const ::timespec *__restrict __timeout, const ::__sigset_t *__restrict __sigmask);
}
extern "C"
{
  extern inline unsigned int gnu_dev_major(unsigned long long int __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline unsigned int gnu_dev_minor(unsigned long long int __dev) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw() __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__));
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_major(unsigned long long int __dev) throw()
  {
    return (__dev >> 8 & 4095) | ((unsigned int)(__dev >> 32) & ~4095);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned int gnu_dev_minor(unsigned long long int __dev) throw()
  {
    return (__dev & 255) | ((unsigned int)(__dev >> 12) & ~255);
  }
}
extern "C"
{
  __extension__ extern inline __attribute__((__const__)) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor) throw()
  {
    return (((__minor & 255) | (__major & 4095) << 8) | (unsigned long long int)(__minor & ~255) << 12) | (unsigned long long int)(__major & ~4095) << 32;
  }
}
typedef ::__blksize_t blksize_t;
typedef ::__blkcnt_t blkcnt_t;
typedef ::__fsblkcnt_t fsblkcnt_t;
typedef ::__fsfilcnt_t fsfilcnt_t;
typedef ::__blkcnt64_t blkcnt64_t;
typedef ::__fsblkcnt64_t fsblkcnt64_t;
typedef ::__fsfilcnt64_t fsfilcnt64_t;
extern "C"
{
  extern long int random() throw();
}
extern "C"
{
  extern void srandom(unsigned int __seed) throw();
}
extern "C"
{
  extern char *initstate(unsigned int __seed, char *__statebuf, ::size_t __statelen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern char *setstate(char *__statebuf) throw() __attribute__((__nonnull__(1)));
}
struct  random_data
{
    ::int32_t *fptr;
    ::int32_t *rptr;
    ::int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    ::int32_t *end_ptr;
};
extern "C"
{
  extern int random_r(::random_data *__restrict __buf, ::int32_t *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srandom_r(unsigned int __seed, ::random_data *__buf) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int initstate_r(unsigned int __seed, char *__restrict __statebuf, ::size_t __statelen, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(2, 4)));
}
extern "C"
{
  extern int setstate_r(char *__restrict __statebuf, ::random_data *__restrict __buf) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int rand() throw();
}
extern "C"
{
  extern void srand(unsigned int __seed) throw();
}
extern "C"
{
  extern int rand_r(unsigned int *__seed) throw();
}
extern "C"
{
  extern double drand48() throw();
}
extern "C"
{
  extern double erand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int lrand48() throw();
}
extern "C"
{
  extern long int nrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern long int mrand48() throw();
}
extern "C"
{
  extern long int jrand48(unsigned short int __xsubi[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void srand48(long int __seedval) throw();
}
extern "C"
{
  extern unsigned short int *seed48(unsigned short int __seed16v[3L]) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void lcong48(unsigned short int __param[7L]) throw() __attribute__((__nonnull__(1)));
}
struct  drand48_data
{
    unsigned short int __x[3L];
    unsigned short int __old_x[3L];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;
};
extern "C"
{
  extern int drand48_r(::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int erand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, double *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int nrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int mrand48_r(::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int jrand48_r(unsigned short int __xsubi[3L], ::drand48_data *__restrict __buffer, long int *__restrict __result) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int srand48_r(long int __seedval, ::drand48_data *__buffer) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int seed48_r(unsigned short int __seed16v[3L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern int lcong48_r(unsigned short int __param[7L], ::drand48_data *__buffer) throw() __attribute__((__nonnull__(1, 2)));
}
extern "C"
{
  extern void *malloc(::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern void *calloc(::size_t __nmemb, ::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern void *realloc(void *__ptr, ::size_t __size) throw() __attribute__((__warn_unused_result__));
}
extern "C"
{
  extern void free(void *__ptr) throw();
}
extern "C"
{
  extern void cfree(void *__ptr) throw();
}
extern "C"
{
  extern void *alloca(::size_t __size) throw();
}
extern "C"
{
  extern void *valloc(::size_t __size) throw() __attribute__((__malloc__));
}
extern "C"
{
  extern int posix_memalign(void **__memptr, ::size_t __alignment, ::size_t __size) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void *aligned_alloc(::size_t __alignment, ::size_t __size) throw() __attribute__((__malloc__)) __attribute__((__alloc_size__(2)));
}
extern "C"
{
  extern void abort() throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern int atexit(void (*__func)()) throw() __attribute__((__nonnull__(1)));
}
int at_quick_exit(void (*__func)()) throw() __asm("at_quick_exit") __attribute__((__nonnull__(1)));
extern "C"
{
  extern int on_exit(void (*__func)(int, void *), void *__arg) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern void exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void quick_exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern void _Exit(int __status) throw() __attribute__((__noreturn__));
}
extern "C"
{
  extern char *getenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *secure_getenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int putenv(char *__string) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int setenv(const char *__name, const char *__value, int __replace) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int unsetenv(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int clearenv() throw();
}
extern "C"
{
  extern char *mktemp(char *__template) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp(char *__template) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemp64(char *__template) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps(char *__template, int __suffixlen) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkstemps64(char *__template, int __suffixlen) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *mkdtemp(char *__template) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp(char *__template, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemp64(char *__template, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int mkostemps64(char *__template, int __suffixlen, int __flags) __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int system(const char *__command);
}
extern "C"
{
  extern char *canonicalize_file_name(const char *__name) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern char *realpath(const char *__restrict __name, char *__restrict __resolved) throw();
}
typedef int (*__compar_fn_t)(const void *, const void *);
typedef ::__compar_fn_t comparison_fn_t;
typedef int (*__compar_d_fn_t)(const void *, const void *, void *);
extern "C"
{
  extern inline void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 2, 5))) __attribute__((__gnu_inline__));
}
extern "C"
{
  extern inline __attribute__((__nonnull__(1, 2, 5))) __attribute__((__gnu_inline__)) void *bsearch(const void *__key, const void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar)
  {
    ::size_t __l;
    ::size_t __u;
    ::size_t __idx;
    const void *__p;
    int __comparison;
    __l = 0;
    __u = __nmemb;
    while (__l < __u)
      {
        __idx = (__l + __u) / 2;
        __p = (void *)((const char *)__base + __idx * __size);
        __comparison = (*__compar)(__key, __p);
        if (__comparison < 0)
          {
            __u = __idx;
          }
        else
          {
            if (__comparison > 0)
              {
                __l = __idx + 1;
              }
            else
              {
                return (void *)__p;
              }
          }
      }
    return 0L;
  }
}
extern "C"
{
  extern void qsort(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_fn_t __compar) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern void qsort_r(void *__base, ::size_t __nmemb, ::size_t __size, ::__compar_d_fn_t __compar, void *__arg) __attribute__((__nonnull__(1, 4)));
}
extern "C"
{
  extern int abs(int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long int labs(long int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern long long int llabs(long long int __x) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::div_t div(int __numer, int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::ldiv_t ldiv(long int __numer, long int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern ::lldiv_t lldiv(long long int __numer, long long int __denom) throw() __attribute__((__const__));
}
extern "C"
{
  extern char *ecvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *fcvt(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *gcvt(double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern char *qecvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qfcvt(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign) throw() __attribute__((__nonnull__(3, 4)));
}
extern "C"
{
  extern char *qgcvt(long double __value, int __ndigit, char *__buf) throw() __attribute__((__nonnull__(3)));
}
extern "C"
{
  extern int ecvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int fcvt_r(double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qecvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int qfcvt_r(long double __value, int __ndigit, int *__restrict __decpt, int *__restrict __sign, char *__restrict __buf, ::size_t __len) throw() __attribute__((__nonnull__(3, 4, 5)));
}
extern "C"
{
  extern int mblen(const char *__s, ::size_t __n) throw();
}
extern "C"
{
  extern int mbtowc(wchar_t *__restrict __pwc, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern int wctomb(char *__s, wchar_t __wchar) throw();
}
extern "C"
{
  extern ::size_t mbstowcs(wchar_t *__restrict __pwcs, const char *__restrict __s, ::size_t __n) throw();
}
extern "C"
{
  extern ::size_t wcstombs(char *__restrict __s, const wchar_t *__restrict __pwcs, ::size_t __n) throw();
}
extern "C"
{
  extern int rpmatch(const char *__response) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int getsubopt(char **__restrict __optionp, char *const *__restrict __tokens, char **__restrict __valuep) throw() __attribute__((__nonnull__(1, 2, 3)));
}
extern "C"
{
  extern void setkey(const char *__key) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern int posix_openpt(int __oflag);
}
extern "C"
{
  extern int grantpt(int __fd) throw();
}
extern "C"
{
  extern int unlockpt(int __fd) throw();
}
extern "C"
{
  extern char *ptsname(int __fd) throw();
}
extern "C"
{
  extern int ptsname_r(int __fd, char *__buf, ::size_t __buflen) throw() __attribute__((__nonnull__(2)));
}
extern "C"
{
  extern int getpt();
}
extern "C"
{
  extern int getloadavg(double __loadavg[], int __nelem) throw() __attribute__((__nonnull__(1)));
}
extern "C"
{
  extern inline __attribute__((__pure__)) __attribute__((__nonnull__(1))) __attribute__((__leaf__)) __attribute__((__gnu_inline__)) double atof(const char *__nptr) throw()
  {
    return ::strtod(__nptr, (char **)0L);
  }
}
namespace std __attribute__((__visibility__("default"))) {
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::at_quick_exit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::quick_exit;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline long int abs(long int __i)
  {
    return __builtin_labs(__i);
  }
  inline ::ldiv_t div(long int __i, long int __j)
  {
    return ::std::ldiv(__i, __j);
  }
  inline long long int abs(long long int __x)
  {
    return __builtin_llabs(__x);
  }
}
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  using ::lldiv_t;
  using ::_Exit;
  using ::llabs;
  inline ::lldiv_t div(long long int __n, long long int __d)
  {
    ::lldiv_t __q /* () */ ;
    __q.quot = __n / __d;
    __q.rem = __n % __d;
    return __q;
  }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std __attribute__((__visibility__("default"))) {
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
extern "C"
{
  extern int *__errno_location() throw() __attribute__((__const__));
}
extern "C"
{
  extern char *program_invocation_name;
}
extern "C"
{
  extern char *program_invocation_short_name;
}
typedef int error_t;
namespace __gnu_cxx __attribute__((__visibility__("default"))) {
  template < typename _TRet, typename _Ret = _TRet, typename _CharT, typename ..._Base >
  _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *__name, const _CharT *__str, ::std::size_t *__idx, _Base ...__base);
  template < typename _TRet, typename _Ret, typename _CharT, typename ..._Base >
  _Ret __stoa(_TRet (*__convf)(const _CharT *, _CharT **, _Base ...), const char *__name, const _CharT *__str, ::std::size_t *__idx, _Base ...__base)
  {
    _Ret __ret;
    _CharT *__endptr;
    *::__errno_location() = 0;
    const _TRet __tmp = __convf(__str, &__endptr, __base ...);
    if (__endptr == __str)
      {
        std::__throw_invalid_argument(__name);
      }
    else
      {
        if (*::__errno_location() == 34 || (std::__are_same<_Ret, int>::__value && (__tmp < ::__gnu_cxx::__numeric_traits_integer<int>::__min || __tmp > ::__gnu_cxx::__numeric_traits_integer<int>::__max)))
          {
            std::__throw_out_of_range(__name);
          }
        else
          {
            __ret = __tmp;
          }
      }
    if (__idx)
      {
        *__idx = __endptr - __str;
      }
    return __ret;
  }
  template < typename _String, typename _CharT = typename _String::value_type >
  _String __to_xstring(int (*__convf)(_CharT *, ::std::size_t, const _CharT *, ::__builtin_va_list), ::std::size_t __n, const _CharT *__fmt, ...);
  template < typename _String, typename _CharT >
  _String __to_xstring(int (*__convf)(_CharT *, ::std::size_t, const _CharT *, ::__builtin_va_list), ::std::size_t __n, const _CharT *__fmt, ...)
  {
    _CharT *__s = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __n));
    ::__builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __len = __convf(__s, __n, __fmt, __args);
    __builtin_va_end(__args);
    return _String(__s, __s + __len);
  }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char>' */ 
 /* Instantiation of class template '::std::allocator<char>' */ 
 /* Instantiation of class template '::std::remove_volatile<char>' */ 
 /* Instantiation of class template '::std::remove_const<char>' */ 
 /* Instantiation of class template '::std::remove_cv<char>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<char, char>' */ 
 /* Instantiation of class template '::std::pointer_traits<char *>' */ 
 /* Instantiation of class template '::std::remove_volatile<long int>' */ 
 /* Instantiation of class template '::std::remove_const<long int>' */ 
 /* Instantiation of class template '::std::remove_cv<long int>' */ 
 /* Instantiation of class template '::std::is_integral<long int>' */ 
 /* Instantiation of class template '::std::is_enum<long int>' */ 
 /* Instantiation of class template '::std::is_const<long int>' */ 
 /* Instantiation of class template '::std::is_volatile<long int>' */ 
 /* Instantiation of class template '::std::__cv_selector<unsigned long int, false, false>' */ 
 /* Instantiation of class template '::std::__match_cv_qualifiers<long int, unsigned long int, false, false>' */ 
 /* Instantiation of class template '::std::__make_unsigned_selector<long int, true, false>' */ 
 /* Instantiation of class template '::std::make_unsigned<long int>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::allocator<char>::rebind<char>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<char>, char>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<char>, char, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char> >::rebind<char>' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>::' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char>' */ 
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'int ::__gnu_cxx::__stoa<long int, int, char, int>(long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
}
namespace std __attribute__((__visibility__("default"))) {
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    inline int stoi(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa<long int, int>(::strtol, "stoi", __str.::std::__cxx11::basic_string<char>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long int ::__gnu_cxx::__stoa<long int, long int, char, int>(long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
    inline long int stol(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::strtol, "stol", __str.::std::__cxx11::basic_string<char>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long int ::__gnu_cxx::__stoa<unsigned long int, unsigned long int, char, int>(unsigned long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
    inline unsigned long int stoul(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::strtoul, "stoul", __str.::std::__cxx11::basic_string<char>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long long int ::__gnu_cxx::__stoa<long long int, long long int, char, int>(long long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
    inline long long int stoll(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::strtoll, "stoll", __str.::std::__cxx11::basic_string<char>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long long int ::__gnu_cxx::__stoa<unsigned long long int, unsigned long long int, char, int>(unsigned long long int (*)(const char *, char **, int), const char *, const char *, unsigned long int *, int)' */ 
    inline unsigned long long int stoull(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::strtoull, "stoull", __str.::std::__cxx11::basic_string<char>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'float ::__gnu_cxx::__stoa<float, float, char>(float (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
    inline float stof(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::strtof, "stof", __str.::std::__cxx11::basic_string<char>::c_str(), __idx);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'double ::__gnu_cxx::__stoa<double, double, char>(double (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
    inline double stod(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::strtod, "stod", __str.::std::__cxx11::basic_string<char>::c_str(), __idx);
    }
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
 /* Instantiation of template function 'long double ::__gnu_cxx::__stoa<long double, long double, char>(long double (*)(const char *, char **), const char *, const char *, unsigned long int *)' */ 
    inline long double stold(const ::std::__cxx11::string &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::strtold, "stold", __str.::std::__cxx11::basic_string<char>::c_str(), __idx);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of class template '::std::initializer_list<char>' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(int), "%d", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(unsigned int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(unsigned int), "%u", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(long int), "%ld", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(unsigned long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(unsigned long int), "%lu", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(long long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(long long int), "%lld", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(unsigned long long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, 4 * sizeof(unsigned long long int), "%llu", __val);
    }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<float>, ::__gnu_cxx::__numeric_traits_floating<float> >' */ 
 /* Instantiation of class template '::std::__are_same<float, float>' */ 
 /* Instantiation of class template '::std::__are_same<float, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<float>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<float>' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(float __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<float>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, __n, "%f", __val);
    }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<double>, ::__gnu_cxx::__numeric_traits_floating<double> >' */ 
 /* Instantiation of class template '::std::__are_same<double, float>' */ 
 /* Instantiation of class template '::std::__are_same<double, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<double>' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(double __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<double>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, __n, "%f", __val);
    }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<false, ::__gnu_cxx::__numeric_traits_integer<long double>, ::__gnu_cxx::__numeric_traits_floating<long double> >' */ 
 /* Instantiation of class template '::std::__are_same<long double, float>' */ 
 /* Instantiation of class template '::std::__are_same<long double, double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_floating<long double>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<long double>' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<char>, char>(int (*)(char *, unsigned long int, const char *, __builtin_va_list), unsigned long int, const char *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
    inline ::std::__cxx11::string to_string(long double __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<long double>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::string>(::vsnprintf, __n, "%Lf", __val);
    }
 /* Instantiation of class template '::__gnu_cxx::new_allocator<wchar_t>' */ 
 /* Instantiation of class template '::std::allocator<wchar_t>' */ 
 /* Instantiation of class template '::std::remove_volatile<wchar_t>' */ 
 /* Instantiation of class template '::std::remove_const<wchar_t>' */ 
 /* Instantiation of class template '::std::remove_cv<wchar_t>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<wchar_t, wchar_t>' */ 
 /* Instantiation of class template '::std::pointer_traits<wchar_t *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<wchar_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<wchar_t> >' */ 
 /* Instantiation of class template '::std::allocator<wchar_t>::rebind<wchar_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<wchar_t>, wchar_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<wchar_t>, wchar_t, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<wchar_t> >::rebind<wchar_t>' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<wchar_t>::' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<wchar_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<wchar_t>' */ 
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'int ::__gnu_cxx::__stoa<long int, int, wchar_t, int>(long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
    inline int stoi(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa<long int, int>(::wcstol, "stoi", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long int ::__gnu_cxx::__stoa<long int, long int, wchar_t, int>(long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
    inline long int stol(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::wcstol, "stol", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long int ::__gnu_cxx::__stoa<unsigned long int, unsigned long int, wchar_t, int>(unsigned long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
    inline unsigned long int stoul(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::wcstoul, "stoul", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long long int ::__gnu_cxx::__stoa<long long int, long long int, wchar_t, int>(long long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
    inline long long int stoll(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::wcstoll, "stoll", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'unsigned long long int ::__gnu_cxx::__stoa<unsigned long long int, unsigned long long int, wchar_t, int>(unsigned long long int (*)(const wchar_t *, wchar_t **, int), const char *, const wchar_t *, unsigned long int *, int)' */ 
    inline unsigned long long int stoull(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0), int __base  = (10))
    {
      return __gnu_cxx::__stoa(::wcstoull, "stoull", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx, __base);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'float ::__gnu_cxx::__stoa<float, float, wchar_t>(float (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
    inline float stof(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::wcstof, "stof", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'double ::__gnu_cxx::__stoa<double, double, wchar_t>(double (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
    inline double stod(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::wcstod, "stod", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx);
    }
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::c_str() const ' */ 
 /* Instantiation of template function 'long double ::__gnu_cxx::__stoa<long double, long double, wchar_t>(long double (*)(const wchar_t *, wchar_t **), const char *, const wchar_t *, unsigned long int *)' */ 
    inline long double stold(const ::std::__cxx11::wstring &__str, ::std::size_t *__idx  = (0))
    {
      return __gnu_cxx::__stoa(::wcstold, "stold", __str.::std::__cxx11::basic_string<wchar_t>::c_str(), __idx);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of class template '::std::initializer_list<wchar_t>' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(int), L"%d", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(unsigned int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(unsigned int), L"%u", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(long int), L"%ld", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(unsigned long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(unsigned long int), L"%lu", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(long long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(long long int), L"%lld", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(unsigned long long int __val)
    {
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, 4 * sizeof(unsigned long long int), L"%llu", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(float __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<float>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, __n, L"%f", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(double __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<double>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, __n, L"%f", __val);
    }
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t> ::__gnu_cxx::__to_xstring< ::std::__cxx11::basic_string<wchar_t>, wchar_t>(int (*)(wchar_t *, unsigned long int, const wchar_t *, __builtin_va_list), unsigned long int, const wchar_t *, ...)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<wchar_t>::basic_string(::std::__cxx11::basic_string<wchar_t> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<wchar_t>::~basic_string() const ' */ 
    inline ::std::__cxx11::wstring to_wstring(long double __val)
    {
      const int __n(::__gnu_cxx::__numeric_traits_floating<long double>::__max_exponent10 + 20);
      return __gnu_cxx::__to_xstring< ::std::__cxx11::wstring>(::vswprintf, __n, L"%Lf", __val);
    }
  }
  ::std::size_t _Hash_bytes(const void *__ptr, ::std::size_t __len, ::std::size_t __seed);
  ::std::size_t _Fnv_hash_bytes(const void *__ptr, ::std::size_t __len, ::std::size_t __seed);
  template < typename _Result, typename _Arg >
  struct  __hash_base
  {
      typedef _Result result_type;
      typedef _Arg argument_type;
  };
  template < typename _Tp >
  struct hash;
  template < typename _Tp >
  struct  hash<_Tp *> : ::std::__hash_base<unsigned long int, _Tp *>
  {
      inline ::std::size_t operator ()(_Tp *__p) const  noexcept(true)
      {
        return reinterpret_cast< ::std::size_t>(__p);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, bool>' */ 
  template <>
  struct  hash<bool> : ::std::__hash_base<unsigned long int, bool>
  {
      inline ::std::size_t operator ()(bool __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char>' */ 
  template <>
  struct  hash<char> : ::std::__hash_base<unsigned long int, char>
  {
      inline ::std::size_t operator ()(char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, signed char>' */ 
  template <>
  struct  hash<signed char> : ::std::__hash_base<unsigned long int, signed char>
  {
      inline ::std::size_t operator ()(signed char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned char>' */ 
  template <>
  struct  hash<unsigned char> : ::std::__hash_base<unsigned long int, unsigned char>
  {
      inline ::std::size_t operator ()(unsigned char __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, wchar_t>' */ 
  template <>
  struct  hash<wchar_t> : ::std::__hash_base<unsigned long int, wchar_t>
  {
      inline ::std::size_t operator ()(wchar_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char16_t>' */ 
  template <>
  struct  hash<char16_t> : ::std::__hash_base<unsigned long int, char16_t>
  {
      inline ::std::size_t operator ()(char16_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, char32_t>' */ 
  template <>
  struct  hash<char32_t> : ::std::__hash_base<unsigned long int, char32_t>
  {
      inline ::std::size_t operator ()(char32_t __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, short int>' */ 
  template <>
  struct  hash<short int> : ::std::__hash_base<unsigned long int, short int>
  {
      inline ::std::size_t operator ()(short int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, int>' */ 
  template <>
  struct  hash<int> : ::std::__hash_base<unsigned long int, int>
  {
      inline ::std::size_t operator ()(int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long int>' */ 
  template <>
  struct  hash<long int> : ::std::__hash_base<unsigned long int, long int>
  {
      inline ::std::size_t operator ()(long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long long int>' */ 
  template <>
  struct  hash<long long int> : ::std::__hash_base<unsigned long int, long long int>
  {
      inline ::std::size_t operator ()(long long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned short int>' */ 
  template <>
  struct  hash<unsigned short int> : ::std::__hash_base<unsigned long int, unsigned short int>
  {
      inline ::std::size_t operator ()(unsigned short int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned int>' */ 
  template <>
  struct  hash<unsigned int> : ::std::__hash_base<unsigned long int, unsigned int>
  {
      inline ::std::size_t operator ()(unsigned int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned long int>' */ 
  template <>
  struct  hash<unsigned long int> : ::std::__hash_base<unsigned long int, unsigned long int>
  {
      inline ::std::size_t operator ()(unsigned long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, unsigned long long int>' */ 
  template <>
  struct  hash<unsigned long long int> : ::std::__hash_base<unsigned long int, unsigned long long int>
  {
      inline ::std::size_t operator ()(unsigned long long int __val) const  noexcept(true)
      {
        return static_cast< ::std::size_t>(__val);
      }
  };
  struct  _Hash_impl
  {
      static inline ::std::size_t hash(const void *__ptr, ::std::size_t __clength, ::std::size_t __seed  = (static_cast< ::std::size_t>(3339675911LU)))
      {
        return ::std::_Hash_bytes(__ptr, __clength, __seed);
      }
      template < typename _Tp >
      static inline ::std::size_t hash(const _Tp &__val)
      {
        return hash(&__val, sizeof(__val));
      }
      template < typename _Tp >
      static inline ::std::size_t __hash_combine(const _Tp &__val, ::std::size_t __hash)
      {
        return hash(&__val, sizeof(__val), __hash);
      }
  };
  struct  _Fnv_hash_impl
  {
      static inline ::std::size_t hash(const void *__ptr, ::std::size_t __clength, ::std::size_t __seed  = (static_cast< ::std::size_t>(2166136261LU)))
      {
        return ::std::_Fnv_hash_bytes(__ptr, __clength, __seed);
      }
      template < typename _Tp >
      static inline ::std::size_t hash(const _Tp &__val)
      {
        return hash(&__val, sizeof(__val));
      }
      template < typename _Tp >
      static inline ::std::size_t __hash_combine(const _Tp &__val, ::std::size_t __hash)
      {
        return hash(&__val, sizeof(__val), __hash);
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, float>' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::hash<float>(const float &)' */ 
  template <>
  struct  hash<float> : ::std::__hash_base<unsigned long int, float>
  {
      inline ::std::size_t operator ()(float __val) const  noexcept(true)
      {
        return __val != 0.000000000000000000000000e+00f ? std::_Hash_impl::hash(__val) : 0;
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, double>' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::hash<double>(const double &)' */ 
  template <>
  struct  hash<double> : ::std::__hash_base<unsigned long int, double>
  {
      inline ::std::size_t operator ()(double __val) const  noexcept(true)
      {
        return __val != 0.00000000000000000000000000000000000000000000000000000e+00 ? std::_Hash_impl::hash(__val) : 0;
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, long double>' */ 
  template <>
  struct  hash<long double> : ::std::__hash_base<unsigned long int, long double>
  {
      ::std::size_t operator ()(long double __val) const  noexcept(true) __attribute__((__pure__));
  };
  template < typename _Hash >
  struct  __is_fast_hash : ::std::integral_constant<bool, true>
  {
  };
  template <>
  struct  __is_fast_hash< ::std::hash<long double> > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char> >' */ 
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::data() const ' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<char> >::size_type ::std::__cxx11::basic_string<char>::length() const ' */ 
  template <>
  struct  hash< ::std::__cxx11::basic_string<char> > : ::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char> >
  {
      inline ::std::size_t operator ()(const ::std::__cxx11::string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::__cxx11::basic_string<char>::data(), __s.::std::__cxx11::basic_string<char>::length() /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::__cxx11::basic_string<char> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<wchar_t> >' */ 
 /* Instantiation of template function 'const wchar_t *::std::__cxx11::basic_string<wchar_t>::data() const ' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<wchar_t> >::size_type ::std::__cxx11::basic_string<wchar_t>::length() const ' */ 
  template <>
  struct  hash< ::std::__cxx11::basic_string<wchar_t> > : ::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<wchar_t> >
  {
      inline ::std::size_t operator ()(const ::std::__cxx11::wstring &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::__cxx11::basic_string<wchar_t>::data(), __s.::std::__cxx11::basic_string<wchar_t>::length() * sizeof(wchar_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::__cxx11::basic_string<wchar_t> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char16_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char16_t>' */ 
 /* Instantiation of class template '::std::allocator<char16_t>' */ 
 /* Instantiation of class template '::std::remove_volatile<char16_t>' */ 
 /* Instantiation of class template '::std::remove_const<char16_t>' */ 
 /* Instantiation of class template '::std::remove_cv<char16_t>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<char16_t, char16_t>' */ 
 /* Instantiation of class template '::std::pointer_traits<char16_t *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<char16_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char16_t> >' */ 
 /* Instantiation of class template '::std::allocator<char16_t>::rebind<char16_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<char16_t>, char16_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<char16_t>, char16_t, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char16_t> >::rebind<char16_t>' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char16_t>::' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char16_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char16_t>' */ 
 /* Instantiation of template function 'const char16_t *::std::__cxx11::basic_string<char16_t>::data() const ' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<char16_t> >::size_type ::std::__cxx11::basic_string<char16_t>::length() const ' */ 
  template <>
  struct  hash< ::std::__cxx11::basic_string<char16_t> > : ::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char16_t> >
  {
      inline ::std::size_t operator ()(const ::std::__cxx11::u16string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::__cxx11::basic_string<char16_t>::data(), __s.::std::__cxx11::basic_string<char16_t>::length() * sizeof(char16_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::__cxx11::basic_string<char16_t> > > : ::std::integral_constant<bool, false>
  {
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char32_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::new_allocator<char32_t>' */ 
 /* Instantiation of class template '::std::allocator<char32_t>' */ 
 /* Instantiation of class template '::std::remove_volatile<char32_t>' */ 
 /* Instantiation of class template '::std::remove_const<char32_t>' */ 
 /* Instantiation of class template '::std::remove_cv<char32_t>' */ 
 /* Instantiation of class template '::std::__ptrtr_not_void<char32_t, char32_t>' */ 
 /* Instantiation of class template '::std::pointer_traits<char32_t *>' */ 
 /* Instantiation of class template '::std::allocator_traits< ::std::allocator<char32_t> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char32_t> >' */ 
 /* Instantiation of class template '::std::allocator<char32_t>::rebind<char32_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind_helper< ::std::allocator<char32_t>, char32_t>' */ 
 /* Instantiation of class template '::std::__alloctr_rebind< ::std::allocator<char32_t>, char32_t, true>' */ 
 /* Instantiation of class template '::__gnu_cxx::__alloc_traits< ::std::allocator<char32_t> >::rebind<char32_t>' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char32_t>::' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char32_t>::_Alloc_hider' */ 
 /* Instantiation of class template '::std::__cxx11::basic_string<char32_t>' */ 
 /* Instantiation of template function 'const char32_t *::std::__cxx11::basic_string<char32_t>::data() const ' */ 
 /* Instantiation of template function '::__gnu_cxx::__alloc_traits< ::std::allocator<char32_t> >::size_type ::std::__cxx11::basic_string<char32_t>::length() const ' */ 
  template <>
  struct  hash< ::std::__cxx11::basic_string<char32_t> > : ::std::__hash_base<unsigned long int, ::std::__cxx11::basic_string<char32_t> >
  {
      inline ::std::size_t operator ()(const ::std::__cxx11::u32string &__s) const  noexcept(true)
      {
        return std::_Hash_impl::hash(__s.::std::__cxx11::basic_string<char32_t>::data(), __s.::std::__cxx11::basic_string<char32_t>::length() * sizeof(char32_t) /* , static_cast<unsigned long int>(3339675911LU) */ );
      }
  };
  template <>
  struct  __is_fast_hash< ::std::hash< ::std::__cxx11::basic_string<char32_t> > > : ::std::integral_constant<bool, false>
  {
  };
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::swap(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s) noexcept(true)
    {
      if (this == &__s)
        {
          return ;
        }
      std::__alloc_swap<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type>::_S_do_it((*this)._M_get_allocator(), __s._M_get_allocator());
      if ((*this)._M_is_local())
        {
          if (__s._M_is_local())
            {
              if ((*this).length() && __s.length())
                {
                  _CharT __tmp_data[::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1];
                  traits_type::copy(__tmp_data, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                  traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                  traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __tmp_data, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                }
              else
                {
                  if (__s.length())
                    {
                      traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                      (*this)._M_length(__s.length());
                      __s._M_set_length(0);
                      return ;
                    }
                  else
                    {
                      if ((*this).length())
                        {
                          traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
                          __s._M_length((*this).length());
                          (*this)._M_set_length(0);
                          return ;
                        }
                    }
                }
            }
          else
            {
              const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_capacity = __s._M_allocated_capacity;
              traits_type::copy(__s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
              (*this)._M_data(__s._M_data());
              __s._M_data(__s._M_local_buf);
              (*this)._M_capacity(__tmp_capacity);
            }
        }
      else
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_capacity = ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_allocated_capacity;
          if (__s._M_is_local())
            {
              traits_type::copy(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf, __s._M_local_buf, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity + 1);
              __s._M_data((*this)._M_data());
              (*this)._M_data(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_buf);
            }
          else
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp_ptr = (*this)._M_data();
              (*this)._M_data(__s._M_data());
              __s._M_data(__tmp_ptr);
              (*this)._M_capacity(__s._M_allocated_capacity);
            }
          __s._M_capacity(__tmp_capacity);
        }
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __tmp_length = (*this).length();
      (*this)._M_length(__s.length());
      __s._M_length(__tmp_length);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer basic_string<_CharT, _Traits, _Alloc>::_M_create(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type &__capacity, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_capacity)
    {
      if (__capacity > (*this).max_size())
        {
          std::__throw_length_error("basic_string::_M_create");
        }
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
        {
          __capacity = 2 * __old_capacity;
          if (__capacity > (*this).max_size())
            {
              __capacity = (*this).max_size();
            }
        }
      return _Alloc_traits::allocate((*this)._M_get_allocator(), __capacity + 1);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, ::std::input_iterator_tag)
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = 0;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity)));
      while (__beg != __end && __len < __capacity)
        {
          (*this)._M_data()[__len++] = *__beg;
           ++__beg;
        }
      try
      {
        while (__beg != __end)
          {
            if (__len == __capacity)
              {
                __capacity = __len + 1;
                typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __another = (*this)._M_create(__capacity, __len);
                this->_S_copy(__another, (*this)._M_data(), __len);
                (*this)._M_dispose();
                (*this)._M_data(__another);
                (*this)._M_capacity(__capacity);
              }
            (*this)._M_data()[__len++] = *__beg;
             ++__beg;
          }
      }
      catch (...)
      {
        (*this)._M_dispose();
        throw;
      }
      (*this)._M_set_length(__len);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InIterator >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator __beg, _InIterator __end, ::std::forward_iterator_tag)
    {
      if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
        {
          std::__throw_logic_error("basic_string::_M_construct null not valid");
        }
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __dnew = static_cast<typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type>(std::distance(__beg, __end));
      if (__dnew > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
        {
          (*this)._M_data((*this)._M_create(__dnew, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0)))));
          (*this)._M_capacity(__dnew);
        }
      try
      {
        this->_S_copy_chars((*this)._M_data(), __beg, __end);
      }
      catch (...)
      {
        (*this)._M_dispose();
        throw;
      }
      (*this)._M_set_length(__dnew);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_construct(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
    {
      if (__n > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
        {
          (*this)._M_data((*this)._M_create(__n, ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0)))));
          (*this)._M_capacity(__n);
        }
      if (__n)
        {
          this->_S_assign((*this)._M_data(), __n, __c);
        }
      (*this)._M_set_length(__n);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_assign(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
    {
      if (this != &__str)
        {
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __rsize = __str.length();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = (*this).capacity();
          if (__rsize > __capacity)
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_capacity = __rsize;
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp = (*this)._M_create(__new_capacity, __capacity);
              (*this)._M_dispose();
              (*this)._M_data(__tmp);
              (*this)._M_capacity(__new_capacity);
            }
          if (__rsize)
            {
              this->_S_copy((*this)._M_data(), __str._M_data(), __rsize);
            }
          (*this)._M_set_length(__rsize);
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::reserve(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __res)
    {
      if (__res < (*this).length())
        {
          __res = (*this).length();
        }
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __capacity = (*this).capacity();
      if (__res != __capacity)
        {
          if (__res > __capacity || __res > ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_local_capacity))))
            {
              typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __tmp = (*this)._M_create(__res, __capacity);
              this->_S_copy(__tmp, (*this)._M_data(), (*this).length() + 1);
              (*this)._M_dispose();
              (*this)._M_data(__tmp);
              (*this)._M_capacity(__res);
            }
          else
            {
              if (!(*this)._M_is_local())
                {
                  this->_S_copy((*this)._M_local_data(), (*this)._M_data(), (*this).length() + 1);
                  (*this)._M_destroy(__capacity);
                  (*this)._M_data((*this)._M_local_data());
                }
            }
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_mutate(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = (*this).length() - __pos - __len1;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_capacity = (*this).length() + __len2 - __len1;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer __r = (*this)._M_create(__new_capacity, (*this).capacity());
      if (__pos)
        {
          this->_S_copy(__r, (*this)._M_data(), __pos);
        }
      if (__s && __len2)
        {
          this->_S_copy(__r + __pos, __s, __len2);
        }
      if (__how_much)
        {
          this->_S_copy(__r + __pos + __len2, (*this)._M_data() + __pos + __len1, __how_much);
        }
      (*this)._M_dispose();
      (*this)._M_data(__r);
      (*this)._M_capacity(__new_capacity);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::_M_erase(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = (*this).length() - __pos - __n;
      if (__how_much && __n)
        {
          this->_S_move((*this)._M_data() + __pos, (*this)._M_data() + __pos + __n, __how_much);
        }
      (*this)._M_set_length((*this).length() - __n);
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    void basic_string<_CharT, _Traits, _Alloc>::resize(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, _CharT __c)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size < __n)
        {
          this->append(__n - __size, __c);
        }
      else
        {
          if (__n < __size)
            {
              this->_M_erase(__n, __size - __n);
            }
        }
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_append(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n)
    {
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = __n + this->size();
      if (__len <= this->capacity())
        {
          if (__n)
            {
              this->_S_copy(this->_M_data() + this->size(), __s, __n);
            }
        }
      else
        {
          this->_M_mutate(this->size(), ((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(0))), __s, __n);
        }
      this->_M_set_length(__len);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    template < typename _InputIterator >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_dispatch(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator __i2, _InputIterator __k1, _InputIterator __k2, ::std::__false_type)
    {
      const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __s(__k1, __k2);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1 = __i2 - __i1;
      return (*this)._M_replace(__i1 - (*this).begin(), __n1, __s._M_data(), __s.size());
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace_aux(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2, _CharT __c)
    {
      (*this)._M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __n2 - __n1;
      if (__new_size <= this->capacity())
        {
          _CharT *__p = this->_M_data() + __pos1;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos1 - __n1;
          if (__how_much && __n1 != __n2)
            {
              this->_S_move(__p + __n2, __p + __n1, __how_much);
            }
        }
      else
        {
          this->_M_mutate(__pos1, __n1, 0, __n2);
        }
      if (__n2)
        {
          this->_S_assign(this->_M_data() + __pos1, __n2, __c);
        }
      this->_M_set_length(__new_size);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &basic_string<_CharT, _Traits, _Alloc>::_M_replace(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len1, const _CharT *__s, const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len2)
    {
      (*this)._M_check_length(__len1, __len2, "basic_string::_M_replace");
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __old_size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __new_size = __old_size + __len2 - __len1;
      if (__new_size <= this->capacity())
        {
          _CharT *__p = this->_M_data() + __pos;
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __how_much = __old_size - __pos - __len1;
          if ((*this)._M_disjunct(__s))
            {
              if (__how_much && __len1 != __len2)
                {
                  this->_S_move(__p + __len2, __p + __len1, __how_much);
                }
              if (__len2)
                {
                  this->_S_copy(__p, __s, __len2);
                }
            }
          else
            {
              if (__len2 && __len2 <= __len1)
                {
                  this->_S_move(__p, __s, __len2);
                }
              if (__how_much && __len1 != __len2)
                {
                  this->_S_move(__p + __len2, __p + __len1, __how_much);
                }
              if (__len2 > __len1)
                {
                  if (__s + __len2 <= __p + __len1)
                    {
                      this->_S_move(__p, __s, __len2);
                    }
                  else
                    {
                      if (__s >= __p + __len1)
                        {
                          this->_S_copy(__p, __s + __len2 - __len1, __len2);
                        }
                      else
                        {
                          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __nleft = __p + __len1 - __s;
                          this->_S_move(__p, __s, __nleft);
                          this->_S_copy(__p + __nleft, __p + __len2, __len2 - __nleft);
                        }
                    }
                }
            }
        }
      else
        {
          this->_M_mutate(__pos, __len1, __s, __len2);
        }
      this->_M_set_length(__new_size);
      return *this;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::copy(_CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const 
    {
      (*this)._M_check(__pos, "basic_string::copy");
      __n = (*this)._M_limit(__pos, __n);
      ;
      if (__n)
        {
          _S_copy(__s, (*this)._M_data() + __pos, __n);
        }
      return __n;
    }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(const _CharT *__lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    ;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    const __size_type __len = _Traits::length(__lhs);
    __string_type __str;
    __str.reserve(__len + __rhs.size());
    __str.append(__lhs, __len);
    __str.append(__rhs);
    return __str;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> operator +(_CharT __lhs, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__rhs)
  {
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __string_type __str;
    const __size_type __len = __rhs.size();
    __str.reserve(__len + 1);
    __str.append(__size_type(1), __lhs);
    __str.append(__rhs);
    return __str;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      const _CharT *__data = (*this)._M_data();
      if (__n == 0)
        {
          return __pos <= __size ? __pos : ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
        }
      if (__n <= __size)
        {
          for (; __pos <= __size - __n;  ++__pos)
            {
              if (traits_type::eq(__data[__pos], __s[0]) && traits_type::compare(__data + __pos + 1, __s + 1, __n - 1) == 0)
                {
                  return __pos;
                }
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __ret = ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__pos < __size)
        {
          const _CharT *__data = (*this)._M_data();
          const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n = __size - __pos;
          const _CharT *__p = traits_type::find(__data + __pos, __n, __c);
          if (__p)
            {
              __ret = __p - __data;
            }
        }
      return __ret;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__n <= __size)
        {
          __pos = std::min(((typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type(__size - __n))), __pos);
          const _CharT *__data = (*this)._M_data();
          do
            {
              if (traits_type::compare(__data + __pos, __s, __n) == 0)
                {
                  return __pos;
                }
            }
          while (__pos-- > 0);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::rfind(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          for ( ++__size; __size-- > 0; )
            {
              if (traits_type::eq((*this)._M_data()[__size], __c))
                {
                  return __size;
                }
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      for (; __n && __pos < this->size();  ++__pos)
        {
          const _CharT *__p = traits_type::find(__s, __n, (*this)._M_data()[__pos]);
          if (__p)
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size && __n)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (traits_type::find(__s, __n, (*this)._M_data()[__size]))
                {
                  return __size;
                }
            }
          while (__size-- != 0);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      for (; __pos < this->size();  ++__pos)
        {
          if (!traits_type::find(__s, __n, (*this)._M_data()[__pos]))
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_first_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
    {
      for (; __pos < this->size();  ++__pos)
        {
          if (!traits_type::eq((*this)._M_data()[__pos], __c))
            {
              return __pos;
            }
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n) const 
    {
      ;
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (!traits_type::find(__s, __n, (*this)._M_data()[__size]))
                {
                  return __size;
                }
            }
          while (__size--);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type basic_string<_CharT, _Traits, _Alloc>::find_last_not_of(_CharT __c, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos) const  noexcept(true)
    {
      typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      if (__size)
        {
          if ( --__size > __pos)
            {
              __size = __pos;
            }
          do
            {
              if (!traits_type::eq((*this)._M_data()[__size], __c))
                {
                  return __size;
                }
            }
          while (__size--);
        }
      return ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::npos;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str) const 
    {
      (*this)._M_check(__pos, "basic_string::compare");
      __n = (*this)._M_limit(__pos, __n);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = __str.size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare((*this)._M_data() + __pos, __str.data(), __len);
      if (!__r)
        {
          __r = _S_compare(__n, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos1, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos2, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
    {
      (*this)._M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare((*this)._M_data() + __pos1, __str.data() + __pos2, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __n2);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(const _CharT *__s) const 
    {
      ;
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size = this->size();
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare((*this)._M_data(), __s, __len);
      if (!__r)
        {
          __r = _S_compare(__size, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s) const 
    {
      ;
      (*this)._M_check(__pos, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos, __n1);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __osize = traits_type::length(__s);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __osize);
        }
      return __r;
    }
    template < typename _CharT, typename _Traits, typename _Alloc >
    int basic_string<_CharT, _Traits, _Alloc>::compare(typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __pos, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n1, const _CharT *__s, typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __n2) const 
    {
      ;
      (*this)._M_check(__pos, "basic_string::compare");
      __n1 = (*this)._M_limit(__pos, __n1);
      const typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare((*this)._M_data() + __pos, __s, __len);
      if (!__r)
        {
          __r = _S_compare(__n1, __n2);
        }
      return __r;
    }
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    typedef typename ::std::ctype<_CharT>::ctype_base __ctype_base;
    __size_type __extracted = 0;
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          __str.erase();
          _CharT __buf[128L];
          __size_type __len = 0;
          const ::std::streamsize __w = __in.width();
          const __size_type __n = __w > 0 ? static_cast<__size_type>(__w) : __str.max_size();
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(__ctype_base::space, _Traits::to_char_type(__c)))
            {
              if (__len == sizeof(__buf) / sizeof(_CharT))
                {
                  __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                  __len = 0;
                }
              __buf[__len++] = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          __str.append(__buf, __len);
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  ::std::basic_istream<_CharT, _Traits> &getline(::std::basic_istream<_CharT, _Traits> &__in, ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__str, _CharT __delim)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> __string_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::ios_base __ios_base;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef typename ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type __size_type;
    __size_type __extracted = 0;
    const __size_type __n = __str.max_size();
    typename ::std::basic_istream<_CharT, _Traits>::ios_base::iostate __err = __ios_base::goodbit;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, true);
    if (__cerb)
      {
        try
        {
          __str.erase();
          const __int_type __idelim = _Traits::to_int_type(__delim);
          const __int_type __eof = _Traits::eof();
          __int_type __c = __in.rdbuf()->sgetc();
          while ((__extracted < __n && !_Traits::eq_int_type(__c, __eof)) && !_Traits::eq_int_type(__c, __idelim))
            {
              __str += _Traits::to_char_type(__c);
               ++__extracted;
              __c = __in.rdbuf()->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= __ios_base::eofbit;
            }
          else
            {
              if (_Traits::eq_int_type(__c, __idelim))
                {
                   ++__extracted;
                  __in.rdbuf()->sbumpc();
                }
              else
                {
                  __err |= __ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(__ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(__ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= __ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::basic_string<char>;
  }
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const ::std::__cxx11::basic_string<char> &);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &, char);
  extern template ::std::basic_istream<char> &getline(::std::basic_istream<char> &, ::std::__cxx11::basic_string<char> &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::basic_string<wchar_t>;
  }
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const ::std::__cxx11::basic_string<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &, wchar_t);
  extern template ::std::basic_istream<wchar_t> &getline(::std::basic_istream<wchar_t> &, ::std::__cxx11::basic_string<wchar_t> &);
 /* Instantiation of template function 'const char *::std::__cxx11::basic_string<char>::c_str() const ' */ 
  class  locale
  {
    public:
      typedef int category;
      class facet;
      class id;
      class _Impl;
      static const ::std::locale::category none = 0;
      static const ::std::locale::category ctype = 1L << 0;
      static const ::std::locale::category numeric = 1L << 1;
      static const ::std::locale::category collate = 1L << 2;
      static const ::std::locale::category time = 1L << 3;
      static const ::std::locale::category monetary = 1L << 4;
      static const ::std::locale::category messages = 1L << 5;
      static const ::std::locale::category all = ((((::std::locale::ctype | ::std::locale::numeric) | ::std::locale::collate) | ::std::locale::time) | ::std::locale::monetary) | ::std::locale::messages;
      locale() throw();
      locale(const ::std::locale &__other) throw();
      explicit locale(const char *__s);
      locale(const ::std::locale &__base, const char *__s, ::std::locale::category __cat);
      inline explicit locale(const ::std::__cxx11::string &__s)
        : ::std::locale(__s.::std::__cxx11::basic_string<char>::c_str())
      {
      }
      inline locale(const ::std::locale &__base, const ::std::__cxx11::string &__s, ::std::locale::category __cat)
        : ::std::locale(__base, __s.::std::__cxx11::basic_string<char>::c_str(), __cat)
      {
      }
      locale(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      template < typename _Facet >
      locale(const ::std::locale &__other, _Facet *__f);
      ~locale() throw();
      const ::std::locale &operator =(const ::std::locale &__other) throw();
      template < typename _Facet >
      ::std::locale combine(const ::std::locale &__other) const ;
      ::std::__cxx11::string name() const  __attribute__((__abi_tag__("cxx11")));
      bool operator ==(const ::std::locale &__other) const  throw();
      inline bool operator !=(const ::std::locale &__other) const  throw()
      {
        return !(*this).::std::locale::operator ==(__other);
      }
      template < typename _Char, typename _Traits, typename _Alloc >
      bool operator ()(const ::std::__cxx11::basic_string<_Char, _Traits, _Alloc> &__s1, const ::std::__cxx11::basic_string<_Char, _Traits, _Alloc> &__s2) const ;
      static ::std::locale global(const ::std::locale &__loc);
      static const ::std::locale &classic();
    private:
      ::std::locale::_Impl *_M_impl;
      static ::std::locale::_Impl *_S_classic;
      static ::std::locale::_Impl *_S_global;
      static const char *const *const _S_categories;
      enum mcc_enum_anon_66
      {
        _S_categories_size = 6 + 6
      };
      static ::__gthread_once_t _S_once;
      explicit locale(::std::locale::_Impl *) throw();
      static void _S_initialize();
      static void _S_initialize_once() throw();
      static ::std::locale::category _S_normalize_category(::std::locale::category);
      void _M_coalesce(const ::std::locale &__base, const ::std::locale &__add, ::std::locale::category __cat);
      static const ::std::locale::id *const _S_twinned_facets[];
    friend class ::std::locale::facet;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  class  locale::facet
  {
      mutable ::_Atomic_word _M_refcount;
      static ::std::__c_locale _S_c_locale;
      static const char _S_c_name[2L];
      static ::__gthread_once_t _S_once;
      static void _S_initialize_once();
    protected:
      inline explicit facet(::std::size_t __refs  = (0)) throw()
        : _M_refcount(__refs ? 1 : 0)
      {
      }
      virtual ~facet();
      static void _S_create_c_locale(::std::__c_locale &__cloc, const char *__s, ::std::__c_locale __old  = (0));
      static ::std::__c_locale _S_clone_c_locale(::std::__c_locale &__cloc) throw();
      static void _S_destroy_c_locale(::std::__c_locale &__cloc);
      static ::std::__c_locale _S_lc_ctype_c_locale(::std::__c_locale __cloc, const char *__s);
      static ::std::__c_locale _S_get_c_locale();
      static const char *_S_get_c_name() throw() __attribute__((__const__));
    private:
      inline void _M_add_reference() const  throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() const  throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      facet(const ::std::locale::facet &);
      ::std::locale::facet &operator =(const ::std::locale::facet &);
      const ::std::locale::facet *_M_sso_shim(const ::std::locale::id *) const ;
      const ::std::locale::facet *_M_cow_shim(const ::std::locale::id *) const ;
    friend class locale;
    friend class ::std::locale::_Impl;
  };
  class  locale::id
  {
      mutable ::std::size_t _M_index;
      static ::_Atomic_word _S_refcount;
      void operator =(const ::std::locale::id &);
      id(const ::std::locale::id &);
    public:
      inline id()
      {
      }
      ::std::size_t _M_id() const  throw();
    friend class locale;
    friend class ::std::locale::_Impl;
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
  };
  class  locale::_Impl
  {
      ::_Atomic_word _M_refcount;
      const ::std::locale::facet **_M_facets;
      ::std::size_t _M_facets_size;
      const ::std::locale::facet **_M_caches;
      char **_M_names;
      static const ::std::locale::id *const _S_id_ctype[];
      static const ::std::locale::id *const _S_id_numeric[];
      static const ::std::locale::id *const _S_id_collate[];
      static const ::std::locale::id *const _S_id_time[];
      static const ::std::locale::id *const _S_id_monetary[];
      static const ::std::locale::id *const _S_id_messages[];
      static const ::std::locale::id *const *const _S_facet_categories[];
      inline void _M_add_reference() throw()
      {
        __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
      }
      inline void _M_remove_reference() throw()
      {
        ;
        if (__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1) == 1)
          {
            ;
            try
            {
              delete this;
            }
            catch (...)
            {
            }
          }
      }
      _Impl(const ::std::locale::_Impl &, ::std::size_t);
      _Impl(const char *, ::std::size_t);
      _Impl(::std::size_t) throw();
      ~_Impl() throw();
      _Impl(const ::std::locale::_Impl &);
      void operator =(const ::std::locale::_Impl &);
      inline bool _M_check_same_name()
      {
        bool __ret(true);
        if ((*this)._M_names[1])
          {
            for (::std::size_t __i(0); __ret && __i < ::std::locale::_S_categories_size - 1;  ++__i)
              {
                __ret = __builtin_strcmp((*this)._M_names[__i], (*this)._M_names[__i + 1]) == 0;
              }
          }
        return __ret;
      }
      void _M_replace_categories(const ::std::locale::_Impl *, ::std::locale::category);
      void _M_replace_category(const ::std::locale::_Impl *, const ::std::locale::id *const *);
      void _M_replace_facet(const ::std::locale::_Impl *, const ::std::locale::id *);
      void _M_install_facet(const ::std::locale::id *, const ::std::locale::facet *);
      template < typename _Facet >
      inline void _M_init_facet(_Facet *__facet)
      {
        _M_install_facet(&_Facet::id, __facet);
      }
      template < typename _Facet >
      inline void _M_init_facet_unchecked(_Facet *__facet)
      {
        __facet->_M_add_reference();
        (*this)._M_facets[_Facet::id._M_id()] = __facet;
      }
      void _M_install_cache(const ::std::locale::facet *, ::std::size_t);
      void _M_init_extra(::std::locale::facet **);
      void _M_init_extra(void *, void *, const char *, const char *);
    friend class locale;
    friend class ::std::locale::facet;
    template < typename _Facet >
    friend bool (::std::has_facet)(const ::std::locale &) throw();
    template < typename _Facet >
    friend const _Facet &(::std::use_facet)(const ::std::locale &);
    template < typename _Cache >
    friend struct __use_cache;
  };
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class  collate : public ::std::locale::facet
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
      protected:
        ::std::__c_locale _M_c_locale_collate;
      public:
        static ::std::locale::id id;
        inline explicit collate(::std::size_t __refs  = (0))
          : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
        {
        }
        inline explicit collate(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
          : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
        {
        }
        inline int compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
        {
          return this->do_compare(__lo1, __hi1, __lo2, __hi2);
        }
        inline typename ::std::__cxx11::collate<_CharT>::string_type transform(const _CharT *__lo, const _CharT *__hi) const 
        {
          return this->do_transform(__lo, __hi);
        }
        inline long int hash(const _CharT *__lo, const _CharT *__hi) const 
        {
          return this->do_hash(__lo, __hi);
        }
        int _M_compare(const _CharT *, const _CharT *) const  throw();
        ::std::size_t _M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw();
      protected:
        inline virtual ~collate()
        {
          _S_destroy_c_locale(::std::__cxx11::collate<_CharT>::_M_c_locale_collate);
        }
        virtual int do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const ;
        virtual typename ::std::__cxx11::collate<_CharT>::string_type do_transform(const _CharT *__lo, const _CharT *__hi) const ;
        virtual long int do_hash(const _CharT *__lo, const _CharT *__hi) const ;
    };
    template < typename _CharT >
    ::std::locale::id collate<_CharT>::id;
 /* Instantiation of class template '::std::__cxx11::collate<char>' */ 
    template <>
    int collate<char>::_M_compare(const char *, const char *) const  throw();
    template <>
    unsigned long int collate<char>::_M_transform(char *, const char *, unsigned long int) const  throw();
 /* Instantiation of class template '::std::__cxx11::collate<wchar_t>' */ 
    template <>
    int collate<wchar_t>::_M_compare(const wchar_t *, const wchar_t *) const  throw();
    template <>
    unsigned long int collate<wchar_t>::_M_transform(wchar_t *, const wchar_t *, unsigned long int) const  throw();
    template < typename _CharT >
    class  collate_byname : public ::std::__cxx11::collate<_CharT>
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        inline explicit collate_byname(const char *__s, ::std::size_t __refs  = (0))
          : collate<_CharT>(__refs)
        {
          if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
            {
              this->_S_destroy_c_locale(this->_M_c_locale_collate);
              this->_S_create_c_locale(this->_M_c_locale_collate, __s);
            }
        }
        inline explicit collate_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs  = (0))
          : collate_byname(__s.::std::__cxx11::basic_string<char>::c_str(), __refs)
        {
        }
      protected:
        inline virtual ~collate_byname()
        {
        }
    };
  }
  template < typename _Facet >
  locale::locale(const ::std::locale &__other, _Facet *__f)
  {
    (*this)._M_impl = new (::std::locale::_Impl)((*__other._M_impl), (1));
    try
    {
      (*(*this)._M_impl)._M_install_facet(&_Facet::id, __f);
    }
    catch (...)
    {
      (*(*this)._M_impl).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    delete[] (*(*this)._M_impl)._M_names[0];
    (*(*this)._M_impl)._M_names[0] = 0;
  }
  template < typename _Facet >
  ::std::locale locale::combine(const ::std::locale &__other) const 
  {
    ::std::locale::_Impl *__tmp(new (::std::locale::_Impl)((*(*this)._M_impl), (1)));
    try
    {
      (*__tmp)._M_replace_facet(__other._M_impl, &_Facet::id);
    }
    catch (...)
    {
      (*__tmp).::std::locale::_Impl::_M_remove_reference();
      throw;
    }
    return ::std::locale(__tmp);
  }
  template < typename _CharT, typename _Traits, typename _Alloc >
  bool locale::operator ()(const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s1, const ::std::__cxx11::basic_string<_CharT, _Traits, _Alloc> &__s2) const 
  {
    typedef ::std::__cxx11::collate<_CharT> __collate_type;
    const __collate_type &__collate = use_facet<__collate_type>(*this);
    return __collate.compare(__s1.data(), __s1.data() + __s1.length(), __s2.data(), __s2.data() + __s2.length()) < 0;
  }
  template < typename _Facet >
  bool has_facet(const ::std::locale &__loc) throw()
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    return __i < (*__loc._M_impl)._M_facets_size && dynamic_cast<const _Facet *>(__facets[__i]);
  }
  template < typename _Facet >
  const _Facet &use_facet(const ::std::locale &__loc)
  {
    const ::std::size_t __i = _Facet::id._M_id();
    const ::std::locale::facet **__facets((*__loc._M_impl)._M_facets);
    if (__i >= (*__loc._M_impl)._M_facets_size || !__facets[__i])
      {
        ::std::__throw_bad_cast();
      }
    return dynamic_cast<const _Facet &>(*__facets[__i]);
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    int collate<_CharT>::_M_compare(const _CharT *, const _CharT *) const  throw()
    {
      return 0;
    }
    template < typename _CharT >
    ::std::size_t collate<_CharT>::_M_transform(_CharT *, const _CharT *, ::std::size_t) const  throw()
    {
      return 0;
    }
    template < typename _CharT >
    int collate<_CharT>::do_compare(const _CharT *__lo1, const _CharT *__hi1, const _CharT *__lo2, const _CharT *__hi2) const 
    {
      const typename ::std::__cxx11::collate<_CharT>::string_type __one(__lo1, __hi1);
      const typename ::std::__cxx11::collate<_CharT>::string_type __two(__lo2, __hi2);
      const _CharT *__p = __one.c_str();
      const _CharT *__pend = __one.data() + __one.length();
      const _CharT *__q = __two.c_str();
      const _CharT *__qend = __two.data() + __two.length();
      for (; ; )
        {
          const int __res = (*this)._M_compare(__p, __q);
          if (__res)
            {
              return __res;
            }
          __p += char_traits<_CharT>::length(__p);
          __q += char_traits<_CharT>::length(__q);
          if (__p == __pend && __q == __qend)
            {
              return 0;
            }
          else
            {
              if (__p == __pend)
                {
                  return  -1;
                }
              else
                {
                  if (__q == __qend)
                    {
                      return 1;
                    }
                }
            }
          __p++;
          __q++;
        }
    }
    template < typename _CharT >
    typename ::std::__cxx11::collate<_CharT>::string_type collate<_CharT>::do_transform(const _CharT *__lo, const _CharT *__hi) const 
    {
      typename ::std::__cxx11::collate<_CharT>::string_type __ret;
      const typename ::std::__cxx11::collate<_CharT>::string_type __str(__lo, __hi);
      const _CharT *__p = __str.c_str();
      const _CharT *__pend = __str.data() + __str.length();
      ::std::size_t __len = (__hi - __lo) * 2;
      _CharT *__c = new _CharT [__len];
      try
      {
        for (; ; )
          {
            ::std::size_t __res = (*this)._M_transform(__c, __p, __len);
            if (__res >= __len)
              {
                __len = __res + 1;
                (delete[] __c, __c = 0);
                __c = (new _CharT [__len]);
                __res = (*this)._M_transform(__c, __p, __len);
              }
            __ret.append(__c, __res);
            __p += char_traits<_CharT>::length(__p);
            if (__p == __pend)
              {
                break;
              }
            __p++;
            __ret.push_back(_CharT());
          }
      }
      catch (...)
      {
        delete[] __c;
        throw;
      }
      delete[] __c;
      return __ret;
    }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<unsigned long int>, ::__gnu_cxx::__numeric_traits_floating<unsigned long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<unsigned long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<unsigned long int>' */ 
    template < typename _CharT >
    long int collate<_CharT>::do_hash(const _CharT *__lo, const _CharT *__hi) const 
    {
      unsigned long int __val(0);
      for (; __lo < __hi;  ++__lo)
        {
          __val = *__lo + (__val << 7 | __val >> (::__gnu_cxx::__numeric_traits_integer<unsigned long int>::__digits - 7));
        }
      return static_cast<long int>(__val);
    }
    extern template class ::std::__cxx11::collate<char>;
    extern template class ::std::__cxx11::collate_byname<char>;
  }
  extern template const ::std::__cxx11::collate<char> &use_facet< ::std::__cxx11::collate<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::collate<char> >(const ::std::locale &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::collate<wchar_t>;
    extern template class ::std::__cxx11::collate_byname<wchar_t>;
  }
  extern template const ::std::__cxx11::collate<wchar_t> &use_facet< ::std::__cxx11::collate<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::collate<wchar_t> >(const ::std::locale &);
  enum struct errc : int 
  {
    address_family_not_supported = 97,
    address_in_use = 98,
    address_not_available = 99,
    already_connected = 106,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 74,
    broken_pipe = 32,
    connection_aborted = 103,
    connection_already_in_progress = 114,
    connection_refused = 111,
    connection_reset = 104,
    cross_device_link = 18,
    destination_address_required = 89,
    device_or_resource_busy = 16,
    directory_not_empty = 39,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 36,
    function_not_supported = 38,
    host_unreachable = 113,
    identifier_removed = 43,
    illegal_byte_sequence = 84,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 90,
    network_down = 100,
    network_reset = 102,
    network_unreachable = 101,
    no_buffer_space = 105,
    no_child_process = 10,
    no_link = 67,
    no_lock_available = 37,
    no_message_available = 61,
    no_message = 42,
    no_protocol_option = 92,
    no_space_on_device = 28,
    no_stream_resources = 63,
    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 88,
    not_a_stream = 60,
    not_connected = 107,
    not_enough_memory = 12,
    not_supported = 95,
    operation_canceled = 125,
    operation_in_progress = 115,
    operation_not_permitted = 1,
    operation_not_supported = 95,
    operation_would_block = 11,
    owner_dead = 130,
    permission_denied = 13,
    protocol_error = 71,
    protocol_not_supported = 93,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 35,
    resource_unavailable_try_again = 11,
    result_out_of_range = 34,
    state_not_recoverable = 131,
    stream_timeout = 62,
    text_file_busy = 26,
    timed_out = 110,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 40,
    value_too_large = 75,
    wrong_protocol_type = 91
  };
  struct  __cow_string
  {
      union 
      {
          const char *_M_p;
          char _M_bytes[8L];
      };
      __cow_string();
      __cow_string(const ::std::__cxx11::string &);
      __cow_string(const char *, ::std::size_t);
      __cow_string(const ::std::__cow_string &) noexcept(true);
      ::std::__cow_string &operator =(const ::std::__cow_string &) noexcept(true);
      ~__cow_string();
      __cow_string(::std::__cow_string &&) noexcept(true);
      ::std::__cow_string &operator =(::std::__cow_string &&) noexcept(true);
  };
  typedef ::std::__cxx11::basic_string<char> __sso_string;
  class  logic_error : public ::std::exception
  {
      ::std::__cow_string _M_msg;
    public:
      explicit logic_error(const ::std::__cxx11::string &__arg);
      explicit logic_error(const char *);
      logic_error(const ::std::logic_error &) noexcept(true);
      ::std::logic_error &operator =(const ::std::logic_error &) noexcept(true);
      virtual ~logic_error() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  domain_error : public ::std::logic_error
  {
    public:
      explicit domain_error(const ::std::__cxx11::string &__arg);
      explicit domain_error(const char *);
      virtual ~domain_error() noexcept(true);
  };
  class  invalid_argument : public ::std::logic_error
  {
    public:
      explicit invalid_argument(const ::std::__cxx11::string &__arg);
      explicit invalid_argument(const char *);
      virtual ~invalid_argument() noexcept(true);
  };
  class  length_error : public ::std::logic_error
  {
    public:
      explicit length_error(const ::std::__cxx11::string &__arg);
      explicit length_error(const char *);
      virtual ~length_error() noexcept(true);
  };
  class  out_of_range : public ::std::logic_error
  {
    public:
      explicit out_of_range(const ::std::__cxx11::string &__arg);
      explicit out_of_range(const char *);
      virtual ~out_of_range() noexcept(true);
  };
  class  runtime_error : public ::std::exception
  {
      ::std::__cow_string _M_msg;
    public:
      explicit runtime_error(const ::std::__cxx11::string &__arg);
      explicit runtime_error(const char *);
      runtime_error(const ::std::runtime_error &) noexcept(true);
      ::std::runtime_error &operator =(const ::std::runtime_error &) noexcept(true);
      virtual ~runtime_error() noexcept(true);
      virtual const char *what() const  noexcept(true);
  };
  class  range_error : public ::std::runtime_error
  {
    public:
      explicit range_error(const ::std::__cxx11::string &__arg);
      explicit range_error(const char *);
      virtual ~range_error() noexcept(true);
  };
  class  overflow_error : public ::std::runtime_error
  {
    public:
      explicit overflow_error(const ::std::__cxx11::string &__arg);
      explicit overflow_error(const char *);
      virtual ~overflow_error() noexcept(true);
  };
  class  underflow_error : public ::std::runtime_error
  {
    public:
      explicit underflow_error(const ::std::__cxx11::string &__arg);
      explicit underflow_error(const char *);
      virtual ~underflow_error() noexcept(true);
  };
  struct error_code;
  struct error_condition;
  class system_error;
  template < typename _Tp >
  struct  is_error_code_enum : ::std::integral_constant<bool, false>
  {
  };
  template < typename _Tp >
  struct  is_error_condition_enum : ::std::integral_constant<bool, false>
  {
  };
  template <>
  struct  is_error_condition_enum< ::std::errc> : ::std::integral_constant<bool, true>
  {
  };
 /* Instantiation of class template '::std::binary_function<const class error_category *, const class error_category *, bool>' */ 
 /* Instantiation of class template '::std::less<const class error_category *>' */ 
 /* Instantiation of template function 'bool ::std::less<const class error_category *>::operator ()(const class error_category *const &, const class error_category *const &) const ' */ 
  inline namespace _V2 {
    class  error_category
    {
      public:
        inline constexpr error_category() noexcept(true) = default ;
        virtual ~error_category();
        error_category(const ::std::_V2::error_category &) = delete ;
        ::std::_V2::error_category &operator =(const ::std::_V2::error_category &) = delete ;
        virtual const char *name() const  noexcept(true) = 0 ;
      private:
        virtual ::std::__cow_string _M_message(int) const  __attribute__((__abi_tag__("cxx11")));
      public:
        virtual ::std::__cxx11::string message(int) const  __attribute__((__abi_tag__("cxx11"))) = 0 ;
        virtual ::std::error_condition default_error_condition(int __i) const  noexcept(true);
        virtual bool equivalent(int __i, const ::std::error_condition &__cond) const  noexcept(true);
        virtual bool equivalent(const ::std::error_code &__code, int __i) const  noexcept(true);
        inline bool operator <(const ::std::_V2::error_category &__other) const  noexcept(true)
        {
          return ::std::less<const ::std::_V2::error_category *>().::std::less<const ::std::_V2::error_category *>::operator ()(this, &__other);
        }
        inline bool operator ==(const ::std::_V2::error_category &__other) const  noexcept(true)
        {
          return this == &__other;
        }
        inline bool operator !=(const ::std::_V2::error_category &__other) const  noexcept(true)
        {
          return this != &__other;
        }
    };
    const ::std::_V2::error_category &system_category() noexcept(true) __attribute__((__const__));
    const ::std::_V2::error_category &generic_category() noexcept(true) __attribute__((__const__));
  }
  inline ::std::error_code make_error_code(::std::errc __e) noexcept(true);
  template < typename _Tp >
  struct hash;
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
  struct  error_code
  {
      inline error_code() noexcept(true)
        : _M_value(0), _M_cat(&::std::_V2::system_category())
      {
      }
      inline error_code(int __v, const ::std::_V2::error_category &__cat) noexcept(true)
        : _M_value(__v), _M_cat(&__cat)
      {
      }
      template < typename _ErrorCodeEnum, typename __type_tpl__param_1_1__ = typename ::std::enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type >
      inline error_code(_ErrorCodeEnum __e) noexcept(true)
      {
        *this = make_error_code(__e);
      }
      inline void assign(int __v, const ::std::_V2::error_category &__cat) noexcept(true)
      {
        (*this)._M_value = __v;
        (*this)._M_cat = &__cat;
      }
      inline void clear() noexcept(true)
      {
        (*this).::std::error_code::assign(0, ::std::_V2::system_category());
      }
      template < typename _ErrorCodeEnum >
      inline typename ::std::enable_if<is_error_code_enum<_ErrorCodeEnum>::value, ::std::error_code &>::type operator =(_ErrorCodeEnum __e) noexcept(true)
      {
        return *this = make_error_code(__e);
      }
      inline int value() const  noexcept(true)
      {
        return (*this)._M_value;
      }
      inline const ::std::_V2::error_category &category() const  noexcept(true)
      {
        return *(*this)._M_cat;
      }
      ::std::error_condition default_error_condition() const  noexcept(true);
      inline __attribute__((__abi_tag__("cxx11"))) ::std::__cxx11::string message() const 
      {
        return (*this).::std::error_code::category().message((*this).::std::error_code::value());
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return (*this)._M_value != 0 ? true : false;
      }
    private:
      int _M_value;
      const ::std::_V2::error_category *_M_cat;
    public:
    friend struct ::std::hash< ::std::error_code>;
  };
 /* Instantiation of class template '::std::is_error_code_enum< ::std::error_code>' */ 
 /* Instantiation of class template '::std::enable_if<false, void>' */ 
  inline ::std::error_code make_error_code(::std::errc __e) noexcept(true)
  {
    return ::std::error_code(static_cast<int>(__e), ::std::_V2::generic_category());
  }
 /* Instantiation of class template '::std::is_error_code_enum< ::std::_V2::error_category>' */ 
  inline bool operator <(const ::std::error_code &__lhs, const ::std::error_code &__rhs) noexcept(true)
  {
    return __lhs.::std::error_code::category() < __rhs.::std::error_code::category() || (__lhs.::std::error_code::category() == __rhs.::std::error_code::category() && __lhs.::std::error_code::value() < __rhs.::std::error_code::value());
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::error_code &__e);
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__os, const ::std::error_code &__e)
  {
    return __os << __e.::std::error_code::category().name() << ':' << __e.::std::error_code::value();
  }
  inline ::std::error_condition make_error_condition(::std::errc __e) noexcept(true);
 /* Instantiation of template function '::std::__cxx11::basic_string<char>::basic_string(::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function 'void ::std::__cxx11::basic_string<char>::~basic_string() const ' */ 
  struct  error_condition
  {
      inline error_condition() noexcept(true)
        : _M_value(0), _M_cat(&::std::_V2::generic_category())
      {
      }
      inline error_condition(int __v, const ::std::_V2::error_category &__cat) noexcept(true)
        : _M_value(__v), _M_cat(&__cat)
      {
      }
      template < typename _ErrorConditionEnum, typename __type_tpl__param_1_1__ = typename ::std::enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type >
      inline error_condition(_ErrorConditionEnum __e) noexcept(true)
      {
        *this = make_error_condition(__e);
      }
      inline void assign(int __v, const ::std::_V2::error_category &__cat) noexcept(true)
      {
        (*this)._M_value = __v;
        (*this)._M_cat = &__cat;
      }
      template < typename _ErrorConditionEnum >
      inline typename ::std::enable_if<is_error_condition_enum<_ErrorConditionEnum>::value, ::std::error_condition &>::type operator =(_ErrorConditionEnum __e) noexcept(true)
      {
        return *this = make_error_condition(__e);
      }
      inline void clear() noexcept(true)
      {
        (*this).::std::error_condition::assign(0, ::std::_V2::generic_category());
      }
      inline int value() const  noexcept(true)
      {
        return (*this)._M_value;
      }
      inline const ::std::_V2::error_category &category() const  noexcept(true)
      {
        return *(*this)._M_cat;
      }
      inline __attribute__((__abi_tag__("cxx11"))) ::std::__cxx11::string message() const 
      {
        return (*this).::std::error_condition::category().message((*this).::std::error_condition::value());
      }
      inline explicit operator bool() const  noexcept(true)
      {
        return (*this)._M_value != 0 ? true : false;
      }
    private:
      int _M_value;
      const ::std::_V2::error_category *_M_cat;
    public:
  };
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::error_condition>' */ 
  inline ::std::error_condition make_error_condition(::std::errc __e) noexcept(true)
  {
    return ::std::error_condition(static_cast<int>(__e), ::std::_V2::generic_category());
  }
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::_V2::error_category>' */ 
  inline bool operator <(const ::std::error_condition &__lhs, const ::std::error_condition &__rhs) noexcept(true)
  {
    return __lhs.::std::error_condition::category() < __rhs.::std::error_condition::category() || (__lhs.::std::error_condition::category() == __rhs.::std::error_condition::category() && __lhs.::std::error_condition::value() < __rhs.::std::error_condition::value());
  }
  inline bool operator ==(const ::std::error_code &__lhs, const ::std::error_code &__rhs) noexcept(true)
  {
    return __lhs.::std::error_code::category() == __rhs.::std::error_code::category() && __lhs.::std::error_code::value() == __rhs.::std::error_code::value();
  }
 /* Instantiation of class template '::std::is_error_code_enum<int>' */ 
  inline bool operator ==(const ::std::error_code &__lhs, const ::std::error_condition &__rhs) noexcept(true)
  {
    return __lhs.::std::error_code::category().equivalent(__lhs.::std::error_code::value(), __rhs) || __rhs.::std::error_condition::category().equivalent(__lhs, __rhs.::std::error_condition::value());
  }
  inline bool operator ==(const ::std::error_condition &__lhs, const ::std::error_code &__rhs) noexcept(true)
  {
    return __rhs.::std::error_code::category().equivalent(__rhs.::std::error_code::value(), __lhs) || __lhs.::std::error_condition::category().equivalent(__rhs, __lhs.::std::error_condition::value());
  }
  inline bool operator ==(const ::std::error_condition &__lhs, const ::std::error_condition &__rhs) noexcept(true)
  {
    return __lhs.::std::error_condition::category() == __rhs.::std::error_condition::category() && __lhs.::std::error_condition::value() == __rhs.::std::error_condition::value();
  }
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::error_code>' */ 
  inline bool operator !=(const ::std::error_code &__lhs, const ::std::error_code &__rhs) noexcept(true)
  {
    return !(__lhs == __rhs);
  }
 /* Instantiation of class template '::std::is_error_code_enum< ::std::error_condition>' */ 
  inline bool operator !=(const ::std::error_code &__lhs, const ::std::error_condition &__rhs) noexcept(true)
  {
    return !(__lhs == __rhs);
  }
  inline bool operator !=(const ::std::error_condition &__lhs, const ::std::error_code &__rhs) noexcept(true)
  {
    return !(__lhs == __rhs);
  }
  inline bool operator !=(const ::std::error_condition &__lhs, const ::std::error_condition &__rhs) noexcept(true)
  {
    return !(__lhs == __rhs);
  }
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::std::operator +<char, ::std::char_traits<char>, ::std::allocator<char> >(const ::std::__cxx11::basic_string<char> &, const char *)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::std::operator +<char, ::std::char_traits<char>, ::std::allocator<char> >(::std::__cxx11::basic_string<char> &&, ::std::__cxx11::basic_string<char> &&)' */ 
 /* Instantiation of template function '::std::__cxx11::basic_string<char> ::std::operator +<char, ::std::char_traits<char>, ::std::allocator<char> >(const char *, ::std::__cxx11::basic_string<char> &&)' */ 
  class  system_error : public ::std::runtime_error
  {
      ::std::error_code _M_code;
    public:
      inline system_error(::std::error_code __ec  = (::std::error_code()))
        : ::std::runtime_error(__ec.::std::error_code::message()), _M_code(__ec)
      {
      }
      inline system_error(::std::error_code __ec, const ::std::__cxx11::string &__what)
        : ::std::runtime_error(__what + ": " + __ec.::std::error_code::message()), _M_code(__ec)
      {
      }
      inline system_error(::std::error_code __ec, const char *__what)
        : ::std::runtime_error(__what + (": " + __ec.::std::error_code::message())), _M_code(__ec)
      {
      }
      inline system_error(int __v, const ::std::_V2::error_category &__ecat, const char *__what)
        : ::std::system_error(::std::error_code(__v, __ecat), __what)
      {
      }
      inline system_error(int __v, const ::std::_V2::error_category &__ecat)
        : ::std::runtime_error(::std::error_code(__v, __ecat).::std::error_code::message()), _M_code(__v, __ecat)
      {
      }
      inline system_error(int __v, const ::std::_V2::error_category &__ecat, const ::std::__cxx11::string &__what)
        : ::std::runtime_error(__what + ": " + ::std::error_code(__v, __ecat).::std::error_code::message()), _M_code(__v, __ecat)
      {
      }
      virtual ~system_error() noexcept(true);
      inline const ::std::error_code &code() const  noexcept(true)
      {
        return (*this)._M_code;
      }
  };
 /* Instantiation of class template '::std::__hash_base<unsigned long int, ::std::error_code>' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::hash<int>(const int &)' */ 
 /* Instantiation of template function 'unsigned long int ::std::_Hash_impl::__hash_combine<const ::std::_V2::error_category *>(const ::std::_V2::error_category *const &, unsigned long int)' */ 
  template <>
  struct  hash< ::std::error_code> : ::std::__hash_base<unsigned long int, ::std::error_code>
  {
      inline ::std::size_t operator ()(const ::std::error_code &__e) const  noexcept(true)
      {
        const ::std::size_t __tmp(std::_Hash_impl::hash(__e._M_value));
        return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
  };
  enum _Ios_Fmtflags
  {
    _S_boolalpha = 1L << 0,
    _S_dec = 1L << 1,
    _S_fixed = 1L << 2,
    _S_hex = 1L << 3,
    _S_internal = 1L << 4,
    _S_left = 1L << 5,
    _S_oct = 1L << 6,
    _S_right = 1L << 7,
    _S_scientific = 1L << 8,
    _S_showbase = 1L << 9,
    _S_showpoint = 1L << 10,
    _S_showpos = 1L << 11,
    _S_skipws = 1L << 12,
    _S_unitbuf = 1L << 13,
    _S_uppercase = 1L << 14,
    _S_adjustfield = (::std::_S_left | ::std::_S_right) | ::std::_S_internal,
    _S_basefield = (::std::_S_dec | ::std::_S_oct) | ::std::_S_hex,
    _S_floatfield = ::std::_S_scientific | ::std::_S_fixed,
    _S_ios_fmtflags_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Fmtflags operator &(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator |(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator ^(::std::_Ios_Fmtflags __a, ::std::_Ios_Fmtflags __b)
  {
    return (::std::_Ios_Fmtflags)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Fmtflags operator ~(::std::_Ios_Fmtflags __a)
  {
    return (::std::_Ios_Fmtflags)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Fmtflags &operator |=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Fmtflags &operator &=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Fmtflags &operator ^=(::std::_Ios_Fmtflags &__a, ::std::_Ios_Fmtflags __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Openmode
  {
    _S_app = 1L << 0,
    _S_ate = 1L << 1,
    _S_bin = 1L << 2,
    _S_in = 1L << 3,
    _S_out = 1L << 4,
    _S_trunc = 1L << 5,
    _S_ios_openmode_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Openmode operator &(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator |(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator ^(::std::_Ios_Openmode __a, ::std::_Ios_Openmode __b)
  {
    return (::std::_Ios_Openmode)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Openmode operator ~(::std::_Ios_Openmode __a)
  {
    return (::std::_Ios_Openmode)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Openmode &operator |=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Openmode &operator &=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Openmode &operator ^=(::std::_Ios_Openmode &__a, ::std::_Ios_Openmode __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Iostate
  {
    _S_goodbit = 0,
    _S_badbit = 1L << 0,
    _S_eofbit = 1L << 1,
    _S_failbit = 1L << 2,
    _S_ios_iostate_end = 1L << 16
  };
  inline constexpr ::std::_Ios_Iostate operator &(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) & static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator |(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) | static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator ^(::std::_Ios_Iostate __a, ::std::_Ios_Iostate __b)
  {
    return (::std::_Ios_Iostate)(static_cast<int>(__a) ^ static_cast<int>(__b));
  }
  inline constexpr ::std::_Ios_Iostate operator ~(::std::_Ios_Iostate __a)
  {
    return (::std::_Ios_Iostate)~static_cast<int>(__a);
  }
  inline const ::std::_Ios_Iostate &operator |=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a | __b;
  }
  inline const ::std::_Ios_Iostate &operator &=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a & __b;
  }
  inline const ::std::_Ios_Iostate &operator ^=(::std::_Ios_Iostate &__a, ::std::_Ios_Iostate __b)
  {
    return __a = __a ^ __b;
  }
  enum _Ios_Seekdir
  {
    _S_beg = 0,
    _S_cur = 1,
    _S_end = 2,
    _S_ios_seekdir_end = 1L << 16
  };
  enum struct io_errc : int 
  {
    stream = 1
  };
  template <>
  struct  is_error_code_enum< ::std::io_errc> : ::std::integral_constant<bool, true>
  {
  };
  const ::std::_V2::error_category &iostream_category() noexcept(true);
  inline ::std::error_code make_error_code(::std::io_errc e) noexcept(true)
  {
    return ::std::error_code(static_cast<int>(e), ::std::iostream_category());
  }
  inline ::std::error_condition make_error_condition(::std::io_errc e) noexcept(true)
  {
    return ::std::error_condition(static_cast<int>(e), ::std::iostream_category());
  }
  class  ios_base
  {
    public:
      class __attribute__((__abi_tag__("cxx11")))  failure : public ::std::system_error
      {
        public:
          explicit failure(const ::std::__cxx11::string &__str);
          explicit failure(const ::std::__cxx11::string &, const ::std::error_code &);
          explicit failure(const char *, const ::std::error_code &  = (::std::io_errc::stream));
          virtual ~failure() throw();
          virtual const char *what() const  throw();
      };
      typedef ::std::_Ios_Fmtflags fmtflags;
      static const ::std::ios_base::fmtflags boolalpha = ::std::_S_boolalpha;
      static const ::std::ios_base::fmtflags dec = ::std::_S_dec;
      static const ::std::ios_base::fmtflags fixed = ::std::_S_fixed;
      static const ::std::ios_base::fmtflags hex = ::std::_S_hex;
      static const ::std::ios_base::fmtflags internal = ::std::_S_internal;
      static const ::std::ios_base::fmtflags left = ::std::_S_left;
      static const ::std::ios_base::fmtflags oct = ::std::_S_oct;
      static const ::std::ios_base::fmtflags right = ::std::_S_right;
      static const ::std::ios_base::fmtflags scientific = ::std::_S_scientific;
      static const ::std::ios_base::fmtflags showbase = ::std::_S_showbase;
      static const ::std::ios_base::fmtflags showpoint = ::std::_S_showpoint;
      static const ::std::ios_base::fmtflags showpos = ::std::_S_showpos;
      static const ::std::ios_base::fmtflags skipws = ::std::_S_skipws;
      static const ::std::ios_base::fmtflags unitbuf = ::std::_S_unitbuf;
      static const ::std::ios_base::fmtflags uppercase = ::std::_S_uppercase;
      static const ::std::ios_base::fmtflags adjustfield = ::std::_S_adjustfield;
      static const ::std::ios_base::fmtflags basefield = ::std::_S_basefield;
      static const ::std::ios_base::fmtflags floatfield = ::std::_S_floatfield;
      typedef ::std::_Ios_Iostate iostate;
      static const ::std::ios_base::iostate badbit = ::std::_S_badbit;
      static const ::std::ios_base::iostate eofbit = ::std::_S_eofbit;
      static const ::std::ios_base::iostate failbit = ::std::_S_failbit;
      static const ::std::ios_base::iostate goodbit = ::std::_S_goodbit;
      typedef ::std::_Ios_Openmode openmode;
      static const ::std::ios_base::openmode app = ::std::_S_app;
      static const ::std::ios_base::openmode ate = ::std::_S_ate;
      static const ::std::ios_base::openmode binary = ::std::_S_bin;
      static const ::std::ios_base::openmode in = ::std::_S_in;
      static const ::std::ios_base::openmode out = ::std::_S_out;
      static const ::std::ios_base::openmode trunc = ::std::_S_trunc;
      typedef ::std::_Ios_Seekdir seekdir;
      static const ::std::ios_base::seekdir beg = ::std::_S_beg;
      static const ::std::ios_base::seekdir cur = ::std::_S_cur;
      static const ::std::ios_base::seekdir end = ::std::_S_end;
      typedef int io_state;
      typedef int open_mode;
      typedef int seek_dir;
      typedef ::std::streampos streampos;
      typedef ::std::streamoff streamoff;
      enum event
      {
        erase_event = 0,
        imbue_event = 1,
        copyfmt_event = 2
      };
      typedef void (*event_callback)(::std::ios_base::event, ::std::ios_base &, int);
      void register_callback(::std::ios_base::event_callback __fn, int __index);
    protected:
      ::std::streamsize _M_precision;
      ::std::streamsize _M_width;
      ::std::ios_base::fmtflags _M_flags;
      ::std::ios_base::iostate _M_exception;
      ::std::ios_base::iostate _M_streambuf_state;
      struct  _Callback_list
      {
          ::std::ios_base::_Callback_list *_M_next;
          ::std::ios_base::event_callback _M_fn;
          int _M_index;
          ::_Atomic_word _M_refcount;
          inline _Callback_list(::std::ios_base::event_callback __fn, int __index, ::std::ios_base::_Callback_list *__cb)
            : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0)
          {
          }
          inline void _M_add_reference()
          {
            __gnu_cxx::__atomic_add_dispatch(&(*this)._M_refcount, 1);
          }
          inline int _M_remove_reference()
          {
            ;
            int __res(__gnu_cxx::__exchange_and_add_dispatch(&(*this)._M_refcount,  -1));
            if (__res == 0)
              {
                ;
              }
            return __res;
          }
      };
      ::std::ios_base::_Callback_list *_M_callbacks;
      void _M_call_callbacks(::std::ios_base::event __ev) throw();
      void _M_dispose_callbacks() throw();
      struct  _Words
      {
          void *_M_pword;
          long int _M_iword;
          inline _Words()
            : _M_pword(0), _M_iword(0)
          {
          }
      };
      ::std::ios_base::_Words _M_word_zero;
      enum mcc_enum_anon_67
      {
        _S_local_word_size = 8
      };
      ::std::ios_base::_Words _M_local_word[8L];
      int _M_word_size;
      ::std::ios_base::_Words *_M_word;
      ::std::ios_base::_Words &_M_grow_words(int __index, bool __iword);
      ::std::locale _M_ios_locale;
      void _M_init() throw();
    public:
      class  Init
      {
        public:
          Init();
          ~Init();
        private:
          static ::_Atomic_word _S_refcount;
          static bool _S_synced_with_stdio;
        public:
        friend class ios_base;
      };
      inline ::std::ios_base::fmtflags flags() const 
      {
        return (*this)._M_flags;
      }
      inline ::std::ios_base::fmtflags flags(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags = __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags |= __fmtfl;
        return __old;
      }
      inline ::std::ios_base::fmtflags setf(::std::ios_base::fmtflags __fmtfl, ::std::ios_base::fmtflags __mask)
      {
        ::std::ios_base::fmtflags __old((*this)._M_flags);
        (*this)._M_flags &=  ~__mask;
        (*this)._M_flags |= __fmtfl & __mask;
        return __old;
      }
      inline void unsetf(::std::ios_base::fmtflags __mask)
      {
        (*this)._M_flags &=  ~__mask;
      }
      inline ::std::streamsize precision() const 
      {
        return (*this)._M_precision;
      }
      inline ::std::streamsize precision(::std::streamsize __prec)
      {
        ::std::streamsize __old((*this)._M_precision);
        (*this)._M_precision = __prec;
        return __old;
      }
      inline ::std::streamsize width() const 
      {
        return (*this)._M_width;
      }
      inline ::std::streamsize width(::std::streamsize __wide)
      {
        ::std::streamsize __old((*this)._M_width);
        (*this)._M_width = __wide;
        return __old;
      }
      static bool sync_with_stdio(bool __sync  = (true));
      ::std::locale imbue(const ::std::locale &__loc) throw();
      inline ::std::locale getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      inline const ::std::locale &_M_getloc() const 
      {
        return (*this)._M_ios_locale;
      }
      static int xalloc() throw();
      inline long int &iword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, true));
        return __word._M_iword;
      }
      inline void *&pword(int __ix)
      {
        ::std::ios_base::_Words &__word(__ix < (*this)._M_word_size ? (*this)._M_word[__ix] : (*this).::std::ios_base::_M_grow_words(__ix, false));
        return __word._M_pword;
      }
      virtual ~ios_base();
    protected:
      ios_base() throw();
    public:
      ios_base(const ::std::ios_base &) = delete ;
      ::std::ios_base &operator =(const ::std::ios_base &) = delete ;
    protected:
      void _M_move(::std::ios_base &) noexcept(true);
      void _M_swap(::std::ios_base &__rhs) noexcept(true);
  };
  inline ::std::ios_base &boolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &noboolalpha(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::boolalpha);
    return __base;
  }
  inline ::std::ios_base &showbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &noshowbase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showbase);
    return __base;
  }
  inline ::std::ios_base &showpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &noshowpoint(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpoint);
    return __base;
  }
  inline ::std::ios_base &showpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &noshowpos(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::showpos);
    return __base;
  }
  inline ::std::ios_base &skipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &noskipws(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::skipws);
    return __base;
  }
  inline ::std::ios_base &uppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &nouppercase(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::uppercase);
    return __base;
  }
  inline ::std::ios_base &unitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &nounitbuf(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::unitbuf);
    return __base;
  }
  inline ::std::ios_base &internal(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::internal, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &left(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::left, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &right(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::right, ::std::ios_base::adjustfield);
    return __base;
  }
  inline ::std::ios_base &dec(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::dec, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &hex(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::hex, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &oct(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::oct, ::std::ios_base::basefield);
    return __base;
  }
  inline ::std::ios_base &fixed(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::fixed, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &scientific(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::scientific, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &hexfloat(::std::ios_base &__base)
  {
    __base.::std::ios_base::setf(::std::ios_base::fixed | ::std::ios_base::scientific, ::std::ios_base::floatfield);
    return __base;
  }
  inline ::std::ios_base &defaultfloat(::std::ios_base &__base)
  {
    __base.::std::ios_base::unsetf(::std::ios_base::floatfield);
    return __base;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  class  basic_streambuf
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type> __streambuf_type;
    protected:
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_in_end;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_beg;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_cur;
      typename ::std::basic_streambuf<_CharT, _Traits>::char_type *_M_out_end;
      ::std::locale _M_buf_locale;
    public:
      inline virtual ~basic_streambuf()
      {
      }
      inline ::std::locale pubimbue(const ::std::locale &__loc)
      {
        ::std::locale __tmp(this->getloc());
        this->imbue(__loc);
        ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale = __loc;
        return __tmp;
      }
      inline ::std::locale getloc() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *pubsetbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->setbuf(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __way, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekoff(__off, __way, __mode);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::pos_type pubseekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type __sp, ::std::ios_base::openmode __mode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return this->seekpos(__sp, __mode);
      }
      inline int pubsync()
      {
        return this->sync();
      }
      inline ::std::streamsize in_avail()
      {
        const ::std::streamsize __ret = this->egptr() - this->gptr();
        return __ret ? __ret : this->showmanyc();
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type snextc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(), __ret), true))
          {
            __ret = this->sgetc();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sbumpc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        else
          {
            __ret = this->uflow();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sgetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->gptr() < this->egptr(), true))
          {
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->underflow();
          }
        return __ret;
      }
      inline ::std::streamsize sgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsgetn(__s, __n);
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputbackc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        const bool __testpos = this->eback() < this->gptr();
        if (__builtin_expect(!__testpos || !traits_type::eq(__c, this->gptr()[ -1]), false))
          {
            __ret = this->pbackfail(traits_type::to_int_type(__c));
          }
        else
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sungetc()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->eback() < this->gptr(), true))
          {
            this->gbump( -1);
            __ret = traits_type::to_int_type(*this->gptr());
          }
        else
          {
            __ret = this->pbackfail();
          }
        return __ret;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::int_type sputc(typename ::std::basic_streambuf<_CharT, _Traits>::char_type __c)
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret;
        if (__builtin_expect(this->pptr() < this->epptr(), true))
          {
            *this->pptr() = __c;
            this->pbump(1);
            __ret = traits_type::to_int_type(__c);
          }
        else
          {
            __ret = this->overflow(traits_type::to_int_type(__c));
          }
        return __ret;
      }
      inline ::std::streamsize sputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->xsputn(__s, __n);
      }
    protected:
      inline basic_streambuf()
        : _M_in_beg(0), _M_in_cur(0), _M_in_end(0), _M_out_beg(0), _M_out_cur(0), _M_out_end(0), _M_buf_locale(::std::locale())
      {
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *eback() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *gptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *egptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_in_end;
      }
      inline void gbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void setg(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gnext, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__gend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_beg = __gbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur = __gnext;
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_end = __gend;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pbase() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *pptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur;
      }
      inline typename ::std::basic_streambuf<_CharT, _Traits>::char_type *epptr() const 
      {
        return ::std::basic_streambuf<_CharT, _Traits>::_M_out_end;
      }
      inline void pbump(int __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
      inline void setp(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pbeg, typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__pend)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_beg = ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur = __pbeg;
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_end = __pend;
      }
      inline virtual void imbue(const ::std::locale &__loc)
      {
      }
      inline virtual ::std::basic_streambuf<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, _Traits> *setbuf(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *, ::std::streamsize)
      {
        return this;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekoff(typename ::std::basic_streambuf<_CharT, _Traits>::off_type, ::std::ios_base::seekdir, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::pos_type seekpos(typename ::std::basic_streambuf<_CharT, _Traits>::pos_type, ::std::ios_base::openmode  = (::std::ios_base::in | ::std::ios_base::out))
      {
        return ((typename ::std::basic_streambuf<_CharT, _Traits>::pos_type(((typename ::std::basic_streambuf<_CharT, _Traits>::off_type( -1))))));
      }
      inline virtual int sync()
      {
        return 0;
      }
      inline virtual ::std::streamsize showmanyc()
      {
        return 0;
      }
      virtual ::std::streamsize xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type underflow()
      {
        return traits_type::eof();
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type uflow()
      {
        typename ::std::basic_streambuf<_CharT, _Traits>::int_type __ret = traits_type::eof();
        const bool __testeof = traits_type::eq_int_type(this->underflow(), __ret);
        if (!__testeof)
          {
            __ret = traits_type::to_int_type(*this->gptr());
            this->gbump(1);
          }
        return __ret;
      }
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type pbackfail(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
      virtual ::std::streamsize xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      inline virtual typename ::std::basic_streambuf<_CharT, _Traits>::int_type overflow(typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c  = (traits_type::eof()))
      {
        return traits_type::eof();
      }
    public:
      inline void stossc()
      {
        if (this->gptr() < this->egptr())
          {
            this->gbump(1);
          }
        else
          {
            this->uflow();
          }
      }
      inline void __safe_gbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_in_cur += __n;
      }
      inline void __safe_pbump(::std::streamsize __n)
      {
        ::std::basic_streambuf<_CharT, _Traits>::_M_out_cur += __n;
      }
    protected:
      basic_streambuf(const ::std::basic_streambuf<_CharT, _Traits> &);
      ::std::basic_streambuf<_CharT, _Traits> &operator =(const ::std::basic_streambuf<_CharT, _Traits> &);
      inline void swap(::std::basic_streambuf<_CharT, _Traits> &__sb)
      {
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_in_beg, __sb._M_in_beg);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_in_cur, __sb._M_in_cur);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_in_end, __sb._M_in_end);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_out_beg, __sb._M_out_beg);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_out_cur, __sb._M_out_cur);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_out_end, __sb._M_out_end);
        std::swap(::std::basic_streambuf<_CharT, _Traits>::_M_buf_locale, __sb._M_buf_locale);
      }
    friend class ::std::basic_ios<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_istream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::basic_ostream<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::istreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend class ::std::ostreambuf_iterator<typename ::std::basic_streambuf<_CharT, _Traits>::char_type, typename ::std::basic_streambuf<_CharT, _Traits>::traits_type>;
    friend ::std::streamsize __copy_streambufs_eof<>(::std::basic_streambuf<_CharT, _Traits> *, ::std::basic_streambuf<_CharT, _Traits> *, bool &);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
    template < typename _CharT2, typename _Traits2 >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, _CharT2 *);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &operator >>(::std::basic_istream<_CharT2, _Traits2> &, ::std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &);
    template < typename _CharT2, typename _Traits2, typename _Alloc >
    friend ::std::basic_istream<_CharT2, _Traits2> &getline(::std::basic_istream<_CharT2, _Traits2> &, ::std::__cxx11::basic_string<_CharT2, _Traits2, _Alloc> &, _CharT2);
  };
  template < typename _CharT, typename _Traits >
  basic_streambuf<_CharT, _Traits>::basic_streambuf(const ::std::basic_streambuf<_CharT, _Traits> &) = default ;
  template < typename _CharT, typename _Traits >
  ::std::basic_streambuf<_CharT, _Traits> &basic_streambuf<_CharT, _Traits>::operator =(const ::std::basic_streambuf<_CharT, _Traits> &) = default ;
  template <>
  long int __copy_streambufs_eof<char, ::std::char_traits<char> >(::std::basic_streambuf<char> *__sbin, ::std::basic_streambuf<char> *__sbout, bool &__ineof);
  template <>
  long int __copy_streambufs_eof<wchar_t, ::std::char_traits<wchar_t> >(::std::basic_streambuf<wchar_t> *__sbin, ::std::basic_streambuf<wchar_t> *__sbout, bool &__ineof);
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsgetn(typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->egptr() - this->gptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(__s, this->gptr(), __len);
            __ret += __len;
            __s += __len;
            this->__safe_gbump(__len);
          }
        if (__ret < __n)
          {
            const typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->uflow();
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                traits_type::assign(*__s++, traits_type::to_char_type(__c));
                 ++__ret;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_streambuf<_CharT, _Traits>::xsputn(const typename ::std::basic_streambuf<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::streamsize __ret(0);
    while (__ret < __n)
      {
        const ::std::streamsize __buf_len = this->epptr() - this->pptr();
        if (__buf_len)
          {
            const ::std::streamsize __remaining(__n - __ret);
            const ::std::streamsize __len = std::min(__buf_len, __remaining);
            traits_type::copy(this->pptr(), __s, __len);
            __ret += __len;
            __s += __len;
            this->__safe_pbump(__len);
          }
        if (__ret < __n)
          {
            typename ::std::basic_streambuf<_CharT, _Traits>::int_type __c = this->overflow(traits_type::to_int_type(*__s));
            if (!traits_type::eq_int_type(__c, traits_type::eof()))
              {
                 ++__ret;
                 ++__s;
              }
            else
              {
                break;
              }
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize __copy_streambufs_eof(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout, bool &__ineof)
  {
    ::std::streamsize __ret(0);
    __ineof = true;
    typename _Traits::int_type __c = __sbin->sgetc();
    while (!_Traits::eq_int_type(__c, _Traits::eof()))
      {
        __c = __sbout->sputc(_Traits::to_char_type(__c));
        if (_Traits::eq_int_type(__c, _Traits::eof()))
          {
            __ineof = false;
            break;
          }
         ++__ret;
        __c = __sbin->snextc();
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout);
  template < typename _CharT, typename _Traits >
  inline ::std::streamsize __copy_streambufs(::std::basic_streambuf<_CharT, _Traits> *__sbin, ::std::basic_streambuf<_CharT, _Traits> *__sbout)
  {
    bool __ineof;
    return __copy_streambufs_eof(__sbin, __sbout, __ineof);
  }
  extern template class ::std::basic_streambuf<char>;
  extern template long int __copy_streambufs(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<char> *, ::std::basic_streambuf<char> *, bool &);
  extern template class ::std::basic_streambuf<wchar_t>;
  extern template long int __copy_streambufs(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *);
  extern template long int __copy_streambufs_eof(::std::basic_streambuf<wchar_t> *, ::std::basic_streambuf<wchar_t> *, bool &);
}
typedef unsigned long int wctype_t;
enum mcc_enum_anon_68
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,
  _ISwupper = ::__ISwupper < 8 ? (int)(1LU << ::__ISwupper << 24) : ::__ISwupper < 16 ? (int)(1LU << ::__ISwupper << 8) : ::__ISwupper < 24 ? (int)(1LU << ::__ISwupper >> 8) : (int)(1LU << ::__ISwupper >> 24),
  _ISwlower = ::__ISwlower < 8 ? (int)(1LU << ::__ISwlower << 24) : ::__ISwlower < 16 ? (int)(1LU << ::__ISwlower << 8) : ::__ISwlower < 24 ? (int)(1LU << ::__ISwlower >> 8) : (int)(1LU << ::__ISwlower >> 24),
  _ISwalpha = ::__ISwalpha < 8 ? (int)(1LU << ::__ISwalpha << 24) : ::__ISwalpha < 16 ? (int)(1LU << ::__ISwalpha << 8) : ::__ISwalpha < 24 ? (int)(1LU << ::__ISwalpha >> 8) : (int)(1LU << ::__ISwalpha >> 24),
  _ISwdigit = ::__ISwdigit < 8 ? (int)(1LU << ::__ISwdigit << 24) : ::__ISwdigit < 16 ? (int)(1LU << ::__ISwdigit << 8) : ::__ISwdigit < 24 ? (int)(1LU << ::__ISwdigit >> 8) : (int)(1LU << ::__ISwdigit >> 24),
  _ISwxdigit = ::__ISwxdigit < 8 ? (int)(1LU << ::__ISwxdigit << 24) : ::__ISwxdigit < 16 ? (int)(1LU << ::__ISwxdigit << 8) : ::__ISwxdigit < 24 ? (int)(1LU << ::__ISwxdigit >> 8) : (int)(1LU << ::__ISwxdigit >> 24),
  _ISwspace = ::__ISwspace < 8 ? (int)(1LU << ::__ISwspace << 24) : ::__ISwspace < 16 ? (int)(1LU << ::__ISwspace << 8) : ::__ISwspace < 24 ? (int)(1LU << ::__ISwspace >> 8) : (int)(1LU << ::__ISwspace >> 24),
  _ISwprint = ::__ISwprint < 8 ? (int)(1LU << ::__ISwprint << 24) : ::__ISwprint < 16 ? (int)(1LU << ::__ISwprint << 8) : ::__ISwprint < 24 ? (int)(1LU << ::__ISwprint >> 8) : (int)(1LU << ::__ISwprint >> 24),
  _ISwgraph = ::__ISwgraph < 8 ? (int)(1LU << ::__ISwgraph << 24) : ::__ISwgraph < 16 ? (int)(1LU << ::__ISwgraph << 8) : ::__ISwgraph < 24 ? (int)(1LU << ::__ISwgraph >> 8) : (int)(1LU << ::__ISwgraph >> 24),
  _ISwblank = ::__ISwblank < 8 ? (int)(1LU << ::__ISwblank << 24) : ::__ISwblank < 16 ? (int)(1LU << ::__ISwblank << 8) : ::__ISwblank < 24 ? (int)(1LU << ::__ISwblank >> 8) : (int)(1LU << ::__ISwblank >> 24),
  _ISwcntrl = ::__ISwcntrl < 8 ? (int)(1LU << ::__ISwcntrl << 24) : ::__ISwcntrl < 16 ? (int)(1LU << ::__ISwcntrl << 8) : ::__ISwcntrl < 24 ? (int)(1LU << ::__ISwcntrl >> 8) : (int)(1LU << ::__ISwcntrl >> 24),
  _ISwpunct = ::__ISwpunct < 8 ? (int)(1LU << ::__ISwpunct << 24) : ::__ISwpunct < 16 ? (int)(1LU << ::__ISwpunct << 8) : ::__ISwpunct < 24 ? (int)(1LU << ::__ISwpunct >> 8) : (int)(1LU << ::__ISwpunct >> 24),
  _ISwalnum = ::__ISwalnum < 8 ? (int)(1LU << ::__ISwalnum << 24) : ::__ISwalnum < 16 ? (int)(1LU << ::__ISwalnum << 8) : ::__ISwalnum < 24 ? (int)(1LU << ::__ISwalnum >> 8) : (int)(1LU << ::__ISwalnum >> 24)
};
extern "C"
{
  extern int iswalnum(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswalpha(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswcntrl(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswgraph(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswlower(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswprint(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswpunct(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswspace(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswupper(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswxdigit(::wint_t __wc) throw();
}
extern "C"
{
  extern int iswblank(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctype_t wctype(const char *__property) throw();
}
extern "C"
{
  extern int iswctype(::wint_t __wc, ::wctype_t __desc) throw();
}
typedef const ::__int32_t *wctrans_t;
extern "C"
{
  extern ::wint_t towlower(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wint_t towupper(::wint_t __wc) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans(const char *__property) throw();
}
extern "C"
{
  extern ::wint_t towctrans(::wint_t __wc, ::wctrans_t __desc) throw();
}
extern "C"
{
  extern int iswalnum_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswalpha_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswcntrl_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswgraph_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswprint_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswpunct_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswspace_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswxdigit_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswblank_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctype_t wctype_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern int iswctype_l(::wint_t __wc, ::wctype_t __desc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towlower_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towupper_l(::wint_t __wc, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wctrans_t wctrans_l(const char *__property, ::__locale_t __locale) throw();
}
extern "C"
{
  extern ::wint_t towctrans_l(::wint_t __wc, ::wctrans_t __desc, ::__locale_t __locale) throw();
}
namespace std __attribute__((__visibility__("default"))) {
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
  struct  ctype_base
  {
      typedef const int *__to_type;
      typedef unsigned short int mask;
      static const ::std::ctype_base::mask upper = ::_ISupper;
      static const ::std::ctype_base::mask lower = ::_ISlower;
      static const ::std::ctype_base::mask alpha = ::_ISalpha;
      static const ::std::ctype_base::mask digit = ::_ISdigit;
      static const ::std::ctype_base::mask xdigit = ::_ISxdigit;
      static const ::std::ctype_base::mask space = ::_ISspace;
      static const ::std::ctype_base::mask print = ::_ISprint;
      static const ::std::ctype_base::mask graph = (::_ISalpha | ::_ISdigit) | ::_ISpunct;
      static const ::std::ctype_base::mask cntrl = ::_IScntrl;
      static const ::std::ctype_base::mask punct = ::_ISpunct;
      static const ::std::ctype_base::mask alnum = ::_ISalpha | ::_ISdigit;
      static const ::std::ctype_base::mask blank = ::_ISblank;
  };
  template < typename _CharT, typename _Traits >
  class  istreambuf_iterator : public ::std::iterator< ::std::input_iterator_tag, _CharT, typename _Traits::off_type, _CharT *, _CharT>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> istream_type;
    private:
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      mutable typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_c;
    public:
      inline constexpr istreambuf_iterator() noexcept(true)
        : _M_sbuf(0), _M_c(traits_type::eof())
      {
      }
      istreambuf_iterator(const ::std::istreambuf_iterator<_CharT, _Traits> &) noexcept(true) = default ;
      ~istreambuf_iterator() = default ;
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::istream_type &__s) noexcept(true)
        : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof())
      {
      }
      inline istreambuf_iterator(typename ::std::istreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) noexcept(true)
        : _M_sbuf(__s), _M_c(traits_type::eof())
      {
      }
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::char_type operator *() const 
      {
        return traits_type::to_char_type((*this)._M_get());
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        ;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return *this;
      }
      inline ::std::istreambuf_iterator<_CharT, _Traits> operator ++(int)
      {
        ;
        ::std::istreambuf_iterator<_CharT, _Traits> __old = *this;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            __old._M_c = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sbumpc();
            ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = traits_type::eof();
          }
        return __old;
      }
      inline bool equal(const ::std::istreambuf_iterator<_CharT, _Traits> &__b) const 
      {
        return (*this)._M_at_eof() == __b._M_at_eof();
      }
    private:
      inline typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type _M_get() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __ret = __eof;
        if (::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf)
          {
            if (!traits_type::eq_int_type(::std::istreambuf_iterator<_CharT, _Traits>::_M_c, __eof))
              {
                __ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_c;
              }
            else
              {
                if (!traits_type::eq_int_type(__ret = ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf->sgetc(), __eof))
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_c = __ret;
                  }
                else
                  {
                    ::std::istreambuf_iterator<_CharT, _Traits>::_M_sbuf = 0;
                  }
              }
          }
        return __ret;
      }
      inline bool _M_at_eof() const 
      {
        const typename ::std::istreambuf_iterator<_CharT, _Traits>::int_type __eof = traits_type::eof();
        return traits_type::eq_int_type((*this)._M_get(), __eof);
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
    template < bool _IsMove, typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, _CharT2 *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, _CharT2 *);
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::istreambuf_iterator<_CharT2> >::__type find(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, const _CharT2 &);
  };
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator ==(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return __a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b);
  template < typename _CharT, typename _Traits >
  inline bool operator !=(const ::std::istreambuf_iterator<_CharT, _Traits> &__a, const ::std::istreambuf_iterator<_CharT, _Traits> &__b)
  {
    return !__a.equal(__b);
  }
  template < typename _CharT, typename _Traits >
  class  ostreambuf_iterator : public ::std::iterator< ::std::output_iterator_tag, void, void, void, void>
  {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef ::std::basic_ostream<_CharT, _Traits> ostream_type;
    private:
      typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *_M_sbuf;
      bool _M_failed;
    public:
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::ostream_type &__s) noexcept(true)
        : _M_sbuf(__s.rdbuf()), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ostreambuf_iterator(typename ::std::ostreambuf_iterator<_CharT, _Traits>::streambuf_type *__s) noexcept(true)
        : _M_sbuf(__s), _M_failed(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf)
      {
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator =(_CharT __c)
      {
        if (!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed && _Traits::eq_int_type(::std::ostreambuf_iterator<_CharT, _Traits>::_M_sbuf->sputc(__c), _Traits::eof()))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator *()
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++(int)
      {
        return *this;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &operator ++()
      {
        return *this;
      }
      inline bool failed() const  noexcept(true)
      {
        return ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed;
      }
      inline ::std::ostreambuf_iterator<_CharT, _Traits> &_M_put(const _CharT *__ws, ::std::streamsize __len)
      {
        if (__builtin_expect(!::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed, true) && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len, false))
          {
            ::std::ostreambuf_iterator<_CharT, _Traits>::_M_failed = true;
          }
        return *this;
      }
    template < typename _CharT2 >
    friend typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, ::std::ostreambuf_iterator<_CharT2> >::__type copy(::std::istreambuf_iterator<_CharT2>, ::std::istreambuf_iterator<_CharT2>, ::std::ostreambuf_iterator<_CharT2>);
  };
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT> >::__type copy(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    if ((__first._M_sbuf && !__last._M_sbuf) && !__result._M_failed)
      {
        bool __ineof;
        __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
        if (!__ineof)
          {
            __result._M_failed = true;
          }
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(_CharT *__first, _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::ostreambuf_iterator<_CharT, ::std::char_traits<_CharT> > >::__type __copy_move_a2(const _CharT *__first, const _CharT *__last, ::std::ostreambuf_iterator<_CharT> __result)
  {
    const ::std::streamsize __num = __last - __first;
    if (__num > 0)
      {
        __result._M_put(__first, __num);
      }
    return __result;
  }
  template < bool _IsMove, typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, _CharT *>::__type __copy_move_a2(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, _CharT *__result)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            const ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                traits_type::copy(__result, __sb->gptr(), __n);
                __sb->__safe_gbump(__n);
                __result += __n;
                __c = __sb->underflow();
              }
            else
              {
                *__result++ = traits_type::to_char_type(__c);
                __c = __sb->snextc();
              }
          }
      }
    return __result;
  }
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val);
  template < typename _CharT >
  typename ::__gnu_cxx::__enable_if<__is_char<_CharT>::__value, ::std::istreambuf_iterator<_CharT> >::__type find(::std::istreambuf_iterator<_CharT> __first, ::std::istreambuf_iterator<_CharT> __last, const _CharT &__val)
  {
    typedef ::std::istreambuf_iterator<_CharT> __is_iterator_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type traits_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::streambuf_type streambuf_type;
    typedef typename ::std::istreambuf_iterator<_CharT>::traits_type::int_type int_type;
    if (__first._M_sbuf && !__last._M_sbuf)
      {
        const int_type __ival = traits_type::to_int_type(__val);
        streambuf_type *__sb = __first._M_sbuf;
        int_type __c = __sb->sgetc();
        while (!traits_type::eq_int_type(__c, traits_type::eof()) && !traits_type::eq_int_type(__c, __ival))
          {
            ::std::streamsize __n = __sb->egptr() - __sb->gptr();
            if (__n > 1)
              {
                const _CharT *__p = traits_type::find(__sb->gptr(), __n, __val);
                if (__p)
                  {
                    __n = __p - __sb->gptr();
                  }
                __sb->__safe_gbump(__n);
                __c = __sb->sgetc();
              }
            else
              {
                __c = __sb->snextc();
              }
          }
        if (!traits_type::eq_int_type(__c, traits_type::eof()))
          {
            __first._M_c = __c;
          }
        else
          {
            __first._M_sbuf = 0;
          }
      }
    return __first;
  }
  template < typename _Tp >
  void __convert_to_v(const char *, _Tp &, ::std::ios_base::iostate &, const ::std::__c_locale &) throw();
  template <>
  void __convert_to_v<float>(const char *, float &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<double>(const char *, double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template <>
  void __convert_to_v<long double>(const char *, long double &, ::std::_Ios_Iostate &, ::__locale_struct *const &) throw();
  template < typename _CharT, typename _Traits >
  struct  __pad
  {
      static void _S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen);
  };
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len);
  template < typename _CharT >
  inline ::std::ostreambuf_iterator<_CharT> __write(::std::ostreambuf_iterator<_CharT> __s, const _CharT *__ws, int __len)
  {
    __s._M_put(__ws, __len);
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len);
  template < typename _CharT, typename _OutIter >
  inline _OutIter __write(_OutIter __s, const _CharT *__ws, int __len)
  {
    for (int __j(0); __j < __len; (__j++,  ++__s))
      {
        *__s = __ws[__j];
      }
    return __s;
  }
  template < typename _CharT >
  class  __ctype_abstract_base : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef _CharT char_type;
      inline bool is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_is(__m, __c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const 
      {
        return this->do_is(__lo, __hi, __vec);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_is(__m, __lo, __hi);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_scan_not(__m, __lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_toupper(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_toupper(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const 
      {
        return this->do_tolower(__c);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const 
      {
        return this->do_tolower(__lo, __hi);
      }
      inline typename ::std::__ctype_abstract_base<_CharT>::char_type widen(char __c) const 
      {
        return this->do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const 
      {
        return this->do_widen(__lo, __hi, __to);
      }
      inline char narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const 
      {
        return this->do_narrow(__c, __dfault);
      }
      inline const typename ::std::__ctype_abstract_base<_CharT>::char_type *narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const 
      {
        return this->do_narrow(__lo, __hi, __dfault, __to);
      }
    protected:
      inline explicit __ctype_abstract_base(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline virtual ~__ctype_abstract_base()
      {
      }
      virtual bool do_is(::std::ctype_base::mask __m, typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_is(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, ::std::ctype_base::mask *__vec) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_is(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_scan_not(::std::ctype_base::mask __m, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_toupper(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type __c) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_tolower(typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi) const  = 0 ;
      virtual typename ::std::__ctype_abstract_base<_CharT>::char_type do_widen(char __c) const  = 0 ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::__ctype_abstract_base<_CharT>::char_type *__to) const  = 0 ;
      virtual char do_narrow(typename ::std::__ctype_abstract_base<_CharT>::char_type __c, char __dfault) const  = 0 ;
      virtual const typename ::std::__ctype_abstract_base<_CharT>::char_type *do_narrow(const typename ::std::__ctype_abstract_base<_CharT>::char_type *__lo, const typename ::std::__ctype_abstract_base<_CharT>::char_type *__hi, char __dfault, char *__to) const  = 0 ;
  };
  template < typename _CharT >
  class  ctype : public ::std::__ctype_abstract_base<_CharT>
  {
    public:
      typedef _CharT char_type;
      typedef typename ::std::__ctype_abstract_base<_CharT>::mask mask;
      static ::std::locale::id id;
      inline explicit ctype(::std::size_t __refs  = (0))
        : __ctype_abstract_base<_CharT>(__refs)
      {
      }
    protected:
      virtual ~ctype();
      virtual bool do_is(typename ::std::ctype<_CharT>::mask __m, typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_is(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, typename ::std::ctype<_CharT>::mask *__vec) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_is(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_scan_not(typename ::std::ctype<_CharT>::mask __m, const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_toupper(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_toupper(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_tolower(typename ::std::ctype<_CharT>::char_type __c) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_tolower(typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi) const ;
      virtual typename ::std::ctype<_CharT>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, typename ::std::ctype<_CharT>::char_type *__dest) const ;
      virtual char do_narrow(typename ::std::ctype<_CharT>::char_type, char __dfault) const ;
      virtual const typename ::std::ctype<_CharT>::char_type *do_narrow(const typename ::std::ctype<_CharT>::char_type *__lo, const typename ::std::ctype<_CharT>::char_type *__hi, char __dfault, char *__to) const ;
  };
  template < typename _CharT >
  ::std::locale::id ctype<_CharT>::id;
  template <>
  class  ctype<char> : public ::std::locale::facet, public ::std::ctype_base
  {
    public:
      typedef char char_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_del;
      ::std::ctype_base::__to_type _M_toupper;
      ::std::ctype_base::__to_type _M_tolower;
      const ::std::ctype_base::mask *_M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[256L];
      mutable char _M_narrow[256L];
      mutable char _M_narrow_ok;
    public:
      static ::std::locale::id id;
      static const ::std::size_t table_size = 1 + static_cast<unsigned char>( -1);
      explicit ctype(const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, const ::std::ctype_base::mask *__table  = (0), bool __del  = (false), ::std::size_t __refs  = (0));
      inline bool is(::std::ctype_base::mask __m, char __c) const ;
      inline const char *is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const ;
      inline const char *scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline const char *scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const ;
      inline ::std::ctype<char>::char_type toupper(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_toupper(__c);
      }
      inline const ::std::ctype<char>::char_type *toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_toupper(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type tolower(::std::ctype<char>::char_type __c) const 
      {
        return (*this).do_tolower(__c);
      }
      inline const ::std::ctype<char>::char_type *tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const 
      {
        return (*this).do_tolower(__lo, __hi);
      }
      inline ::std::ctype<char>::char_type widen(char __c) const 
      {
        if ((*this)._M_widen_ok)
          {
            return (*this)._M_widen[static_cast<unsigned char>(__c)];
          }
        (*this).::std::ctype<char>::_M_widen_init();
        return (*this).do_widen(__c);
      }
      inline const char *widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        if ((*this)._M_widen_ok == 1)
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_widen_ok)
          {
            (*this).::std::ctype<char>::_M_widen_init();
          }
        return (*this).do_widen(__lo, __hi, __to);
      }
      inline char narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        if ((*this)._M_narrow[static_cast<unsigned char>(__c)])
          {
            return (*this)._M_narrow[static_cast<unsigned char>(__c)];
          }
        const char __t((*this).do_narrow(__c, __dfault));
        if (__t != __dfault)
          {
            (*this)._M_narrow[static_cast<unsigned char>(__c)] = __t;
          }
        return __t;
      }
      inline const ::std::ctype<char>::char_type *narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        if (__builtin_expect((*this)._M_narrow_ok == 1, true))
          {
            __builtin_memcpy(__to, __lo, __hi - __lo);
            return __hi;
          }
        if (!(*this)._M_narrow_ok)
          {
            (*this).::std::ctype<char>::_M_narrow_init();
          }
        return (*this).do_narrow(__lo, __hi, __dfault, __to);
      }
      inline const ::std::ctype_base::mask *table() const  throw()
      {
        return (*this)._M_table;
      }
      static const ::std::ctype_base::mask *classic_table() throw();
    protected:
      virtual ~ctype();
      virtual ::std::ctype<char>::char_type do_toupper(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_toupper(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual ::std::ctype<char>::char_type do_tolower(::std::ctype<char>::char_type __c) const ;
      virtual const ::std::ctype<char>::char_type *do_tolower(::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi) const ;
      virtual inline ::std::ctype<char>::char_type do_widen(char __c) const 
      {
        return __c;
      }
      virtual inline const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<char>::char_type *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
      virtual inline char do_narrow(::std::ctype<char>::char_type __c, char __dfault) const 
      {
        return __c;
      }
      virtual inline const ::std::ctype<char>::char_type *do_narrow(const ::std::ctype<char>::char_type *__lo, const ::std::ctype<char>::char_type *__hi, char __dfault, char *__to) const 
      {
        __builtin_memcpy(__to, __lo, __hi - __lo);
        return __hi;
      }
    private:
      void _M_narrow_init() const ;
      void _M_widen_init() const ;
    public:
  };
 /* Instantiation of class template '::std::__ctype_abstract_base<wchar_t>' */ 
  template <>
  class  ctype<wchar_t> : public ::std::__ctype_abstract_base<wchar_t>
  {
    public:
      typedef wchar_t char_type;
      typedef ::wctype_t __wmask_type;
    protected:
      ::std::__c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128L];
      ::wint_t _M_widen[256L];
      ::std::ctype_base::mask _M_bit[16L];
      ::std::ctype<wchar_t>::__wmask_type _M_wmask[16L];
    public:
      static ::std::locale::id id;
      explicit ctype(::std::size_t __refs  = (0));
      explicit ctype(::std::__c_locale __cloc, ::std::size_t __refs  = (0));
    protected:
      ::std::ctype<wchar_t>::__wmask_type _M_convert_to_wmask(const ::std::ctype_base::mask __m) const  throw();
      virtual ~ctype();
      virtual bool do_is(::std::ctype_base::mask __m, ::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_is(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, ::std::ctype_base::mask *__vec) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_is(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_scan_not(::std::ctype_base::mask __m, const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_toupper(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_toupper(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_tolower(::std::ctype<wchar_t>::char_type __c) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_tolower(::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi) const ;
      virtual ::std::ctype<wchar_t>::char_type do_widen(char __c) const ;
      virtual const char *do_widen(const char *__lo, const char *__hi, ::std::ctype<wchar_t>::char_type *__to) const ;
      virtual char do_narrow(::std::ctype<wchar_t>::char_type __c, char __dfault) const ;
      virtual const ::std::ctype<wchar_t>::char_type *do_narrow(const ::std::ctype<wchar_t>::char_type *__lo, const ::std::ctype<wchar_t>::char_type *__hi, char __dfault, char *__to) const ;
      void _M_initialize_ctype() throw();
    public:
  };
  template < typename _CharT >
  class  ctype_byname : public ::std::ctype<_CharT>
  {
    public:
      typedef typename ::std::ctype<_CharT>::mask mask;
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
      inline explicit ctype_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs  = (0))
        : ctype_byname(__s.::std::__cxx11::basic_string<char>::c_str(), __refs)
      {
      }
    protected:
      inline virtual ~ctype_byname()
      {
      }
  };
  template <>
  class  ctype_byname<char> : public ::std::ctype<char>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
      explicit ctype_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  template <>
  class  ctype_byname<wchar_t> : public ::std::ctype<wchar_t>
  {
    public:
      explicit ctype_byname(const char *__s, ::std::size_t __refs  = (0));
      explicit ctype_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs  = (0));
    protected:
      virtual ~ctype_byname();
    public:
  };
  inline bool ctype<char>::is(::std::ctype_base::mask __m, char __c) const 
  {
    return (*this)._M_table[static_cast<unsigned char>(__c)] & __m;
  }
 /* Instantiation of class template '::std::is_error_code_enum<const char *>' */ 
 /* Instantiation of class template '::std::is_error_condition_enum<const char *>' */ 
  inline const char *ctype<char>::is(const char *__low, const char *__high, ::std::ctype_base::mask *__vec) const 
  {
    while (__low < __high)
      {
        *__vec++ = (*this)._M_table[static_cast<unsigned char>(*__low++)];
      }
    return __high;
  }
  inline const char *ctype<char>::scan_is(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && !((*this)._M_table[static_cast<unsigned char>(*__low)] & __m))
      {
         ++__low;
      }
    return __low;
  }
  inline const char *ctype<char>::scan_not(::std::ctype_base::mask __m, const char *__low, const char *__high) const 
  {
    while (__low < __high && ((*this)._M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      {
         ++__low;
      }
    return __low;
  }
  class  __num_base
  {
    public:
      enum mcc_enum_anon_69
      {
        _S_ominus = 0,
        _S_oplus = 1,
        _S_ox = 2,
        _S_oX = 3,
        _S_odigits = 4,
        _S_odigits_end = ::std::__num_base::_S_odigits + 16,
        _S_oudigits = ::std::__num_base::_S_odigits_end,
        _S_oudigits_end = ::std::__num_base::_S_oudigits + 16,
        _S_oe = ::std::__num_base::_S_odigits + 14,
        _S_oE = ::std::__num_base::_S_oudigits + 14,
        _S_oend = ::std::__num_base::_S_oudigits_end
      };
      static const char *_S_atoms_out;
      static const char *_S_atoms_in;
      enum mcc_enum_anon_70
      {
        _S_iminus = 0,
        _S_iplus = 1,
        _S_ix = 2,
        _S_iX = 3,
        _S_izero = 4,
        _S_ie = ::std::__num_base::_S_izero + 14,
        _S_iE = ::std::__num_base::_S_izero + 20,
        _S_iend = 26
      };
      static void _S_format_float(const ::std::ios_base &__io, char *__fptr, char __mod) throw();
  };
  template < typename _CharT >
  struct  __numpunct_cache : ::std::locale::facet
  {
      const char *_M_grouping;
      ::std::size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT *_M_truename;
      ::std::size_t _M_truename_size;
      const _CharT *_M_falsename;
      ::std::size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[36L];
      _CharT _M_atoms_in[26L];
      bool _M_allocated;
      inline __numpunct_cache(::std::size_t __refs  = (0))
        : facet(__refs), _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false), _M_truename(0), _M_truename_size(0), _M_falsename(0), _M_falsename_size(0), _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()), _M_allocated(false)
      {
      }
      virtual ~__numpunct_cache();
      void _M_cache(const ::std::locale &__loc);
    private:
      ::std::__numpunct_cache<_CharT> &operator =(const ::std::__numpunct_cache<_CharT> &);
      explicit __numpunct_cache(const ::std::__numpunct_cache<_CharT> &);
  };
  template < typename _CharT >
  __numpunct_cache<_CharT>::~__numpunct_cache()
  {
    if (::std::__numpunct_cache<_CharT>::_M_allocated)
      {
        delete[] ::std::__numpunct_cache<_CharT>::_M_grouping;
        delete[] ::std::__numpunct_cache<_CharT>::_M_truename;
        delete[] ::std::__numpunct_cache<_CharT>::_M_falsename;
      }
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    template < typename _CharT >
    class  numpunct : public ::std::locale::facet
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
      protected:
        typename ::std::__cxx11::numpunct<_CharT>::__cache_type *_M_data;
      public:
        static ::std::locale::id id;
        inline explicit numpunct(::std::size_t __refs  = (0))
          : facet(__refs), _M_data(0)
        {
          (*this)._M_initialize_numpunct();
        }
        inline explicit numpunct(typename ::std::__cxx11::numpunct<_CharT>::__cache_type *__cache, ::std::size_t __refs  = (0))
          : facet(__refs), _M_data(__cache)
        {
          (*this)._M_initialize_numpunct();
        }
        inline explicit numpunct(::std::__c_locale __cloc, ::std::size_t __refs  = (0))
          : facet(__refs), _M_data(0)
        {
          (*this)._M_initialize_numpunct(__cloc);
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::char_type decimal_point() const 
        {
          return this->do_decimal_point();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::char_type thousands_sep() const 
        {
          return this->do_thousands_sep();
        }
        inline ::std::__cxx11::string grouping() const 
        {
          return this->do_grouping();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::string_type truename() const 
        {
          return this->do_truename();
        }
        inline typename ::std::__cxx11::numpunct<_CharT>::string_type falsename() const 
        {
          return this->do_falsename();
        }
      protected:
        virtual ~numpunct();
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::char_type do_decimal_point() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_decimal_point;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::char_type do_thousands_sep() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_thousands_sep;
        }
        inline virtual ::std::__cxx11::string do_grouping() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_grouping;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::string_type do_truename() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_truename;
        }
        inline virtual typename ::std::__cxx11::numpunct<_CharT>::string_type do_falsename() const 
        {
          return ::std::__cxx11::numpunct<_CharT>::_M_data->_M_falsename;
        }
        void _M_initialize_numpunct(::std::__c_locale __cloc  = (0));
    };
    template < typename _CharT >
    ::std::locale::id numpunct<_CharT>::id;
 /* Instantiation of class template '::std::__cxx11::numpunct<char>' */ 
    template <>
    numpunct<char>::~numpunct();
    template <>
    void numpunct<char>::_M_initialize_numpunct(::__locale_struct *__cloc);
 /* Instantiation of class template '::std::__cxx11::numpunct<wchar_t>' */ 
    template <>
    numpunct<wchar_t>::~numpunct();
    template <>
    void numpunct<wchar_t>::_M_initialize_numpunct(::__locale_struct *__cloc);
    template < typename _CharT >
    class  numpunct_byname : public ::std::__cxx11::numpunct<_CharT>
    {
      public:
        typedef _CharT char_type;
        typedef ::std::__cxx11::basic_string<_CharT> string_type;
        inline explicit numpunct_byname(const char *__s, ::std::size_t __refs  = (0))
          : numpunct<_CharT>(__refs)
        {
          if (__builtin_strcmp(__s, "C") != 0 && __builtin_strcmp(__s, "POSIX") != 0)
            {
              ::std::__c_locale __tmp;
              this->_S_create_c_locale(__tmp, __s);
              this->_M_initialize_numpunct(__tmp);
              this->_S_destroy_c_locale(__tmp);
            }
        }
        inline explicit numpunct_byname(const ::std::__cxx11::string &__s, ::std::size_t __refs  = (0))
          : numpunct_byname(__s.::std::__cxx11::basic_string<char>::c_str(), __refs)
        {
        }
      protected:
        inline virtual ~numpunct_byname()
        {
        }
    };
  }
  template < typename _CharT, typename _InIter >
  class  num_get : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static ::std::locale::id id;
      inline explicit num_get(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
      inline typename ::std::num_get<_CharT, _InIter>::iter_type get(typename ::std::num_get<_CharT, _InIter>::iter_type __in, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
      {
        return this->do_get(__in, __end, __io, __err, __v);
      }
    protected:
      inline virtual ~num_get()
      {
      }
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_float(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::__cxx11::string &__xtrc) const  __attribute__((__abi_tag__("cxx11")));
      template < typename _ValueT >
      typename ::std::num_get<_CharT, _InIter>::iter_type _M_extract_int(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const  __attribute__((__abi_tag__("cxx11")));
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        if (__len <= 10)
          {
            if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
              {
                __ret = __c - _CharT2('0');
              }
          }
        else
          {
            if (__c >= _CharT2('0') && __c <= _CharT2('9'))
              {
                __ret = __c - _CharT2('0');
              }
            else
              {
                if (__c >= _CharT2('a') && __c <= _CharT2('f'))
                  {
                    __ret = 10 + (__c - _CharT2('a'));
                  }
                else
                  {
                    if (__c >= _CharT2('A') && __c <= _CharT2('F'))
                      {
                        __ret = 10 + (__c - _CharT2('A'));
                      }
                  }
              }
          }
        return __ret;
      }
      template < typename _CharT2 >
      inline typename ::__gnu_cxx::__enable_if<!__is_char<_CharT2>::__value, int>::__type _M_find(const _CharT2 *__zero, ::std::size_t __len, _CharT2 __c) const 
      {
        int __ret( -1);
        const typename ::std::num_get<_CharT, _InIter>::char_type *__q = char_traits<_CharT2>::find(__zero, __len, __c);
        if (__q)
          {
            __ret = __q - __zero;
            if (__ret > 15)
              {
                __ret -= 6;
              }
          }
        return __ret;
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const ;
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned short int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      inline virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, unsigned long long int &__v) const 
      {
        return (*this)._M_extract_int(__beg, __end, __io, __err, __v);
      }
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const ;
      virtual typename ::std::num_get<_CharT, _InIter>::iter_type do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const ;
  };
  template < typename _CharT, typename _InIter >
  ::std::locale::id num_get<_CharT, _InIter>::id;
  template < typename _CharT, typename _OutIter >
  class  num_put : public ::std::locale::facet
  {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static ::std::locale::id id;
      inline explicit num_put(::std::size_t __refs  = (0))
        : facet(__refs)
      {
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
      inline typename ::std::num_put<_CharT, _OutIter>::iter_type put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
      {
        return this->do_put(__s, __io, __fill, __v);
      }
    protected:
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_float(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, char __mod, _ValueT __v) const ;
      void _M_group_float(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, const typename ::std::num_put<_CharT, _OutIter>::char_type *__p, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      template < typename _ValueT >
      typename ::std::num_put<_CharT, _OutIter>::iter_type _M_insert_int(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, _ValueT __v) const ;
      void _M_group_int(const char *__grouping, ::std::size_t __grouping_size, typename ::std::num_put<_CharT, _OutIter>::char_type __sep, ::std::ios_base &, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      void _M_pad(typename ::std::num_put<_CharT, _OutIter>::char_type __fill, ::std::streamsize __w, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type *__new, const typename ::std::num_put<_CharT, _OutIter>::char_type *__cs, int &__len) const ;
      inline virtual ~num_put()
      {
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const ;
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      inline virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, unsigned long long int __v) const 
      {
        return (*this)._M_insert_int(__s, __io, __fill, __v);
      }
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const ;
      virtual typename ::std::num_put<_CharT, _OutIter>::iter_type do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const ;
  };
  template < typename _CharT, typename _OutIter >
  ::std::locale::id num_put<_CharT, _OutIter>::id;
  template < typename _CharT >
  inline bool isspace(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::space, __c);
  }
  template < typename _CharT >
  inline bool isprint(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::print, __c);
  }
  template < typename _CharT >
  inline bool iscntrl(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::cntrl, __c);
  }
  template < typename _CharT >
  inline bool isupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::upper, __c);
  }
  template < typename _CharT >
  inline bool islower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::lower, __c);
  }
  template < typename _CharT >
  inline bool isalpha(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alpha, __c);
  }
  template < typename _CharT >
  inline bool isdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::digit, __c);
  }
  template < typename _CharT >
  inline bool ispunct(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::punct, __c);
  }
  template < typename _CharT >
  inline bool isxdigit(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::xdigit, __c);
  }
  template < typename _CharT >
  inline bool isalnum(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::alnum, __c);
  }
  template < typename _CharT >
  inline bool isgraph(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::graph, __c);
  }
  template < typename _CharT >
  inline bool isblank(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).is(::std::ctype_base::blank, __c);
  }
  template < typename _CharT >
  inline _CharT toupper(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).toupper(__c);
  }
  template < typename _CharT >
  inline _CharT tolower(_CharT __c, const ::std::locale &__loc)
  {
    return use_facet< ::std::ctype<_CharT> >(__loc).tolower(__c);
  }
  template < typename _Facet >
  struct  __use_cache
  {
      const _Facet *operator ()(const ::std::locale &__loc) const ;
  };
  template < typename _CharT >
  struct  __use_cache< ::std::__numpunct_cache<_CharT> >
  {
      inline const ::std::__numpunct_cache<_CharT> *operator ()(const ::std::locale &__loc) const 
      {
        const ::std::size_t __i = numpunct<_CharT>::id._M_id();
        const ::std::locale::facet **__caches((*__loc._M_impl)._M_caches);
        if (!__caches[__i])
          {
            ::std::__numpunct_cache<_CharT> *__tmp = 0;
            try
            {
              __tmp = (new ::std::__numpunct_cache<_CharT>());
              __tmp->_M_cache(__loc);
            }
            catch (...)
            {
              delete __tmp;
              throw;
            }
            (*__loc._M_impl)._M_install_cache(__tmp, __i);
          }
        return static_cast<const ::std::__numpunct_cache<_CharT> *>(__caches[__i]);
      }
  };
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<char>, ::__gnu_cxx::__numeric_traits_floating<char> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<char>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<char>' */ 
  template < typename _CharT >
  void __numpunct_cache<_CharT>::_M_cache(const ::std::locale &__loc)
  {
    const ::std::__cxx11::numpunct<_CharT> &__np = use_facet< ::std::__cxx11::numpunct<_CharT> >(__loc);
    char *__grouping(0);
    _CharT *__truename = 0;
    _CharT *__falsename = 0;
    try
    {
      const ::std::__cxx11::string &__g = __np.grouping();
      ::std::__numpunct_cache<_CharT>::_M_grouping_size = __g.::std::__cxx11::basic_string<char>::size();
      __grouping = (new char [::std::__numpunct_cache<_CharT>::_M_grouping_size]);
      __g.copy(__grouping, ::std::__numpunct_cache<_CharT>::_M_grouping_size);
      ::std::__numpunct_cache<_CharT>::_M_use_grouping = (::std::__numpunct_cache<_CharT>::_M_grouping_size && static_cast<signed char>(__grouping[0]) > 0) && __grouping[0] != ::__gnu_cxx::__numeric_traits_integer<char>::__max;
      const ::std::__cxx11::basic_string<_CharT> &__tn = __np.truename();
      ::std::__numpunct_cache<_CharT>::_M_truename_size = __tn.size();
      __truename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_truename_size]);
      __tn.copy(__truename, ::std::__numpunct_cache<_CharT>::_M_truename_size);
      const ::std::__cxx11::basic_string<_CharT> &__fn = __np.falsename();
      ::std::__numpunct_cache<_CharT>::_M_falsename_size = __fn.size();
      __falsename = (new _CharT [::std::__numpunct_cache<_CharT>::_M_falsename_size]);
      __fn.copy(__falsename, ::std::__numpunct_cache<_CharT>::_M_falsename_size);
      ::std::__numpunct_cache<_CharT>::_M_decimal_point = __np.decimal_point();
      ::std::__numpunct_cache<_CharT>::_M_thousands_sep = __np.thousands_sep();
      const ::std::ctype<_CharT> &__ct = use_facet< ::std::ctype<_CharT> >(__loc);
      __ct.widen(::std::__num_base::_S_atoms_out, ::std::__num_base::_S_atoms_out + ::std::__num_base::_S_oend, ::std::__numpunct_cache<_CharT>::_M_atoms_out);
      __ct.widen(::std::__num_base::_S_atoms_in, ::std::__num_base::_S_atoms_in + ::std::__num_base::_S_iend, ::std::__numpunct_cache<_CharT>::_M_atoms_in);
      ::std::__numpunct_cache<_CharT>::_M_grouping = __grouping;
      ::std::__numpunct_cache<_CharT>::_M_truename = __truename;
      ::std::__numpunct_cache<_CharT>::_M_falsename = __falsename;
      ::std::__numpunct_cache<_CharT>::_M_allocated = true;
    }
    catch (...)
    {
      delete[] __grouping;
      delete[] __truename;
      delete[] __falsename;
      throw;
    }
  }
  bool __verify_grouping(const char *__grouping, ::std::size_t __grouping_size, const ::std::__cxx11::string &__grouping_tmp) throw() __attribute__((__pure__));
 /* Instantiation of class template '::std::is_array< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::remove_volatile< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::remove_const< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::remove_cv< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::__is_void_helper< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::is_void< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::__not_< ::std::is_void< ::std::allocator<char> > >' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::__is_default_constructible_impl< ::std::allocator<char> >, ::std::__not_< ::std::is_void< ::std::allocator<char> > > >' */ 
 /* Instantiation of class template '::std::__is_default_constructible_impl< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::__and_< ::std::__not_< ::std::is_void< ::std::allocator<char> > >, ::std::__is_default_constructible_impl< ::std::allocator<char> > >' */ 
 /* Instantiation of class template '::std::__is_default_constructible_atom< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::__is_default_constructible_safe< ::std::allocator<char>, false>' */ 
 /* Instantiation of class template '::std::is_default_constructible< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::conditional<true, ::std::__is_nt_default_constructible_impl< ::std::allocator<char>, false>, ::std::is_default_constructible< ::std::allocator<char> > >' */ 
 /* Instantiation of class template '::std::__is_nt_default_constructible_atom< ::std::allocator<char> >' */ 
 /* Instantiation of class template '::std::__is_nt_default_constructible_impl< ::std::allocator<char>, false>' */ 
 /* Instantiation of class template '::std::__and_< ::std::is_default_constructible< ::std::allocator<char> >, ::std::__is_nt_default_constructible_impl< ::std::allocator<char>, false> >' */ 
 /* Instantiation of class template '::std::is_nothrow_default_constructible< ::std::allocator<char> >' */ 
  template < typename _CharT, typename _InIter >
  __attribute__((__abi_tag__("cxx11"))) typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_float(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, ::std::__cxx11::string &__xtrc) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    bool __testeof = __beg == __end;
    if (!__testeof)
      {
        __c = *__beg;
        const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
        if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            __xtrc += __plus ? '+' : '-';
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_mantissa(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero])
              {
                if (!__found_mantissa)
                  {
                    __xtrc += '0';
                    __found_mantissa = true;
                  }
                 ++__sep_pos;
                if ( ++__beg != __end)
                  {
                    __c = *__beg;
                  }
                else
                  {
                    __testeof = true;
                  }
              }
            else
              {
                break;
              }
          }
      }
    bool __found_dec(false);
    bool __found_sci(false);
    ::std::__cxx11::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::__cxx11::basic_string<char>::reserve(32);
      }
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            const int __digit = (*this)._M_find(__lit_zero, 10, __c);
            if (__digit !=  -1)
              {
                __xtrc += '0' + __digit;
                __found_mantissa = true;
              }
            else
              {
                if ((__c == __lc->_M_decimal_point && !__found_dec) && !__found_sci)
                  {
                    __xtrc += '.';
                    __found_dec = true;
                  }
                else
                  {
                    if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                      {
                        __xtrc += 'e';
                        __found_sci = true;
                        if ( ++__beg != __end)
                          {
                            __c = *__beg;
                            const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                            if (__plus || __c == __lit[::std::__num_base::_S_iminus])
                              {
                                __xtrc += __plus ? '+' : '-';
                              }
                            else
                              {
                                continue;
                              }
                          }
                        else
                          {
                            __testeof = true;
                            break;
                          }
                      }
                    else
                      {
                        break;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (!__found_dec && !__found_sci)
                  {
                    if (__sep_pos)
                      {
                        __found_grouping += static_cast<char>(__sep_pos);
                        __sep_pos = 0;
                      }
                    else
                      {
                        __xtrc.::std::__cxx11::basic_string<char>::clear();
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    if (!__found_dec && !__found_sci)
                      {
                        if (__found_grouping.::std::__cxx11::basic_string<char>::size())
                          {
                            __found_grouping += static_cast<char>(__sep_pos);
                          }
                        __xtrc += '.';
                        __found_dec = true;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, 10, __c);
                    if (__q)
                      {
                        __xtrc += '0' + (__q - __lit_zero);
                        __found_mantissa = true;
                         ++__sep_pos;
                      }
                    else
                      {
                        if (((__c == __lit[::std::__num_base::_S_ie] || __c == __lit[::std::__num_base::_S_iE]) && !__found_sci) && __found_mantissa)
                          {
                            if (__found_grouping.::std::__cxx11::basic_string<char>::size() && !__found_dec)
                              {
                                __found_grouping += static_cast<char>(__sep_pos);
                              }
                            __xtrc += 'e';
                            __found_sci = true;
                            if ( ++__beg != __end)
                              {
                                __c = *__beg;
                                const bool __plus = __c == __lit[::std::__num_base::_S_iplus];
                                if (((__plus || __c == __lit[::std::__num_base::_S_iminus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
                                  {
                                    __xtrc += __plus ? '+' : '-';
                                  }
                                else
                                  {
                                    continue;
                                  }
                              }
                            else
                              {
                                __testeof = true;
                                break;
                              }
                          }
                        else
                          {
                            break;
                          }
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::__cxx11::basic_string<char>::size())
      {
        if (!__found_dec && !__found_sci)
          {
            __found_grouping += static_cast<char>(__sep_pos);
          }
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    return __beg;
  }
 /* Instantiation of class template '::std::is_error_code_enum< ::std::_Ios_Fmtflags>' */ 
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::_Ios_Fmtflags>' */ 
  template < typename _CharT, typename _InIter >
  template < typename _ValueT >
  __attribute__((__abi_tag__("cxx11"))) typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::_M_extract_int(_InIter __beg, _InIter __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, _ValueT &__v) const 
  {
    typedef ::std::char_traits<_CharT> __traits_type;
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_in;
    typename ::std::num_get<_CharT, _InIter>::char_type __c = ((typename ::std::num_get<_CharT, _InIter>::char_type()));
    const ::std::ios_base::fmtflags __basefield(__io.::std::ios_base::flags() & ::std::ios_base::basefield);
    const bool __oct(__basefield == ::std::ios_base::oct);
    int __base(__oct ? 8 : __basefield == ::std::ios_base::hex ? 16 : 10);
    bool __testeof = __beg == __end;
    bool __negative(false);
    if (!__testeof)
      {
        __c = *__beg;
        __negative = __c == __lit[::std::__num_base::_S_iminus];
        if (((__negative || __c == __lit[::std::__num_base::_S_iplus]) && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)) && !(__c == __lc->_M_decimal_point))
          {
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    bool __found_zero(false);
    int __sep_pos(0);
    while (!__testeof)
      {
        if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep) || __c == __lc->_M_decimal_point)
          {
            break;
          }
        else
          {
            if (__c == __lit[::std::__num_base::_S_izero] && (!__found_zero || __base == 10))
              {
                __found_zero = true;
                 ++__sep_pos;
                if (__basefield == 0)
                  {
                    __base = 8;
                  }
                if (__base == 8)
                  {
                    __sep_pos = 0;
                  }
              }
            else
              {
                if (__found_zero && (__c == __lit[::std::__num_base::_S_ix] || __c == __lit[::std::__num_base::_S_iX]))
                  {
                    if (__basefield == 0)
                      {
                        __base = 16;
                      }
                    if (__base == 16)
                      {
                        __found_zero = false;
                        __sep_pos = 0;
                      }
                    else
                      {
                        break;
                      }
                  }
                else
                  {
                    break;
                  }
              }
          }
        if ( ++__beg != __end)
          {
            __c = *__beg;
            if (!__found_zero)
              {
                break;
              }
          }
        else
          {
            __testeof = true;
          }
      }
    const ::std::size_t __len(__base == 16 ? ::std::__num_base::_S_iend - ::std::__num_base::_S_izero : __base);
    ::std::__cxx11::string __found_grouping /* () */ ;
    if (__lc->_M_use_grouping)
      {
        __found_grouping.::std::__cxx11::basic_string<char>::reserve(32);
      }
    bool __testfail(false);
    bool __testoverflow(false);
    const __unsigned_type __max = __negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed ?  -__gnu_cxx::__numeric_traits<_ValueT>::__min : __gnu_cxx::__numeric_traits<_ValueT>::__max;
    const __unsigned_type __smax = __max / __base;
    __unsigned_type __result = 0;
    int __digit(0);
    const typename ::std::num_get<_CharT, _InIter>::char_type *__lit_zero = __lit + ::std::__num_base::_S_izero;
    if (!__lc->_M_allocated)
      {
        while (!__testeof)
          {
            __digit = (*this)._M_find(__lit_zero, __len, __c);
            if (__digit ==  -1)
              {
                break;
              }
            if (__result > __smax)
              {
                __testoverflow = true;
              }
            else
              {
                __result *= __base;
                __testoverflow |= __result > __max - __digit;
                __result += __digit;
                 ++__sep_pos;
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    else
      {
        while (!__testeof)
          {
            if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
              {
                if (__sep_pos)
                  {
                    __found_grouping += static_cast<char>(__sep_pos);
                    __sep_pos = 0;
                  }
                else
                  {
                    __testfail = true;
                    break;
                  }
              }
            else
              {
                if (__c == __lc->_M_decimal_point)
                  {
                    break;
                  }
                else
                  {
                    const typename ::std::num_get<_CharT, _InIter>::char_type *__q = __traits_type::find(__lit_zero, __len, __c);
                    if (!__q)
                      {
                        break;
                      }
                    __digit = __q - __lit_zero;
                    if (__digit > 15)
                      {
                        __digit -= 6;
                      }
                    if (__result > __smax)
                      {
                        __testoverflow = true;
                      }
                    else
                      {
                        __result *= __base;
                        __testoverflow |= __result > __max - __digit;
                        __result += __digit;
                         ++__sep_pos;
                      }
                  }
              }
            if ( ++__beg != __end)
              {
                __c = *__beg;
              }
            else
              {
                __testeof = true;
              }
          }
      }
    if (__found_grouping.::std::__cxx11::basic_string<char>::size())
      {
        __found_grouping += static_cast<char>(__sep_pos);
        if (!std::__verify_grouping(__lc->_M_grouping, __lc->_M_grouping_size, __found_grouping))
          {
            __err = ::std::ios_base::failbit;
          }
      }
    if (((!__sep_pos && !__found_zero) && !__found_grouping.::std::__cxx11::basic_string<char>::size()) || __testfail)
      {
        __v = 0;
        __err = ::std::ios_base::failbit;
      }
    else
      {
        if (__testoverflow)
          {
            if (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
              }
            else
              {
                __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
              }
            __err = ::std::ios_base::failbit;
          }
        else
          {
            __v = __negative ?  -__result : __result;
          }
      }
    if (__testeof)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, bool &__v) const 
  {
    if (!(__io.::std::ios_base::flags() & ::std::ios_base::boolalpha))
      {
        long int __l( -1);
        __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __l);
        if (__l == 0 || __l == 1)
          {
            __v = (bool)__l;
          }
        else
          {
            __v = true;
            __err = ::std::ios_base::failbit;
            if (__beg == __end)
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        bool __testf(true);
        bool __testt(true);
        bool __donef = __lc->_M_falsename_size == 0;
        bool __donet = __lc->_M_truename_size == 0;
        bool __testeof(false);
        ::std::size_t __n(0);
        while (!__donef || !__donet)
          {
            if (__beg == __end)
              {
                __testeof = true;
                break;
              }
            const typename ::std::num_get<_CharT, _InIter>::char_type __c = *__beg;
            if (!__donef)
              {
                __testf = __c == __lc->_M_falsename[__n];
              }
            if (!__testf && __donet)
              {
                break;
              }
            if (!__donet)
              {
                __testt = __c == __lc->_M_truename[__n];
              }
            if (!__testt && __donef)
              {
                break;
              }
            if (!__testt && !__testf)
              {
                break;
              }
             ++__n;
             ++__beg;
            __donef = !__testf || __n >= __lc->_M_falsename_size;
            __donet = !__testt || __n >= __lc->_M_truename_size;
          }
        if ((__testf && __n == __lc->_M_falsename_size) && __n)
          {
            __v = false;
            if (__testt && __n == __lc->_M_truename_size)
              {
                __err = ::std::ios_base::failbit;
              }
            else
              {
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
          }
        else
          {
            if ((__testt && __n == __lc->_M_truename_size) && __n)
              {
                __v = true;
                __err = __testeof ? ::std::ios_base::eofbit : ::std::ios_base::goodbit;
              }
            else
              {
                __v = false;
                __err = ::std::ios_base::failbit;
                if (__testeof)
                  {
                    __err |= ::std::ios_base::eofbit;
                  }
              }
          }
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, float &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, double &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, long double &__v) const 
  {
    ::std::__cxx11::string __xtrc /* () */ ;
    __xtrc.::std::__cxx11::basic_string<char>::reserve(32);
    __beg = (*this)._M_extract_float(__beg, __end, __io, __err, __xtrc);
    std::__convert_to_v(__xtrc.::std::__cxx11::basic_string<char>::c_str(), __v, __err, _S_get_c_locale());
    if (__beg == __end)
      {
        __err |= ::std::ios_base::eofbit;
      }
    return __beg;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>' */ 
  template < typename _CharT, typename _InIter >
  typename ::std::num_get<_CharT, _InIter>::iter_type num_get<_CharT, _InIter>::do_get(typename ::std::num_get<_CharT, _InIter>::iter_type __beg, typename ::std::num_get<_CharT, _InIter>::iter_type __end, ::std::ios_base &__io, ::std::ios_base::iostate &__err, void *&__v) const 
  {
    typedef ::std::ios_base::fmtflags fmtflags;
    const fmtflags __fmt(__io.::std::ios_base::flags());
    __io.::std::ios_base::flags(__fmt &  ~::std::ios_base::basefield | ::std::ios_base::hex);
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    _UIntPtrType __ul;
    __beg = (*this)._M_extract_int(__beg, __end, __io, __err, __ul);
    __io.::std::ios_base::flags(__fmt);
    __v = reinterpret_cast<void *>(__ul);
    return __beg;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_pad(_CharT __fill, ::std::streamsize __w, ::std::ios_base &__io, _CharT *__new, const _CharT *__cs, int &__len) const 
  {
    __pad<_CharT, ::std::char_traits<_CharT> >::_S_pad(__io, __fill, __new, __cs, __w, __len);
    __len = static_cast<int>(__w);
  }
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec);
  template < typename _CharT, typename _ValueT >
  int __int_to_char(_CharT *__bufend, _ValueT __v, const _CharT *__lit, ::std::ios_base::fmtflags __flags, bool __dec)
  {
    _CharT *__buf = __bufend;
    if (__builtin_expect(__dec, true))
      {
        do
          {
            * --__buf = __lit[__v % 10 + ::std::__num_base::_S_odigits];
            __v /= 10;
          }
        while (__v != 0);
      }
    else
      {
        if ((__flags & ::std::ios_base::basefield) == ::std::ios_base::oct)
          {
            do
              {
                * --__buf = __lit[(__v & 7) + ::std::__num_base::_S_odigits];
                __v >>= 3;
              }
            while (__v != 0);
          }
        else
          {
            const bool __uppercase(__flags & ::std::ios_base::uppercase);
            const int __case_offset(__uppercase ? ::std::__num_base::_S_oudigits : ::std::__num_base::_S_odigits);
            do
              {
                * --__buf = __lit[(__v & 15) + __case_offset];
                __v >>= 4;
              }
            while (__v != 0);
          }
      }
    return __bufend - __buf;
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_int(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, ::std::ios_base &, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    _CharT *__p = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __len);
    __len = __p - __new;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_int(_OutIter __s, ::std::ios_base &__io, _CharT __fill, _ValueT __v) const 
  {
    using ::__gnu_cxx::__add_unsigned;
    typedef typename ::__gnu_cxx::__add_unsigned<_ValueT>::__type __unsigned_type;
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const _CharT *__lit = __lc->_M_atoms_out;
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const int __ilen = 5 * sizeof(_ValueT);
    _CharT *__cs = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __ilen));
    const ::std::ios_base::fmtflags __basefield(__flags & ::std::ios_base::basefield);
    const bool __dec(__basefield != ::std::ios_base::oct && __basefield != ::std::ios_base::hex);
    const __unsigned_type __u = (__v > 0 || !__dec ? __unsigned_type(__v) :  -__unsigned_type(__v));
    int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
    __cs += __ilen - __len;
    if (__lc->_M_use_grouping)
      {
        _CharT *__cs2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * (__len + 1) * 2));
        (*this)._M_group_int(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
        __cs = __cs2 + 2;
      }
    if (__builtin_expect(__dec, true))
      {
        if (__v >= 0)
          {
            if ((bool)(__flags & ::std::ios_base::showpos) && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
              {
                (* --__cs = __lit[::std::__num_base::_S_oplus],  ++__len);
              }
          }
        else
          {
            (* --__cs = __lit[::std::__num_base::_S_ominus],  ++__len);
          }
      }
    else
      {
        if ((bool)(__flags & ::std::ios_base::showbase) && __v)
          {
            if (__basefield == ::std::ios_base::oct)
              {
                (* --__cs = __lit[::std::__num_base::_S_odigits],  ++__len);
              }
            else
              {
                const bool __uppercase(__flags & ::std::ios_base::uppercase);
                * --__cs = __lit[::std::__num_base::_S_ox + __uppercase];
                * --__cs = __lit[::std::__num_base::_S_odigits];
                __len += 2;
              }
          }
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__cs3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __cs3, __cs, __len);
        __cs = __cs3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __cs, __len);
  }
  template < typename _CharT, typename _OutIter >
  void num_put<_CharT, _OutIter>::_M_group_float(const char *__grouping, ::std::size_t __grouping_size, _CharT __sep, const _CharT *__p, _CharT *__new, _CharT *__cs, int &__len) const 
  {
    const int __declen = __p ? __p - __cs : __len;
    _CharT *__p2 = std::__add_grouping(__new, __sep, __grouping, __grouping_size, __cs, __cs + __declen);
    int __newlen = __p2 - __new;
    if (__p)
      {
        char_traits<_CharT>::copy(__p2, __p, __len - __declen);
        __newlen += __len - __declen;
      }
    __len = __newlen;
  }
  template < typename _CharT, typename _OutIter >
  template < typename _ValueT >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::_M_insert_float(_OutIter __s, ::std::ios_base &__io, _CharT __fill, char __mod, _ValueT __v) const 
  {
    typedef ::std::__numpunct_cache<_CharT> __cache_type;
    ::std::__use_cache<__cache_type> __uc;
    const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
    const __cache_type *__lc = __uc(__loc);
    const ::std::streamsize __prec(__io.::std::ios_base::precision() < 0 ? 6 : __io.::std::ios_base::precision());
    const int __max_digits = __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
    int __len;
    char __fbuf[16L];
    __num_base::_S_format_float(__io, __fbuf, __mod);
    const bool __use_prec((__io.::std::ios_base::flags() & ::std::ios_base::floatfield) != ::std::ios_base::floatfield);
    int __cs_size = __max_digits * 3;
    char *__cs(static_cast<char *>(__builtin_alloca(__cs_size)));
    if (__use_prec)
      {
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
      }
    else
      {
        __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
      }
    if (__len >= __cs_size)
      {
        __cs_size = __len + 1;
        __cs = static_cast<char *>(__builtin_alloca(__cs_size));
        if (__use_prec)
          {
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __prec, __v);
          }
        else
          {
            __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size, __fbuf, __v);
          }
      }
    const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
    _CharT *__ws = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len));
    __ctype.widen(__cs, __cs + __len, __ws);
    _CharT *__wp = 0;
    const char *__p = char_traits<char>::find(__cs, __len, '.');
    if (__p)
      {
        __wp = __ws + (__p - __cs);
        *__wp = __lc->_M_decimal_point;
      }
    if (__lc->_M_use_grouping && ((__wp || __len < 3) || (((__cs[1] <= '9' && __cs[2] <= '9') && __cs[1] >= '0') && __cs[2] >= '0')))
      {
        _CharT *__ws2 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __len * 2));
        ::std::streamsize __off(0);
        if (__cs[0] == '-' || __cs[0] == '+')
          {
            __off = 1;
            __ws2[0] = __ws[0];
            __len -= 1;
          }
        (*this)._M_group_float(__lc->_M_grouping, __lc->_M_grouping_size, __lc->_M_thousands_sep, __wp, __ws2 + __off, __ws + __off, __len);
        __len += __off;
        __ws = __ws2;
      }
    const ::std::streamsize __w(__io.::std::ios_base::width());
    if (__w > static_cast< ::std::streamsize>(__len))
      {
        _CharT *__ws3 = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __w));
        (*this)._M_pad(__fill, __w, __io, __ws3, __ws, __len);
        __ws = __ws3;
      }
    __io.::std::ios_base::width(0);
    return std::__write(__s, __ws, __len);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, bool __v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    if ((__flags & ::std::ios_base::boolalpha) == 0)
      {
        const long int __l(__v);
        __s = (*this)._M_insert_int(__s, __io, __fill, __l);
      }
    else
      {
        typedef ::std::__numpunct_cache<_CharT> __cache_type;
        ::std::__use_cache<__cache_type> __uc;
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const __cache_type *__lc = __uc(__loc);
        const _CharT *__name = __v ? __lc->_M_truename : __lc->_M_falsename;
        int __len = __v ? __lc->_M_truename_size : __lc->_M_falsename_size;
        const ::std::streamsize __w(__io.::std::ios_base::width());
        if (__w > static_cast< ::std::streamsize>(__len))
          {
            const ::std::streamsize __plen = __w - __len;
            _CharT *__ps = static_cast<_CharT *>(__builtin_alloca(sizeof(_CharT) * __plen));
            char_traits<_CharT>::assign(__ps, __plen, __fill);
            __io.::std::ios_base::width(0);
            if ((__flags & ::std::ios_base::adjustfield) == ::std::ios_base::left)
              {
                __s = std::__write(__s, __name, __len);
                __s = std::__write(__s, __ps, __plen);
              }
            else
              {
                __s = std::__write(__s, __ps, __plen);
                __s = std::__write(__s, __name, __len);
              }
            return __s;
          }
        __io.::std::ios_base::width(0);
        __s = std::__write(__s, __name, __len);
      }
    return __s;
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, char(), __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, long double __v) const 
  {
    return (*this)._M_insert_float(__s, __io, __fill, 'L', __v);
  }
  template < typename _CharT, typename _OutIter >
  typename ::std::num_put<_CharT, _OutIter>::iter_type num_put<_CharT, _OutIter>::do_put(typename ::std::num_put<_CharT, _OutIter>::iter_type __s, ::std::ios_base &__io, typename ::std::num_put<_CharT, _OutIter>::char_type __fill, const void *__v) const 
  {
    const ::std::ios_base::fmtflags __flags(__io.::std::ios_base::flags());
    const ::std::ios_base::fmtflags __fmt( ~(::std::ios_base::basefield | ::std::ios_base::uppercase));
    __io.::std::ios_base::flags(__flags & __fmt | (::std::ios_base::hex | ::std::ios_base::showbase));
    typedef ::__gnu_cxx::__conditional_type<true, unsigned long int, unsigned long long int>::__type _UIntPtrType;
    __s = (*this)._M_insert_int(__s, __io, __fill, reinterpret_cast<_UIntPtrType>(__v));
    __io.::std::ios_base::flags(__flags);
    return __s;
  }
  template < typename _CharT, typename _Traits >
  void __pad<_CharT, _Traits>::_S_pad(::std::ios_base &__io, _CharT __fill, _CharT *__news, const _CharT *__olds, ::std::streamsize __newlen, ::std::streamsize __oldlen)
  {
    const ::std::size_t __plen(static_cast< ::std::size_t>(__newlen - __oldlen));
    const ::std::ios_base::fmtflags __adjust(__io.::std::ios_base::flags() & ::std::ios_base::adjustfield);
    if (__adjust == ::std::ios_base::left)
      {
        _Traits::copy(__news, __olds, __oldlen);
        _Traits::assign(__news + __oldlen, __plen, __fill);
        return ;
      }
    ::std::size_t __mod(0);
    if (__adjust == ::std::ios_base::internal)
      {
        const ::std::locale &__loc(__io.::std::ios_base::_M_getloc());
        const ::std::ctype<_CharT> &__ctype = use_facet< ::std::ctype<_CharT> >(__loc);
        if (__ctype.widen('-') == __olds[0] || __ctype.widen('+') == __olds[0])
          {
            __news[0] = __olds[0];
            __mod = 1;
             ++__news;
          }
        else
          {
            if ((__ctype.widen('0') == __olds[0] && __oldlen > 1) && (__ctype.widen('x') == __olds[1] || __ctype.widen('X') == __olds[1]))
              {
                __news[0] = __olds[0];
                __news[1] = __olds[1];
                __mod = 2;
                __news += 2;
              }
          }
      }
    _Traits::assign(__news, __plen, __fill);
    _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
  }
  template < typename _CharT >
  _CharT *__add_grouping(_CharT *__s, _CharT __sep, const char *__gbeg, ::std::size_t __gsize, const _CharT *__first, const _CharT *__last)
  {
    ::std::size_t __idx(0);
    ::std::size_t __ctr(0);
    while ((__last - __first > __gbeg[__idx] && static_cast<signed char>(__gbeg[__idx]) > 0) && __gbeg[__idx] != ::__gnu_cxx::__numeric_traits_integer<char>::__max)
      {
        __last -= __gbeg[__idx];
        __idx < __gsize - 1 ?  ++__idx :  ++__ctr;
      }
    while (__first != __last)
      {
        *__s++ = *__first++;
      }
    while (__ctr--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    while (__idx--)
      {
        *__s++ = __sep;
        for (char __i(__gbeg[__idx]); __i > 0;  --__i)
          {
            *__s++ = *__first++;
          }
      }
    return __s;
  }
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::numpunct<char>;
    extern template class ::std::__cxx11::numpunct_byname<char>;
  }
  extern template class ::std::num_get<char>;
  extern template class ::std::num_put<char>;
  extern template class ::std::ctype_byname<char>;
  extern template const ::std::ctype<char> &use_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template const ::std::__cxx11::numpunct<char> &use_facet< ::std::__cxx11::numpunct<char> >(const ::std::locale &);
  extern template const ::std::num_put<char> &use_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template const ::std::num_get<char> &use_facet< ::std::num_get<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::numpunct<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<char> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<char> >(const ::std::locale &);
  inline namespace __cxx11 __attribute__((__abi_tag__("cxx11"))) {
    extern template class ::std::__cxx11::numpunct<wchar_t>;
    extern template class ::std::__cxx11::numpunct_byname<wchar_t>;
  }
  extern template class ::std::num_get<wchar_t>;
  extern template class ::std::num_put<wchar_t>;
  extern template class ::std::ctype_byname<wchar_t>;
  extern template const ::std::ctype<wchar_t> &use_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template const ::std::__cxx11::numpunct<wchar_t> &use_facet< ::std::__cxx11::numpunct<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_put<wchar_t> &use_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template const ::std::num_get<wchar_t> &use_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::ctype<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::__cxx11::numpunct<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_put<wchar_t> >(const ::std::locale &);
  extern template bool has_facet< ::std::num_get<wchar_t> >(const ::std::locale &);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f);
  template < typename _Facet >
  inline const _Facet &__check_facet(const _Facet *__f)
  {
    if (!__f)
      {
        ::std::__throw_bad_cast();
      }
    return *__f;
  }
  template < typename _CharT, typename _Traits >
  class  basic_ios : public ::std::ios_base
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
    protected:
      ::std::basic_ostream<_CharT, _Traits> *_M_tie;
      mutable typename ::std::basic_ios<_CharT, _Traits>::char_type _M_fill;
      mutable bool _M_fill_init;
      ::std::basic_streambuf<_CharT, _Traits> *_M_streambuf;
      const typename ::std::basic_ios<_CharT, _Traits>::__ctype_type *_M_ctype;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_put_type *_M_num_put;
      const typename ::std::basic_ios<_CharT, _Traits>::__num_get_type *_M_num_get;
    public:
      inline explicit operator bool() const 
      {
        return !this->fail();
      }
      inline bool operator !() const 
      {
        return this->fail();
      }
      inline ::std::ios_base::iostate rdstate() const 
      {
        return (*this)._M_streambuf_state;
      }
      void clear(::std::ios_base::iostate __state  = (::std::ios_base::goodbit));
      inline void setstate(::std::ios_base::iostate __state)
      {
        this->clear(this->rdstate() | __state);
      }
      inline void _M_setstate(::std::ios_base::iostate __state)
      {
        (*this)._M_streambuf_state |= __state;
        if (this->exceptions() & __state)
          {
            throw;
          }
      }
      inline bool good() const 
      {
        return this->rdstate() == 0;
      }
      inline bool eof() const 
      {
        return (this->rdstate() & ::std::ios_base::eofbit) != 0;
      }
      inline bool fail() const 
      {
        return (this->rdstate() & (::std::ios_base::badbit | ::std::ios_base::failbit)) != 0;
      }
      inline bool bad() const 
      {
        return (this->rdstate() & ::std::ios_base::badbit) != 0;
      }
      inline ::std::ios_base::iostate exceptions() const 
      {
        return (*this)._M_exception;
      }
      inline void exceptions(::std::ios_base::iostate __except)
      {
        (*this)._M_exception = __except;
        this->clear((*this)._M_streambuf_state);
      }
      inline explicit basic_ios(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ios()
      {
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_tie;
      }
      inline ::std::basic_ostream<_CharT, _Traits> *tie(::std::basic_ostream<_CharT, _Traits> *__tiestr)
      {
        ::std::basic_ostream<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_tie;
        ::std::basic_ios<_CharT, _Traits>::_M_tie = __tiestr;
        return __old;
      }
      inline ::std::basic_streambuf<_CharT, _Traits> *rdbuf() const 
      {
        return ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
      }
      ::std::basic_streambuf<_CharT, _Traits> *rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb);
      ::std::basic_ios<_CharT, _Traits> &copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs);
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill() const 
      {
        if (!::std::basic_ios<_CharT, _Traits>::_M_fill_init)
          {
            ::std::basic_ios<_CharT, _Traits>::_M_fill = this->widen(' ');
            ::std::basic_ios<_CharT, _Traits>::_M_fill_init = true;
          }
        return ::std::basic_ios<_CharT, _Traits>::_M_fill;
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type fill(typename ::std::basic_ios<_CharT, _Traits>::char_type __ch)
      {
        typename ::std::basic_ios<_CharT, _Traits>::char_type __old = this->fill();
        ::std::basic_ios<_CharT, _Traits>::_M_fill = __ch;
        return __old;
      }
      ::std::locale imbue(const ::std::locale &__loc);
      inline char narrow(typename ::std::basic_ios<_CharT, _Traits>::char_type __c, char __dfault) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).narrow(__c, __dfault);
      }
      inline typename ::std::basic_ios<_CharT, _Traits>::char_type widen(char __c) const 
      {
        return __check_facet(::std::basic_ios<_CharT, _Traits>::_M_ctype).widen(__c);
      }
    protected:
      inline basic_ios()
        : ios_base(), _M_tie(0), _M_fill(((typename ::std::basic_ios<_CharT, _Traits>::char_type()))), _M_fill_init(false), _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      {
      }
      void init(::std::basic_streambuf<_CharT, _Traits> *__sb);
      basic_ios(const ::std::basic_ios<_CharT, _Traits> &) = delete ;
      ::std::basic_ios<_CharT, _Traits> &operator =(const ::std::basic_ios<_CharT, _Traits> &) = delete ;
      inline void move(::std::basic_ios<_CharT, _Traits> &__rhs)
      {
        ios_base::_M_move(__rhs);
        (*this)._M_cache_locale((*this)._M_ios_locale);
        this->tie(__rhs.tie(nullptr));
        ::std::basic_ios<_CharT, _Traits>::_M_fill = __rhs._M_fill;
        ::std::basic_ios<_CharT, _Traits>::_M_fill_init = __rhs._M_fill_init;
        ::std::basic_ios<_CharT, _Traits>::_M_streambuf = nullptr;
      }
      inline void move(::std::basic_ios<_CharT, _Traits> &&__rhs)
      {
        this->move(__rhs);
      }
      inline void swap(::std::basic_ios<_CharT, _Traits> &__rhs) noexcept(true)
      {
        ios_base::_M_swap(__rhs);
        (*this)._M_cache_locale((*this)._M_ios_locale);
        __rhs._M_cache_locale(__rhs._M_ios_locale);
        std::swap(::std::basic_ios<_CharT, _Traits>::_M_tie, __rhs._M_tie);
        std::swap(::std::basic_ios<_CharT, _Traits>::_M_fill, __rhs._M_fill);
        std::swap(::std::basic_ios<_CharT, _Traits>::_M_fill_init, __rhs._M_fill_init);
      }
      inline void set_rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb)
      {
        ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
      }
      void _M_cache_locale(const ::std::locale &__loc);
  };
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::clear(::std::ios_base::iostate __state)
  {
    if (this->rdbuf())
      {
        (*this)._M_streambuf_state = __state;
      }
    else
      {
        (*this)._M_streambuf_state = __state | ::std::ios_base::badbit;
      }
    if (this->exceptions() & this->rdstate())
      {
        ::std::__throw_ios_failure("basic_ios::clear");
      }
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_streambuf<_CharT, _Traits> *basic_ios<_CharT, _Traits>::rdbuf(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ::std::basic_streambuf<_CharT, _Traits> *__old = ::std::basic_ios<_CharT, _Traits>::_M_streambuf;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    this->clear();
    return __old;
  }
 /* Instantiation of class template '::std::is_error_code_enum< ::std::ios_base::_Words *>' */ 
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::ios_base::_Words *>' */ 
  template < typename _CharT, typename _Traits >
  ::std::basic_ios<_CharT, _Traits> &basic_ios<_CharT, _Traits>::copyfmt(const ::std::basic_ios<_CharT, _Traits> &__rhs)
  {
    if (this != &__rhs)
      {
        ::std::ios_base::_Words *__words = __rhs._M_word_size <= ::std::ios_base::_S_local_word_size ? (*this)._M_local_word : new ::std::ios_base::_Words [__rhs._M_word_size];
        ::std::ios_base::_Callback_list *__cb = __rhs._M_callbacks;
        if (__cb)
          {
            (*__cb).::std::ios_base::_Callback_list::_M_add_reference();
          }
        (*this)._M_call_callbacks(::std::ios_base::erase_event);
        if ((*this)._M_word != (*this)._M_local_word)
          {
            delete[] (*this)._M_word;
            (*this)._M_word = 0;
          }
        (*this)._M_dispose_callbacks();
        (*this)._M_callbacks = __cb;
        for (int __i(0); __i < __rhs._M_word_size;  ++__i)
          {
            __words[__i] = __rhs._M_word[__i];
          }
        (*this)._M_word = __words;
        (*this)._M_word_size = __rhs._M_word_size;
        this->flags(__rhs.flags());
        this->width(__rhs.width());
        this->precision(__rhs.precision());
        this->tie(__rhs.tie());
        this->fill(__rhs.fill());
        (*this)._M_ios_locale = __rhs.getloc();
        (*this)._M_cache_locale((*this)._M_ios_locale);
        (*this)._M_call_callbacks(::std::ios_base::copyfmt_event);
        this->exceptions(__rhs.exceptions());
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::locale basic_ios<_CharT, _Traits>::imbue(const ::std::locale &__loc)
  {
    ::std::locale __old(this->getloc());
    ios_base::imbue(__loc);
    (*this)._M_cache_locale(__loc);
    if (this->rdbuf() != 0)
      {
        this->rdbuf()->pubimbue(__loc);
      }
    return __old;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::init(::std::basic_streambuf<_CharT, _Traits> *__sb)
  {
    ios_base::_M_init();
    (*this)._M_cache_locale((*this)._M_ios_locale);
    ::std::basic_ios<_CharT, _Traits>::_M_fill = _CharT();
    ::std::basic_ios<_CharT, _Traits>::_M_fill_init = false;
    ::std::basic_ios<_CharT, _Traits>::_M_tie = 0;
    (*this)._M_exception = ::std::ios_base::goodbit;
    ::std::basic_ios<_CharT, _Traits>::_M_streambuf = __sb;
    (*this)._M_streambuf_state = __sb ? ::std::ios_base::goodbit : ::std::ios_base::badbit;
  }
  template < typename _CharT, typename _Traits >
  void basic_ios<_CharT, _Traits>::_M_cache_locale(const ::std::locale &__loc)
  {
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__ctype_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_ctype = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_put_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_put = 0;
      }
    if (__builtin_expect(has_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc), true))
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = &use_facet<typename ::std::basic_ios<_CharT, _Traits>::__num_get_type>(__loc);
      }
    else
      {
        ::std::basic_ios<_CharT, _Traits>::_M_num_get = 0;
      }
  }
  extern template class ::std::basic_ios<char>;
  extern template class ::std::basic_ios<wchar_t>;
  template < typename _CharT, typename _Traits >
  class  basic_ostream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef ::std::num_put<_CharT, ::std::ostreambuf_iterator<_CharT, _Traits> > __num_put_type;
      typedef ::std::ctype<_CharT> __ctype_type;
      inline explicit basic_ostream(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sb)
      {
        this->init(__sb);
      }
      inline virtual ~basic_ostream()
      {
      }
      class sentry;
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_ostream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(bool __n)
      {
        return (*this)._M_insert(__n);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(short int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned short int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(int __n);
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned int __n)
      {
        return (*this)._M_insert(static_cast<unsigned long int>(__n));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(unsigned long long int __n)
      {
        return (*this)._M_insert(__n);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(float __f)
      {
        return (*this)._M_insert(static_cast<double>(__f));
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(long double __f)
      {
        return (*this)._M_insert(__f);
      }
      inline typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(const void *__p)
      {
        return (*this)._M_insert(__p);
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c);
      inline void _M_write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        const ::std::streamsize __put = this->rdbuf()->sputn(__s, __n);
        if (__put != __n)
          {
            this->setstate(::std::ios_base::badbit);
          }
      }
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &write(const typename ::std::basic_ostream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &flush();
      typename ::std::basic_ostream<_CharT, _Traits>::pos_type tellp();
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_ostream()
      {
        this->init(0);
      }
      inline basic_ostream(::std::basic_iostream<_CharT, _Traits> &)
      {
      }
      basic_ostream(const ::std::basic_ostream<_CharT, _Traits> &) = delete ;
      inline basic_ostream(::std::basic_ostream<_CharT, _Traits> &&__rhs)
        : __ios_type()
      {
        __ios_type::move(__rhs);
      }
      ::std::basic_ostream<_CharT, _Traits> &operator =(const ::std::basic_ostream<_CharT, _Traits> &) = delete ;
      inline ::std::basic_ostream<_CharT, _Traits> &operator =(::std::basic_ostream<_CharT, _Traits> &&__rhs)
      {
        (*this).swap(__rhs);
        return *this;
      }
      inline void swap(::std::basic_ostream<_CharT, _Traits> &__rhs)
      {
        __ios_type::swap(__rhs);
      }
      template < typename _ValueT >
      typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &_M_insert(_ValueT __v);
    friend class sentry;
  };
  template < typename _CharT, typename _Traits >
  class  basic_ostream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
      ::std::basic_ostream<_CharT, _Traits> &_M_os;
    public:
      explicit sentry(::std::basic_ostream<_CharT, _Traits> &__os);
      inline ~sentry()
      {
        if (bool(::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.flags() & ::std::ios_base::unitbuf) && !::std::uncaught_exception())
          {
            if (::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf() && ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.rdbuf()->pubsync() ==  -1)
              {
                ::std::basic_ostream<_CharT, _Traits>::sentry::_M_os.setstate(::std::ios_base::badbit);
              }
          }
      }
      inline explicit operator bool() const 
      {
        return ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, _CharT __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, char __c)
  {
    return __out << __out.widen(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, char __c)
  {
    return __ostream_insert(__out, &__c, 1);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, signed char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, unsigned char __c)
  {
    return __out << static_cast<char>(__c);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const _CharT *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        __ostream_insert(__out, __s, static_cast< ::std::streamsize>(_Traits::length(__s)));
      }
    return __out;
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const signed char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_ostream<char, _Traits> &operator <<(::std::basic_ostream<char, _Traits> &__out, const unsigned char *__s)
  {
    return __out << reinterpret_cast<const char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &endl(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return flush(__os.put(__os.widen('\n')));
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &ends(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.put(_CharT());
  }
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os);
  template < typename _CharT, typename _Traits >
  inline ::std::basic_ostream<_CharT, _Traits> &flush(::std::basic_ostream<_CharT, _Traits> &__os)
  {
    return __os.flush();
  }
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &&__os, const _Tp &__x);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &&__os, const _Tp &__x)
  {
    __os << __x;
    return __os;
  }
  template < typename _CharT, typename _Traits >
  basic_ostream<_CharT, _Traits>::sentry::sentry(::std::basic_ostream<_CharT, _Traits> &__os)
    : _M_ok(false), _M_os(__os)
  {
    if (__os.tie() && __os.good())
      {
        __os.tie()->flush();
      }
    if (__os.good())
      {
        ::std::basic_ostream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __os.setstate(::std::ios_base::failbit);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::_M_insert(_ValueT __v)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::__num_put_type &__np = __check_facet(this->_M_num_put);
          if (__np.put(*this, *this, this->fill(), __v).failed())
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(short int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned short int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(int __n)
  {
    const ::std::ios_base::fmtflags __fmt = this->flags() & ::std::ios_base::basefield;
    if (__fmt == ::std::ios_base::oct || __fmt == ::std::ios_base::hex)
      {
        return (*this)._M_insert(static_cast<long int>(static_cast<unsigned int>(__n)));
      }
    else
      {
        return (*this)._M_insert(static_cast<long int>(__n));
      }
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::operator <<(typename ::std::basic_ostream<_CharT, _Traits>::__streambuf_type *__sbin)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb && __sbin)
      {
        try
        {
          if (!__copy_streambufs(__sbin, this->rdbuf()))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbin)
          {
            __err |= ::std::ios_base::badbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::put(typename ::std::basic_ostream<_CharT, _Traits>::char_type __c)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::int_type __put = this->rdbuf()->sputc(__c);
          if (traits_type::eq_int_type(__put, traits_type::eof()))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::write(const _CharT *__s, ::std::streamsize __n)
  {
    typename ::std::basic_ostream<_CharT, _Traits>::sentry __cerb(*this);
    if (__cerb)
      {
        try
        {
          (*this)._M_write(__s, __n);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::flush()
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (this->rdbuf() && this->rdbuf()->pubsync() ==  -1)
        {
          __err |= ::std::ios_base::badbit;
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::pos_type basic_ostream<_CharT, _Traits>::tellp()
  {
    typename ::std::basic_ostream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type( -1)));
    try
    {
      if (!this->fail())
        {
          __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::out);
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::pos_type __pos)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_ostream<_CharT, _Traits>::__ostream_type &basic_ostream<_CharT, _Traits>::seekp(typename ::std::basic_ostream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    try
    {
      if (!this->fail())
        {
          const typename ::std::basic_ostream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::out);
          if (__p == ((typename ::std::basic_ostream<_CharT, _Traits>::pos_type(((typename ::std::basic_ostream<_CharT, _Traits>::off_type( -1)))))))
            {
              __err |= ::std::ios_base::failbit;
            }
        }
    }
    catch (::__cxxabiv1::__forced_unwind &)
    {
      this->_M_setstate(::std::ios_base::badbit);
      throw;
    }
    catch (...)
    {
      this->_M_setstate(::std::ios_base::badbit);
    }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_ostream<_CharT, _Traits> &operator <<(::std::basic_ostream<_CharT, _Traits> &__out, const char *__s)
  {
    if (!__s)
      {
        __out.setstate(::std::ios_base::badbit);
      }
    else
      {
        const ::std::size_t __clen(char_traits<char>::length(__s));
        try
        {
          struct  __ptr_guard
          {
              _CharT *__p;
              inline __ptr_guard(_CharT *__ip)
                : __p(__ip)
              {
              }
              inline ~__ptr_guard()
              {
                delete[] __ptr_guard::__p;
              }
              inline _CharT *__get()
              {
                return __ptr_guard::__p;
              }
          };
          __ptr_guard __pg(new _CharT [__clen]);
          _CharT *__ws = __pg.__get();
          for (::std::size_t __i(0); __i < __clen;  ++__i)
            {
              __ws[__i] = __out.widen(__s[__i]);
            }
          __ostream_insert(__out, __ws, __clen);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __out._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __out._M_setstate(::std::ios_base::badbit);
        }
      }
    return __out;
  }
  extern template class ::std::basic_ostream<char>;
  extern template ::std::basic_ostream<char> &endl(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &ends(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &flush(::std::basic_ostream<char> &);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, unsigned char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, signed char);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const unsigned char *);
  extern template ::std::basic_ostream<char> &operator <<(::std::basic_ostream<char> &, const signed char *);
 /* Instantiation of class template '::std::basic_ios<char>' */ 
 /* Instantiation of class template '::std::basic_ostream<char>' */ 
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(bool);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(long double);
  extern template ::std::basic_ostream<char> &ostream::_M_insert(const void *);
  extern template class ::std::basic_ostream<wchar_t>;
  extern template ::std::basic_ostream<wchar_t> &endl(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &ends(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &flush(::std::basic_ostream<wchar_t> &);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, wchar_t);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, char);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const wchar_t *);
  extern template ::std::basic_ostream<wchar_t> &operator <<(::std::basic_ostream<wchar_t> &, const char *);
 /* Instantiation of class template '::std::basic_ios<wchar_t>' */ 
 /* Instantiation of class template '::std::basic_ostream<wchar_t>' */ 
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(bool);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(unsigned long long int);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(long double);
  extern template ::std::basic_ostream<wchar_t> &wostream::_M_insert(const void *);
  template < typename _CharT, typename _Traits >
  class  basic_istream : virtual public ::std::basic_ios<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_ios<_CharT, _Traits> __ios_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::num_get<_CharT, ::std::istreambuf_iterator<_CharT, _Traits> > __num_get_type;
      typedef ::std::ctype<_CharT> __ctype_type;
    protected:
      ::std::streamsize _M_gcount;
    public:
      inline explicit basic_istream(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb)
        : _M_gcount((long int)0)
      {
        this->init(__sb);
      }
      inline virtual ~basic_istream()
      {
        ::std::basic_istream<_CharT, _Traits>::_M_gcount = (long int)0;
      }
      class sentry;
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__istream_type &))
      {
        return __pf(*this);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &(*__pf)(typename ::std::basic_istream<_CharT, _Traits>::__ios_type &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(::std::ios_base &(*__pf)(::std::ios_base &))
      {
        __pf(*this);
        return *this;
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(bool &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(short int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned short int &__n)
      {
        return (*this)._M_extract(__n);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(int &__n);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(unsigned long long int &__n)
      {
        return (*this)._M_extract(__n);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(float &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(long double &__f)
      {
        return (*this)._M_extract(__f);
      }
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(void *&__p)
      {
        return (*this)._M_extract(__p);
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout);
      inline ::std::streamsize gcount() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
      }
      typename ::std::basic_istream<_CharT, _Traits>::int_type get();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->get(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb)
      {
        return this->get(__sb, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim);
      inline typename ::std::basic_istream<_CharT, _Traits>::__istream_type &getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
      {
        return this->getline(__s, __n, this->widen('\n'));
      }
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore(::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &ignore();
      typename ::std::basic_istream<_CharT, _Traits>::int_type peek();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      ::std::streamsize readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &unget();
      int sync();
      typename ::std::basic_istream<_CharT, _Traits>::pos_type tellg();
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos);
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir);
    protected:
      inline basic_istream()
        : _M_gcount((long int)0)
      {
        this->init(0);
      }
      basic_istream(const ::std::basic_istream<_CharT, _Traits> &) = delete ;
      inline basic_istream(::std::basic_istream<_CharT, _Traits> &&__rhs)
        : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
        __ios_type::move(__rhs);
        __rhs._M_gcount = 0;
      }
      ::std::basic_istream<_CharT, _Traits> &operator =(const ::std::basic_istream<_CharT, _Traits> &) = delete ;
      inline ::std::basic_istream<_CharT, _Traits> &operator =(::std::basic_istream<_CharT, _Traits> &&__rhs)
      {
        (*this).swap(__rhs);
        return *this;
      }
      inline void swap(::std::basic_istream<_CharT, _Traits> &__rhs)
      {
        __ios_type::swap(__rhs);
        std::swap(::std::basic_istream<_CharT, _Traits>::_M_gcount, __rhs._M_gcount);
      }
      template < typename _ValueT >
      typename ::std::basic_istream<_CharT, _Traits>::__istream_type &_M_extract(_ValueT &__v);
    friend class sentry;
  };
 /* Instantiation of class template '::std::basic_istream<char>' */ 
  template <>
  ::std::basic_istream<char> &basic_istream<char>::getline(char *__s, long int __n, char __delim);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n);
  template <>
  ::std::basic_istream<char> &basic_istream<char>::ignore(long int __n, ::std::char_traits<char>::int_type __delim);
 /* Instantiation of class template '::std::basic_istream<wchar_t>' */ 
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::getline(wchar_t *__s, long int __n, wchar_t __delim);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n);
  template <>
  ::std::basic_istream<wchar_t> &basic_istream<wchar_t>::ignore(long int __n, ::std::char_traits<wchar_t>::int_type __delim);
  template < typename _CharT, typename _Traits >
  class  basic_istream<_CharT, _Traits>::sentry
  {
      bool _M_ok;
    public:
      typedef _Traits traits_type;
      typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename ::std::basic_istream<_CharT, _Traits>::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip  = (false));
      inline explicit operator bool() const 
      {
        return ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok;
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char &__c)
  {
    return __in >> reinterpret_cast<char &>(__c);
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s);
  template <>
  ::std::basic_istream<char> &operator >><char, ::std::char_traits<char> >(::std::basic_istream<char> &__in, char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, unsigned char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s);
  template < typename _Traits >
  inline ::std::basic_istream<char, _Traits> &operator >>(::std::basic_istream<char, _Traits> &__in, signed char *__s)
  {
    return __in >> reinterpret_cast<char *>(__s);
  }
  template < typename _CharT, typename _Traits >
  class  basic_iostream : public ::std::basic_istream<_CharT, _Traits>, public ::std::basic_ostream<_CharT, _Traits>
  {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
      typedef ::std::basic_ostream<_CharT, _Traits> __ostream_type;
      inline explicit basic_iostream(::std::basic_streambuf<_CharT, _Traits> *__sb)
        : __istream_type(__sb), __ostream_type(__sb)
      {
      }
      inline virtual ~basic_iostream()
      {
      }
    protected:
      inline basic_iostream()
        : __istream_type(), __ostream_type()
      {
      }
      basic_iostream(const ::std::basic_iostream<_CharT, _Traits> &) = delete ;
      inline basic_iostream(::std::basic_iostream<_CharT, _Traits> &&__rhs)
        : __istream_type(std::move(__rhs)), __ostream_type(*this)
      {
      }
      ::std::basic_iostream<_CharT, _Traits> &operator =(const ::std::basic_iostream<_CharT, _Traits> &) = delete ;
      inline ::std::basic_iostream<_CharT, _Traits> &operator =(::std::basic_iostream<_CharT, _Traits> &&__rhs)
      {
        (*this).swap(__rhs);
        return *this;
      }
      inline void swap(::std::basic_iostream<_CharT, _Traits> &__rhs)
      {
        __istream_type::swap(__rhs);
      }
  };
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &&__is, _Tp &__x);
  template < typename _CharT, typename _Traits, typename _Tp >
  inline ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &&__is, _Tp &__x)
  {
    __is >> __x;
    return __is;
  }
 /* Instantiation of class template '::std::is_error_code_enum< ::std::_Ios_Iostate>' */ 
 /* Instantiation of class template '::std::is_error_condition_enum< ::std::_Ios_Iostate>' */ 
  template < typename _CharT, typename _Traits >
  basic_istream<_CharT, _Traits>::sentry::sentry(::std::basic_istream<_CharT, _Traits> &__in, bool __noskip)
    : _M_ok(false)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    if (__in.good())
      {
        if (__in.tie())
          {
            __in.tie()->flush();
          }
        if (!__noskip && bool(__in.flags() & ::std::ios_base::skipws))
          {
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __eof = traits_type::eof();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__streambuf_type *__sb = __in.rdbuf();
            typename ::std::basic_istream<_CharT, _Traits>::sentry::__int_type __c = __sb->sgetc();
            const typename ::std::basic_istream<_CharT, _Traits>::sentry::__ctype_type &__ct = __check_facet(__in._M_ctype);
            while (!traits_type::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, traits_type::to_char_type(__c)))
              {
                __c = __sb->snextc();
              }
            if (traits_type::eq_int_type(__c, __eof))
              {
                __err |= ::std::ios_base::eofbit;
              }
          }
      }
    if (__in.good() && __err == ::std::ios_base::goodbit)
      {
        ::std::basic_istream<_CharT, _Traits>::sentry::_M_ok = true;
      }
    else
      {
        __err |= ::std::ios_base::failbit;
        __in.setstate(__err);
      }
  }
  template < typename _CharT, typename _Traits >
  template < typename _ValueT >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::_M_extract(_ValueT &__v)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __v);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<short int>, ::__gnu_cxx::__numeric_traits_floating<short int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<short int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<short int>' */ 
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(short int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<short int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<short int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<short int>::__max;
                }
              else
                {
                  __n = (short int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(int &__n)
  {
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          long int __l;
          const typename ::std::basic_istream<_CharT, _Traits>::__num_get_type &__ng = __check_facet(this->_M_num_get);
          __ng.get(*this, 0, *this, __err, __l);
          if (__l < ::__gnu_cxx::__numeric_traits_integer<int>::__min)
            {
              __err |= ::std::ios_base::failbit;
              __n = ::__gnu_cxx::__numeric_traits_integer<int>::__min;
            }
          else
            {
              if (__l > ::__gnu_cxx::__numeric_traits_integer<int>::__max)
                {
                  __err |= ::std::ios_base::failbit;
                  __n = ::__gnu_cxx::__numeric_traits_integer<int>::__max;
                }
              else
                {
                  __n = (int)__l;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::operator >>(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sbout)
  {
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
    if (__cerb && __sbout)
      {
        try
        {
          bool __ineof;
          if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
            {
              __err |= ::std::ios_base::failbit;
            }
          if (__ineof)
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::failbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::failbit);
        }
      }
    else
      {
        if (!__sbout)
          {
            __err |= ::std::ios_base::failbit;
          }
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::get()
  {
    const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __eof;
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          __c = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__c, __eof))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type &__c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __cb = this->rdbuf()->sbumpc();
          if (!traits_type::eq_int_type(__cb, traits_type::eof()))
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
              __c = traits_type::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __sb->snextc();
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::get(typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type &__sb, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__this_sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __this_sb->sgetc();
          typename ::std::basic_istream<_CharT, _Traits>::char_type __c2 = traits_type::to_char_type(__c);
          while ((!traits_type::eq_int_type(__c, __eof) && !traits_type::eq_int_type(__c, __idelim)) && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
            {
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
              __c = __this_sb->snextc();
              __c2 = traits_type::to_char_type(__c);
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::getline(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::char_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __idelim = traits_type::to_int_type(__delim);
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          while ((::std::basic_istream<_CharT, _Traits>::_M_gcount + 1 < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __idelim))
            {
              *__s++ = traits_type::to_char_type(__c);
              __c = __sb->snextc();
               ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __idelim))
                {
                  __sb->sbumpc();
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                }
              else
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    if (__n > 0)
      {
        *__s = ((typename ::std::basic_istream<_CharT, _Traits>::char_type()));
      }
    if (!::std::basic_istream<_CharT, _Traits>::_M_gcount)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        this->setstate(__err);
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = 1;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
 /* Instantiation of class template '::__gnu_cxx::__conditional_type<true, ::__gnu_cxx::__numeric_traits_integer<long int>, ::__gnu_cxx::__numeric_traits_floating<long int> >' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits_integer<long int>' */ 
 /* Instantiation of class template '::__gnu_cxx::__numeric_traits<long int>' */ 
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while (::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if (__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::ignore(::std::streamsize __n, typename ::std::basic_istream<_CharT, _Traits>::int_type __delim)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb && __n > 0)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          typename ::std::basic_istream<_CharT, _Traits>::int_type __c = __sb->sgetc();
          bool __large_ignore(false);
          while (true)
            {
              while ((::std::basic_istream<_CharT, _Traits>::_M_gcount < __n && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                   ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                  __c = __sb->snextc();
                }
              if ((__n == ::__gnu_cxx::__numeric_traits_integer<long int>::__max && !traits_type::eq_int_type(__c, __eof)) && !traits_type::eq_int_type(__c, __delim))
                {
                  ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__min;
                  __large_ignore = true;
                }
              else
                {
                  break;
                }
            }
          if (__large_ignore)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          if (traits_type::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          else
            {
              if (traits_type::eq_int_type(__c, __delim))
                {
                  if (::std::basic_istream<_CharT, _Traits>::_M_gcount < ::__gnu_cxx::__numeric_traits_integer<long int>::__max)
                    {
                       ++::std::basic_istream<_CharT, _Traits>::_M_gcount;
                    }
                  __sb->sbumpc();
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::int_type basic_istream<_CharT, _Traits>::peek()
  {
    typename ::std::basic_istream<_CharT, _Traits>::int_type __c = traits_type::eof();
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          __c = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__c, traits_type::eof()))
            {
              __err |= ::std::ios_base::eofbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __c;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::read(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, __n);
          if (::std::basic_istream<_CharT, _Traits>::_M_gcount != __n)
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::streamsize basic_istream<_CharT, _Traits>::readsome(typename ::std::basic_istream<_CharT, _Traits>::char_type *__s, ::std::streamsize __n)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const ::std::streamsize __num = this->rdbuf()->in_avail();
          if (__num > 0)
            {
              ::std::basic_istream<_CharT, _Traits>::_M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
            }
          else
            {
              if (__num ==  -1)
                {
                  __err |= ::std::ios_base::eofbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return ::std::basic_istream<_CharT, _Traits>::_M_gcount;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::putback(typename ::std::basic_istream<_CharT, _Traits>::char_type __c)
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::unget()
  {
    ::std::basic_istream<_CharT, _Traits>::_M_gcount = 0;
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const typename ::std::basic_istream<_CharT, _Traits>::int_type __eof = traits_type::eof();
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (!__sb || traits_type::eq_int_type(__sb->sungetc(), __eof))
            {
              __err |= ::std::ios_base::badbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  int basic_istream<_CharT, _Traits>::sync()
  {
    int __ret( -1);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          typename ::std::basic_istream<_CharT, _Traits>::__streambuf_type *__sb = this->rdbuf();
          if (__sb)
            {
              if (__sb->pubsync() ==  -1)
                {
                  __err |= ::std::ios_base::badbit;
                }
              else
                {
                  __ret = 0;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::pos_type basic_istream<_CharT, _Traits>::tellg()
  {
    typename ::std::basic_istream<_CharT, _Traits>::pos_type __ret = ((typename ::std::basic_istream<_CharT, _Traits>::pos_type( -1)));
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        try
        {
          if (!this->fail())
            {
              __ret = this->rdbuf()->pubseekoff(0, ::std::ios_base::cur, ::std::ios_base::in);
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
      }
    return __ret;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::pos_type __pos)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekpos(__pos, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  typename ::std::basic_istream<_CharT, _Traits>::__istream_type &basic_istream<_CharT, _Traits>::seekg(typename ::std::basic_istream<_CharT, _Traits>::off_type __off, ::std::ios_base::seekdir __dir)
  {
    this->clear(this->rdstate() &  ~::std::ios_base::eofbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(*this, true);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          if (!this->fail())
            {
              const typename ::std::basic_istream<_CharT, _Traits>::pos_type __p = this->rdbuf()->pubseekoff(__off, __dir, ::std::ios_base::in);
              if (__p == ((typename ::std::basic_istream<_CharT, _Traits>::pos_type(((typename ::std::basic_istream<_CharT, _Traits>::off_type( -1)))))))
                {
                  __err |= ::std::ios_base::failbit;
                }
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          this->_M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          this->_M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            this->setstate(__err);
          }
      }
    return *this;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT &__c)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        ::std::ios_base::iostate __err(::std::ios_base::goodbit);
        try
        {
          const __int_type __cb = __in.rdbuf()->sbumpc();
          if (!_Traits::eq_int_type(__cb, _Traits::eof()))
            {
              __c = _Traits::to_char_type(__cb);
            }
          else
            {
              __err |= ::std::ios_base::eofbit | ::std::ios_base::failbit;
            }
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
        if (__err)
          {
            __in.setstate(__err);
          }
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &operator >>(::std::basic_istream<_CharT, _Traits> &__in, _CharT *__s)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename _Traits::int_type int_type;
    typedef _CharT char_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    ::std::streamsize __extracted(0);
    ::std::ios_base::iostate __err(::std::ios_base::goodbit);
    typename ::std::basic_istream<_CharT, _Traits>::sentry __cerb(__in, false);
    if (__cerb)
      {
        try
        {
          ::std::streamsize __num = __in.width();
          if (__num <= 0)
            {
              __num = ::__gnu_cxx::__numeric_traits_integer<long int>::__max;
            }
          const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
          const int_type __eof = _Traits::eof();
          __streambuf_type *__sb = __in.rdbuf();
          int_type __c = __sb->sgetc();
          while ((__extracted < __num - 1 && !_Traits::eq_int_type(__c, __eof)) && !__ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
            {
              *__s++ = _Traits::to_char_type(__c);
               ++__extracted;
              __c = __sb->snextc();
            }
          if (_Traits::eq_int_type(__c, __eof))
            {
              __err |= ::std::ios_base::eofbit;
            }
          *__s = char_type();
          __in.width(0);
        }
        catch (::__cxxabiv1::__forced_unwind &)
        {
          __in._M_setstate(::std::ios_base::badbit);
          throw;
        }
        catch (...)
        {
          __in._M_setstate(::std::ios_base::badbit);
        }
      }
    if (!__extracted)
      {
        __err |= ::std::ios_base::failbit;
      }
    if (__err)
      {
        __in.setstate(__err);
      }
    return __in;
  }
  template < typename _CharT, typename _Traits >
  ::std::basic_istream<_CharT, _Traits> &ws(::std::basic_istream<_CharT, _Traits> &__in)
  {
    typedef ::std::basic_istream<_CharT, _Traits> __istream_type;
    typedef ::std::basic_streambuf<_CharT, _Traits> __streambuf_type;
    typedef typename ::std::basic_istream<_CharT, _Traits>::int_type __int_type;
    typedef ::std::ctype<_CharT> __ctype_type;
    const __ctype_type &__ct = use_facet<__ctype_type>(__in.getloc());
    const __int_type __eof = _Traits::eof();
    __streambuf_type *__sb = __in.rdbuf();
    __int_type __c = __sb->sgetc();
    while (!_Traits::eq_int_type(__c, __eof) && __ct.is(::std::ctype_base::space, _Traits::to_char_type(__c)))
      {
        __c = __sb->snextc();
      }
    if (_Traits::eq_int_type(__c, __eof))
      {
        __in.setstate(::std::ios_base::eofbit);
      }
    return __in;
  }
  extern template class ::std::basic_istream<char>;
  extern template ::std::basic_istream<char> &ws(::std::basic_istream<char> &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char &);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, unsigned char *);
  extern template ::std::basic_istream<char> &operator >>(::std::basic_istream<char> &, signed char *);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(bool &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<char> &istream::_M_extract(float &);
  extern template ::std::basic_istream<char> &istream::_M_extract(double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(long double &);
  extern template ::std::basic_istream<char> &istream::_M_extract(void *&);
  extern template class ::std::basic_iostream<char>;
  extern template class ::std::basic_istream<wchar_t>;
  extern template ::std::basic_istream<wchar_t> &ws(::std::basic_istream<wchar_t> &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t &);
  extern template ::std::basic_istream<wchar_t> &operator >>(::std::basic_istream<wchar_t> &, wchar_t *);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned short int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(bool &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(unsigned long long int &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(float &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(long double &);
  extern template ::std::basic_istream<wchar_t> &wistream::_M_extract(void *&);
  extern template class ::std::basic_iostream<wchar_t>;
  extern ::std::istream cin;
  extern ::std::ostream cout;
  extern ::std::ostream cerr;
  extern ::std::ostream clog;
  extern ::std::wistream wcin;
  extern ::std::wostream wcout;
  extern ::std::wostream wcerr;
  extern ::std::wostream wclog;
  static ::std::ios_base::Init __ioinit /* () */ ;
}
const int num_proteins(4);
const int num_features(2);
const int num_latent(8);
const int num_samples(4);
const int log_num_samples(2);
typedef float U_base;
typedef float U_type;
typedef float mu_base;
typedef float mu_type;
typedef float B_base;
typedef float B_type;
typedef float F_base;
typedef float F_type;
typedef float P_base;
typedef float P_type;
typedef float L_type;
typedef float S_type;
const float epsilon(5.00000000000000000000000000000000000000000000000000000e-01);
void update_model(::U_base U[4L][4L][8L], ::mu_base mu[4L][8L], ::B_base B[4L][2L][8L]);
void predict_compound(::F_base in[2L], ::P_base out[4L]);
const int num_compounds(3);
const ::U_base U[4L][4L][8L] = { /* [0] =  */ { /* [0] =  */ { /* [0] =  */ 4.21999999999999986233234494648058898746967315673828125e-01,  /* [1] =  */ 2.51699999999999979305442820987082086503505706787109375e-01,  /* [2] =  */  -2.30999999999999990063503929604848963208496570587158203e-02,  /* [3] =  */  -3.34699999999999997513100424839649349451065063476562500e-01,  /* [4] =  */  -3.56499999999999983568699235547683201730251312255859375e-01,  /* [5] =  */ 5.94500000000000028421709430404007434844970703125000000e-01,  /* [6] =  */ 1.17159999999999997477573288051644340157508850097656250e+00,  /* [7] =  */  -1.22179999999999999715782905695959925651550292968750000e+00},  /* [1] =  */ { /* [0] =  */ 1.54299999999999992716936958458973094820976257324218750e-01,  /* [1] =  */ 2.03699999999999992184029906638897955417633056640625000e-01,  /* [2] =  */ 5.63999999999999987454479821735731093212962150573730469e-02,  /* [3] =  */ 2.86299999999999998934185896359849721193313598632812500e-01,  /* [4] =  */  -1.21730000000000004867217739956686273217201232910156250e+00,  /* [5] =  */ 3.83000000000000007105427357601001858711242675781250000e-02,  /* [6] =  */ 7.59099999999999996980193373019574210047721862792968750e-01,  /* [7] =  */  -1.63399999999999989697130331478547304868698120117187500e+00},  /* [2] =  */ { /* [0] =  */  -7.85200000000000009059419880941277369856834411621093750e-01,  /* [1] =  */  -1.72120000000000006323830348264891654253005981445312500e+00,  /* [2] =  */  -1.30899999999999988586907306853390764445066452026367188e-01,  /* [3] =  */  -7.92100000000000026290081223123706877231597900390625000e-01,  /* [4] =  */ 2.19900000000000012123635428906709421426057815551757812e-01,  /* [5] =  */ 4.92800000000000015809575870662229135632514953613281250e-01,  /* [6] =  */ 1.42999999999999993782751062099123373627662658691406250e+00,  /* [7] =  */  -5.69200000000000039257486150745535269379615783691406250e-01},  /* [3] =  */ { /* [0] =  */  -7.53000000000000002664535259100375697016716003417968750e-01,  /* [1] =  */  -2.18429999999999990833998708694707602262496948242187500e+00,  /* [2] =  */ 2.88700000000000012168044349891715683043003082275390625e-01,  /* [3] =  */  -2.31699999999999989297450042613490950316190719604492188e-01,  /* [4] =  */  -4.81599999999999972555286831266130320727825164794921875e-01,  /* [5] =  */  -3.32500000000000017763568394002504646778106689453125000e-01,  /* [6] =  */ 1.43140000000000000568434188608080148696899414062500000e+00,  /* [7] =  */  -3.91600000000000003641531520770513452589511871337890625e-01}},  /* [1] =  */ { /* [0] =  */ { /* [0] =  */ 1.87700000000000005728750807065807748585939407348632812e-01,  /* [1] =  */  -1.17440000000000011048939541069557890295982360839843750e+00,  /* [2] =  */  -5.19999999999999976130204970559134380891919136047363281e-02,  /* [3] =  */ 3.12099999999999988542498385868384502828121185302734375e-01,  /* [4] =  */  -9.48999999999999954702900595293613150715827941894531250e-01,  /* [5] =  */ 2.09600000000000008526512829121202230453491210937500000e-01,  /* [6] =  */ 1.27800000000000002486899575160350650548934936523437500e+00,  /* [7] =  */ 1.65899999999999991917576380728860385715961456298828125e-01},  /* [1] =  */ { /* [0] =  */  -1.08420000000000005258016244624741375446319580078125000e+00,  /* [1] =  */  -5.22199999999999997513100424839649349451065063476562500e-01,  /* [2] =  */ 5.78699999999999992184029906638897955417633056640625000e-01,  /* [3] =  */  -5.16299999999999981170617502357345074415206909179687500e-01,  /* [4] =  */  -7.38000000000000044853010194856324233114719390869140625e-02,  /* [5] =  */ 5.98099999999999965005770263815065845847129821777343750e-01,  /* [6] =  */ 7.70900000000000029665159217984182760119438171386718750e-01,  /* [7] =  */  -9.88399999999999945288209346472285687923431396484375000e-01},  /* [2] =  */ { /* [0] =  */ 3.52499999999999980015985556747182272374629974365234375e-01,  /* [1] =  */  -1.46999999999999991784349617773841600865125656127929688e-01,  /* [2] =  */  -9.06699999999999950439644180733012035489082336425781250e-01,  /* [3] =  */ 3.43399999999999983035792183727608062326908111572265625e-01,  /* [4] =  */  -1.01980000000000003979039320256561040878295898437500000e+00,  /* [5] =  */ 3.23900000000000021227464230832993052899837493896484375e-01,  /* [6] =  */ 1.23649999999999993249844010279048234224319458007812500e+00,  /* [7] =  */  -1.28689999999999993285371147067053243517875671386718750e+00},  /* [3] =  */ { /* [0] =  */  -8.31300000000000038902214782865485176444053649902343750e-01,  /* [1] =  */  -1.77930000000000010373923942097462713718414306640625000e+00,  /* [2] =  */  -8.20000000000000034416913763379852753132581710815429688e-02,  /* [3] =  */ 7.34999999999999958921748088869208004325628280639648438e-02,  /* [4] =  */  -4.20599999999999973887554460816318169236183166503906250e-01,  /* [5] =  */  -7.71399999999999974598097196576418355107307434082031250e-01,  /* [6] =  */ 1.77489999999999992219557043426902964711189270019531250e+00,  /* [7] =  */  -1.64000000000000013822276656583198928274214267730712891e-02}},  /* [2] =  */ { /* [0] =  */ { /* [0] =  */ 3.76999999999999974020781223771336954087018966674804688e-02,  /* [1] =  */  -8.29300000000000037125857943465234711766242980957031250e-01,  /* [2] =  */  -1.12500000000000002775557561562891351059079170227050781e-01,  /* [3] =  */  -9.21000000000000013100631690576847176998853683471679688e-02,  /* [4] =  */  -1.17720000000000002415845301584340631961822509765625000e+00,  /* [5] =  */ 2.72399999999999975486275616276543587446212768554687500e-01,  /* [6] =  */ 1.22580000000000000071054273576010018587112426757812500e+00,  /* [7] =  */  -2.48099999999999987210230756318196654319763183593750000e-01},  /* [1] =  */ { /* [0] =  */ 6.82499999999999995559107901499373838305473327636718750e-01,  /* [1] =  */  -9.78800000000000003375077994860475882887840270996093750e-01,  /* [2] =  */  -1.31919999999999992823518368822988122701644897460937500e+00,  /* [3] =  */ 9.56200000000000049915627187147038057446479797363281250e-01,  /* [4] =  */  -1.98009999999999997122301920171594247221946716308593750e+00,  /* [5] =  */  -2.71399999999999974598097196576418355107307434082031250e-01,  /* [6] =  */ 1.41399999999999992361665590578923001885414123535156250e+00,  /* [7] =  */  -1.08799999999999993938182285546645289286971092224121094e-01},  /* [2] =  */ { /* [0] =  */  -8.71299999999999963407049108354840427637100219726562500e-01,  /* [1] =  */  -1.00560000000000004938272013532696291804313659667968750e+00,  /* [2] =  */ 1.50000000000000003122502256758252769941464066505432129e-03,  /* [3] =  */ 1.10899999999999998578914528479799628257751464843750000e-01,  /* [4] =  */  -4.03100000000000013855583347321953624486923217773437500e-01,  /* [5] =  */ 1.55900000000000010791367799356521572917699813842773438e-01,  /* [6] =  */ 1.01360000000000005648814749292796477675437927246093750e+00,  /* [7] =  */  -4.57899999999999973709918776876293122768402099609375000e-01},  /* [3] =  */ { /* [0] =  */  -1.79039999999999999147348717087879776954650878906250000e+00,  /* [1] =  */ 1.84999999999999997779553950749686919152736663818359375e-01,  /* [2] =  */ 1.83999999999999996891375531049561686813831329345703125e-02,  /* [3] =  */  -1.07830000000000003623767952376510947942733764648437500e+00,  /* [4] =  */ 1.65100000000000002309263891220325604081153869628906250e+00,  /* [5] =  */ 1.63700000000000001065814103640150278806686401367187500e+00,  /* [6] =  */ 9.90199999999999969091390994435641914606094360351562500e-01,  /* [7] =  */  -2.00389999999999979252152115805074572563171386718750000e+00}},  /* [3] =  */ { /* [0] =  */ { /* [0] =  */ 8.92599999999999949018558709212811663746833801269531250e-01,  /* [1] =  */  -1.57949999999999990407673067238647490739822387695312500e+00,  /* [2] =  */  -4.98199999999999976196818352036643773317337036132812500e-01,  /* [3] =  */ 3.40200000000000002398081733190338127315044403076171875e-01,  /* [4] =  */  -2.10930000000000017479351299698464572429656982421875000e+00,  /* [5] =  */  -3.78500000000000003108624468950438313186168670654296875e-01,  /* [6] =  */ 1.59729999999999994209076703555183485150337219238281250e+00,  /* [7] =  */  -1.31399999999999989030996516703453380614519119262695312e-01},  /* [1] =  */ { /* [0] =  */  -2.19700000000000006394884621840901672840118408203125000e-01,  /* [1] =  */ 2.81100000000000016520118606422329321503639221191406250e-01,  /* [2] =  */ 3.82099999999999995203836533619323745369911193847656250e-01,  /* [3] =  */ 1.61799999999999999378275106209912337362766265869140625e-01,  /* [4] =  */  -1.29899999999999993249844010279048234224319458007812500e+00,  /* [5] =  */ 1.90099999999999991207033644968760199844837188720703125e-01,  /* [6] =  */ 1.28629999999999999893418589635984972119331359863281250e+00,  /* [7] =  */  -2.64000000000000012434497875801753252744674682617187500e-01},  /* [2] =  */ { /* [0] =  */  -6.83400000000000007460698725481051951646804809570312500e-01,  /* [1] =  */  -3.14300000000000023803181647963356226682662963867187500e-01,  /* [2] =  */ 3.84999999999999995003996389186795568093657493591308594e-02,  /* [3] =  */  -7.74399999999999977262632455676794052124023437500000000e-01,  /* [4] =  */ 7.31199999999999961097785217134514823555946350097656250e-01,  /* [5] =  */ 1.00629999999999997228883330535609275102615356445312500e+00,  /* [6] =  */ 1.21280000000000010018652574217412620782852172851562500e+00,  /* [7] =  */  -1.55040000000000000035527136788005009293556213378906250e+00},  /* [3] =  */ { /* [0] =  */  -7.30700000000000016164847238542279228568077087402343750e-01,  /* [1] =  */ 1.02000000000000007327471962526033166795969009399414062e-02,  /* [2] =  */  -2.74899999999999977706721665526856668293476104736328125e-01,  /* [3] =  */  -2.31399999999999994582111639829236082732677459716796875e-01,  /* [4] =  */ 2.71399999999999974598097196576418355107307434082031250e-01,  /* [5] =  */ 1.02309999999999989839238878630567342042922973632812500e+00,  /* [6] =  */ 1.34830000000000005400124791776761412620544433593750000e+00,  /* [7] =  */  -1.17959999999999998188116023811744526028633117675781250e+00}}};
const ::mu_base mu[4L][8L] = { /* [0] =  */ { /* [0] =  */  -2.79000000000000025757174171303631737828254699707031250e-01,  /* [1] =  */ 8.20000000000000069111383282915994641371071338653564453e-03,  /* [2] =  */  -2.22099999999999991873167459743854124099016189575195312e-01,  /* [3] =  */  -2.13600000000000012079226507921703159809112548828125000e-01,  /* [4] =  */  -7.61000000000000009769962616701377555727958679199218750e-02,  /* [5] =  */ 9.18000000000000065947247662734298501163721084594726562e-02,  /* [6] =  */ 6.50699999999999945110573662532260641455650329589843750e-01,  /* [7] =  */  -7.34199999999999963762320476234890520572662353515625000e-01},  /* [1] =  */ { /* [0] =  */  -1.45699999999999996180832795289461500942707061767578125e-01,  /* [1] =  */ 3.88699999999999989963583857388584874570369720458984375e-01,  /* [2] =  */  -2.66900000000000026112445539183681830763816833496093750e-01,  /* [3] =  */  -7.57199999999999984190424129337770864367485046386718750e-01,  /* [4] =  */  -3.37500000000000022204460492503130808472633361816406250e-01,  /* [5] =  */  -1.00449999999999994848565165739273652434349060058593750e+00,  /* [6] =  */ 1.51900000000000007238654120556020643562078475952148438e-01,  /* [7] =  */  -2.59199999999999985966780968738021329045295715332031250e-01},  /* [2] =  */ { /* [0] =  */  -8.67399999999999948840923025272786617279052734375000000e-01,  /* [1] =  */  -9.69000000000000000222044604925031308084726333618164062e-02,  /* [2] =  */  -3.17900000000000015898393712632241658866405487060546875e-01,  /* [3] =  */ 8.00499999999999989341858963598497211933135986328125000e-01,  /* [4] =  */  -4.25999999999999989785948173448559828102588653564453125e-02,  /* [5] =  */  -2.12799999999999989164223279658472165465354919433593750e-01,  /* [6] =  */ 1.46249999999999991118215802998747676610946655273437500e+00,  /* [7] =  */  -9.22499999999999986677323704498121514916419982910156250e-01},  /* [3] =  */ { /* [0] =  */  -2.98899999999999999023003738329862244427204132080078125e-01,  /* [1] =  */  -3.73800000000000021138646388862980529665946960449218750e-01,  /* [2] =  */  -3.90500000000000013766765505351941101253032684326171875e-01,  /* [3] =  */ 1.09749999999999992006394222698872908949851989746093750e+00,  /* [4] =  */ 5.55499999999999993782751062099123373627662658691406250e-01,  /* [5] =  */ 2.03199999999999991739940696788835339248180389404296875e-01,  /* [6] =  */ 7.38299999999999956301621750753838568925857543945312500e-01,  /* [7] =  */  -5.88600000000000012079226507921703159809112548828125000e-01}};
const ::B_base B[4L][2L][8L] = { /* [0] =  */ { /* [0] =  */ { /* [0] =  */ 3.64200000000000023714363805993343703448772430419921875e-01,  /* [1] =  */  -2.17999999999999999333866185224906075745820999145507812e-02,  /* [2] =  */  -2.06000000000000002553512956637860042974352836608886719e-02,  /* [3] =  */  -3.74199999999999977084996771736769005656242370605468750e-01,  /* [4] =  */ 2.29999999999999996114219413811952108517289161682128906e-02,  /* [5] =  */ 1.50100000000000011191048088221577927470207214355468750e-01,  /* [6] =  */  -8.41600000000000014743761767022078856825828552246093750e-01,  /* [7] =  */ 3.31299999999999983391063551607658155262470245361328125e-01},  /* [1] =  */ { /* [0] =  */  -2.62299999999999977617903823556844145059585571289062500e-01,  /* [1] =  */  -9.74000000000000004662936703425657469779253005981445312e-02,  /* [2] =  */ 2.17700000000000004618527782440651208162307739257812500e-01,  /* [3] =  */ 3.66499999999999992450483432548935525119304656982421875e-01,  /* [4] =  */  -1.25799999999999995159427612634317483752965927124023438e-01,  /* [5] =  */ 2.52599999999999991207033644968760199844837188720703125e-01,  /* [6] =  */ 4.79999999999999982236431605997495353221893310546875000e-01,  /* [7] =  */  -1.75199999999999994626520560814242344349622726440429688e-01}},  /* [1] =  */ { /* [0] =  */ { /* [0] =  */ 8.36999999999999966249220051395241171121597290039062500e-02,  /* [1] =  */ 3.21699999999999985966780968738021329045295715332031250e-01,  /* [2] =  */ 8.89999999999999992505994583780193352140486240386962891e-03,  /* [3] =  */  -6.57900000000000040323300254385685548186302185058593750e-01,  /* [4] =  */  -1.37099999999999999644728632119949907064437866210937500e-01,  /* [5] =  */  -1.95700000000000012834178164666809607297182083129882812e-01,  /* [6] =  */  -4.64500000000000023980817331903381273150444030761718750e-01,  /* [7] =  */ 2.36699999999999993738342141114117112010717391967773438e-01},  /* [1] =  */ { /* [0] =  */  -2.41199999999999997735145029764680657535791397094726562e-01,  /* [1] =  */  -2.65000000000000013322676295501878485083580017089843750e-01,  /* [2] =  */ 1.81100000000000010969003483296546619385480880737304688e-01,  /* [3] =  */ 5.96899999999999986144416652678046375513076782226562500e-01,  /* [4] =  */  -4.51000000000000011990408665951690636575222015380859375e-02,  /* [5] =  */ 4.09799999999999997601918266809661872684955596923828125e-01,  /* [6] =  */ 5.74899999999999966604491419275291264057159423828125000e-01,  /* [7] =  */  -2.96200000000000018829382497642654925584793090820312500e-01}},  /* [2] =  */ { /* [0] =  */ { /* [0] =  */  -4.56999999999999975686115760709071764722466468811035156e-02,  /* [1] =  */ 2.69999999999999996946886682280819513835012912750244141e-02,  /* [2] =  */ 1.24100000000000001976196983832778641954064369201660156e-01,  /* [3] =  */ 5.75000000000000024980018054066022159531712532043457031e-02,  /* [4] =  */  -1.24499999999999999555910790149937383830547332763671875e-01,  /* [5] =  */  -9.09999999999999975575093458246556110680103302001953125e-02,  /* [6] =  */  -9.19999999999999984456877655247808434069156646728515625e-03,  /* [7] =  */  -1.06899999999999995026200849679298698902130126953125000e-01},  /* [1] =  */ { /* [0] =  */  -1.44300000000000011590728377086634282022714614868164062e-01,  /* [1] =  */  -2.39999999999999978975151471161098015727475285530090332e-03,  /* [2] =  */ 7.32000000000000011768364061026659328490495681762695312e-02,  /* [3] =  */ 5.34000000000000030198066269804257899522781372070312500e-02,  /* [4] =  */  -1.15400000000000002575717417130363173782825469970703125e-01,  /* [5] =  */ 1.30399999999999988142818097003328148275613784790039062e-01,  /* [6] =  */ 1.60899999999999987476684282228234224021434783935546875e-01,  /* [7] =  */  -3.28999999999999986899368309423152823001146316528320312e-02}},  /* [3] =  */ { /* [0] =  */ { /* [0] =  */  -2.22599999999999992317256669593916740268468856811523438e-01,  /* [1] =  */  -1.98699999999999987743137808138271793723106384277343750e-01,  /* [2] =  */  -1.56400000000000011235457009206584189087152481079101562e-01,  /* [3] =  */  -1.68699999999999988853360832763428334146738052368164062e-01,  /* [4] =  */  -7.67999999999999932720484707715513650327920913696289062e-02,  /* [5] =  */ 2.15999999999999997557509345824655611068010330200195312e-01,  /* [6] =  */ 2.39199999999999995958788190364430192857980728149414062e-01,  /* [7] =  */ 1.07200000000000003619327060278010321781039237976074219e-01},  /* [1] =  */ { /* [0] =  */  -1.87200000000000005284661597215745132416486740112304688e-01,  /* [1] =  */ 1.94000000000000005773159728050814010202884674072265625e-02,  /* [2] =  */ 1.30399999999999988142818097003328148275613784790039062e-01,  /* [3] =  */ 2.00399999999999994804156244754267390817403793334960938e-01,  /* [4] =  */  -1.10799999999999995714539124946895753964781761169433594e-01,  /* [5] =  */ 2.92000000000000002609024107869117869995534420013427734e-02,  /* [6] =  */ 2.74699999999999999733546474089962430298328399658203125e-01,  /* [7] =  */  -1.23600000000000001532107773982716025784611701965332031e-01}}};
const ::F_base tb_input[3L][2L] = { /* [0] =  */ { /* [0] =  */ 1.00000000000000000000000000000000000000000000000000000e+00,  /* [1] =  */ 2.00000000000000000000000000000000000000000000000000000e+00},  /* [1] =  */ { /* [0] =  */ 2.00000000000000000000000000000000000000000000000000000e+00,  /* [1] =  */ 4.00000000000000000000000000000000000000000000000000000e+00},  /* [2] =  */ { /* [0] =  */ 3.00000000000000000000000000000000000000000000000000000e+00,  /* [1] =  */ 6.00000000000000000000000000000000000000000000000000000e+00}};
const ::P_base tb_ref[3L][4L] = { /* [0] =  */ { /* [0] =  */ 2.10150000000000014566126083082053810358047485351562500e+00,  /* [1] =  */ 2.40660000000000007247535904753021895885467529296875000e+00,  /* [2] =  */ 2.83930000000000015702994460298214107751846313476562500e+00,  /* [3] =  */ 3.11359999999999992326138453790917992591857910156250000e+00},  /* [1] =  */ { /* [0] =  */ 3.15799999999999991828758538758847862482070922851562500e+00,  /* [1] =  */ 3.54499999999999992894572642398998141288757324218750000e+00,  /* [2] =  */ 3.95369999999999999218402990663889795541763305664062500e+00,  /* [3] =  */ 4.31489999999999973567810229724273085594177246093750000e+00},  /* [2] =  */ { /* [0] =  */ 4.21459999999999990194510246510617434978485107421875000e+00,  /* [1] =  */ 4.68350000000000044053649617126211524009704589843750000e+00,  /* [2] =  */ 5.06810000000000027142732506035827100276947021484375000e+00,  /* [3] =  */ 5.51620000000000043627323975670151412487030029296875000e+00}};
template < typename F, typename T >
void convert(const F *in, T *out, int size);
template < typename F, typename T >
void convert(const F *in, T *out, int size)
{
  for (int i(0); i < size;  ++i)
    {
      out[i] = in[i];
    }
}
 /* Instantiation of class template '::__gnu_cxx::__enable_if<false, double>' */ 
template < typename F, typename T >
int check_result(const F out[3L][4L], const T ref[3L][4L]);
template < typename F, typename T >
int check_result(const F (*out)[4L], const T (*ref)[4L])
{
  int nerrors(0);
  for (int c(0); c < ::num_compounds; c++)
    {
      for (int p(0); p < ::num_proteins; p++)
        {
          float o((::P_type(out[c][p])));
          float r((::P_type(ref[c][p])));
          if (std::abs(o - r) > ::epsilon)
            {
              ::printf("error at [%d][%d]: %f != %f\n", c, p, o, r);
              nerrors++;
            }
        }
    }
  ::printf("%d errors (out of %d)\n", nerrors, ::num_compounds * ::num_proteins);
  return nerrors;
}
 /* Instantiation of template function 'void ::convert<float, float>(const float *, float *, int)' */ 
 /* Instantiation of template function 'int ::check_result<float, float>(const float (*)[4L], const float (*)[4L])' */ 
int main()
{
  ::ompss_nanox_main_begin((void *)::main, "main.cpp", 45);
  ::nanos_atexit((void *)::ompss_nanox_main_end);
  ::printf("  nprot: %d\n", ::num_proteins);
  ::printf("  ncmpd: %d\n", ::num_compounds);
  ::printf("  nfeat: %d\n", ::num_features);
  ::printf("  nlat:  %d\n", ::num_latent);
  ::printf("  nsmpl: %d\n", ::num_samples);
  static ::P_base tb_output_fx[3L][4L];
  static ::F_base tb_input_fx[3L][2L];
  static ::U_base U_fx[4L][4L][8L];
  static ::mu_base mu_fx[4L][8L];
  static ::B_base B_fx[4L][2L][8L];
  ::convert /* <float, float> */ (&::tb_input[0][0], &tb_input_fx[0][0], sizeof(const ::F_base (&)[3L][2L]) / sizeof(const ::F_base &));
  ::convert /* <float, float> */ (&::U[0][0][0], &U_fx[0][0][0], sizeof(const ::U_base (&)[4L][4L][8L]) / sizeof(const ::U_base &));
  ::convert /* <float, float> */ (&::mu[0][0], &mu_fx[0][0], sizeof(const ::mu_base (&)[4L][8L]) / sizeof(const ::mu_base &));
  ::convert /* <float, float> */ (&::B[0][0][0], &B_fx[0][0][0], sizeof(const ::B_base (&)[4L][2L][8L]) / sizeof(const ::B_base &));
  int nerrors(0);
  ::printf("Updating model\n");
  ::update_model(U_fx, mu_fx, B_fx);
  ::printf("Predicting\n");
  for (int c(0); c < ::num_compounds; c++)
    {
      ::predict_compound(tb_input_fx[c], tb_output_fx[c]);
    }
  nerrors += ::check_result /* <float, float> */ (tb_output_fx, ::tb_ref);
  return nerrors;
}
