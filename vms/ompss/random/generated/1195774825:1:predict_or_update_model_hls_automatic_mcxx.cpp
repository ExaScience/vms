/////////////////// Automatic IP Generated by OmpSs@FPGA compiler

#include <stdint.h>
#include <iostream>
#include <string.h>
#include <strings.h>
#include <hls_stream.h>
#include <ap_axi_sdata.h>


typedef ap_axis<64,1,1,5> axiData_t;
typedef hls::stream<axiData_t> axiStream_t;
typedef uint64_t counter_t;



#include "predict.fpga.h"
void proteins_loop(::P_base *predictions, const ::L_type (*latents)[8L])
{

  for (int d(0);
 d < ::num_proteins;
 d++)
    {

#pragma HLS PIPELINE II = 1
#pragma HLS ARRAY_PARTITION variable = U complete dim = 1
#pragma HLS ARRAY_PARTITION variable = U complete dim = 3
      ::S_type sum(0);

      for (int s(0);
 s < ::num_samples;
 s++)
        {

          for (int k(0);
 k < ::num_latent;
 k++)
            {

              ::S_type prod(latents[s][k] * (::U_type)::U[s][d][k]);

              sum = sum + prod;

            }

        }

      ::P_type aggr(sum / ::num_samples);

      predictions[d] = aggr;

    }

}

void features_loop(const ::F_base *features, ::L_type (*latents)[8L])
{

  for (int d(0);
 d < ::num_features;
 d++)
    {

#pragma HLS PIPELINE II = 1
#pragma HLS ARRAY_PARTITION variable = B complete dim = 3
#pragma HLS ARRAY_PARTITION variable = B complete dim = 1
#pragma HLS ARRAY_PARTITION variable = mu complete dim = 2
#pragma HLS ARRAY_PARTITION variable = mu complete dim = 1
#pragma HLS ARRAY_PARTITION variable = latents complete dim = 1
#pragma HLS ARRAY_PARTITION variable = latents complete dim = 2
      const ::F_type feature(features[d]);

      for (int s(0);
 s < ::num_samples;
 s++)
        {

          for (int k(0);
 k < ::num_latent;
 k++)
            {

              ::L_type v(57005);

              if (d == 0)
                {

                  v = (::mu_type)::mu[s][k];

                }

              else
                {

                  v = latents[s][k];

                }

              ::L_type prod(feature * (::B_type)::B[s][d][k]);

              latents[s][k] = v + prod;

            }

        }

    }

}

void predict(const ::F_base *features, ::P_base *predictions)
{

#pragma HLS DATAFLOW
  ::L_type latents[4L][8L];

  ::features_loop(features, latents);

  ::proteins_loop(predictions, latents);

}

void load_model(::U_base (*U_in)[4L][8L], ::mu_base (*mu_in)[8L], ::B_base (*B_in)[2L][8L])
{

  for (int i(0);
 i < ::num_samples;
 i++)
    {

      for (int j(0);
 j < ::num_proteins;
 j++)
        {

          for (int k(0);
 k < ::num_latent;
 k++)
            {

              ::U[i][j][k] = U_in[i][j][k];

            }

        }

      for (int j(0);
 j < ::num_latent;
 j++)
        {

          ::mu[i][j] = mu_in[i][j];

        }

      for (int j(0);
 j < ::num_features;
 j++)
        {

          for (int k(0);
 k < ::num_latent;
 k++)
            {

              ::B[i][j][k] = B_in[i][j][k];

            }

        }

    }

}

extern const uint8_t accID;
static uint64_t __mcxx_taskId;
static uint64_t __mcxx_instrCounter, __mcxx_instrBuffer;
static unsigned int __mcxx_instrSlots, __mcxx_instrCurrentSlot;
static int __mcxx_instrNumOverflow;
extern volatile counter_t * mcxx_data;
typedef struct {
    uint64_t eventId;
    uint64_t value;
    uint64_t timestamp;
}
__mcxx_event_t;
typedef enum {
mcxx__EVENT_TYPE_BURST_OPEN = 0,
mcxx__EVENT_TYPE_BURST_CLOSE = 1,
mcxx__EVENT_TYPE_POINT = 2,
mcxx__EVENT_TYPE_LAST = 0XFFFFFFFF
}
 __mcxx_eventType;
#define mcxx__EVENT_VAL_OK   0
#define mcxx__EVENT_VAL_OVERFLOW   0xFFFFFFFF
void write_stream(axiStream_t &stream, uint64_t data, unsigned short dest, unsigned char last) {
#pragma HLS INTERFACE axis port=stream
	axiData_t __data = {
0, 0, 0, 0, 0, 0, 0}
;
	__data.keep = 0xFF;
	__data.dest = dest;
	__data.last = last;
	__data.data = data;
	stream.write(__data);
}
counter_t get_time() {
#pragma HLS INTERFACE m_axi port=mcxx_data
#pragma HLS inline off
return *(mcxx_data + ( __mcxx_instrCounter/sizeof(counter_t)));
}
void __mcxx_writeInstrEvent(uint32_t event, uint64_t val, uint32_t type) {
#pragma HLS inline off
#pragma HLS INTERFACE m_axi port=mcxx_data
	__mcxx_event_t fpga_event;
	if (__mcxx_instrCurrentSlot< (int)__mcxx_instrSlots-1) {
		fpga_event.eventId = ((uint64_t)type<<32) | event;
		fpga_event.value = val;
		fpga_event.timestamp = get_time();
		memcpy((void*)(mcxx_data + ((__mcxx_instrBuffer + __mcxx_instrCurrentSlot * sizeof(__mcxx_event_t))/sizeof(uint64_t))),&fpga_event, sizeof(__mcxx_event_t));
__mcxx_instrCurrentSlot++;
	}
 else if (__mcxx_instrCurrentSlot == __mcxx_instrSlots  -1) {
		__mcxx_instrNumOverflow++;
		fpga_event.eventId = ((uint64_t) mcxx__EVENT_TYPE_LAST << 32) | __mcxx_instrNumOverflow;
		fpga_event.value = __mcxx_instrNumOverflow;
		memcpy((void *)(mcxx_data + ((__mcxx_instrBuffer + __mcxx_instrCurrentSlot * sizeof(__mcxx_event_t))/sizeof(uint64_t))),&fpga_event, sizeof(__mcxx_event_t));
	}
}
void nanos_instrument_burst_begin(uint32_t event, uint64_t value) {
#pragma HLS inline
__mcxx_writeInstrEvent(event, value, mcxx__EVENT_TYPE_BURST_OPEN );
}
void nanos_instrument_burst_end(uint32_t event, uint64_t value) {
#pragma HLS inline
__mcxx_writeInstrEvent(event, value, mcxx__EVENT_TYPE_BURST_CLOSE );
}
void nanos_instrument_point_event(uint32_t event, uint64_t value) {
#pragma HLS inline
__mcxx_writeInstrEvent(event, value, mcxx__EVENT_TYPE_POINT );
}
void __mcxx_instrEnd() {
#pragma HLS inline
__mcxx_writeInstrEvent(mcxx__EVENT_TYPE_LAST, mcxx__EVENT_VAL_OK, mcxx__EVENT_TYPE_LAST );
}
 void predict_or_update_model(::F_base *features, ::P_base *predictions, bool update_model, ::U_base (*U_in)[4L][8L], ::mu_base (*mu_in)[8L], ::B_base (*B_in)[2L][8L])
{

  if (update_model)
    {

      ::load_model(U_in, mu_in, B_in);

    }

  else
    {

      ::predict(features, predictions);

    }

}

 void end_acc_task(axiStream_t& stream, uint32_t destId) {
__mcxx_instrEnd();
	uint64_t data = accID;
	data = (data << 56) | (__mcxx_taskId & 0x00FFFFFFFFFFFFFF);
	write_stream(stream, data, destId, 1);
}
void predict_or_update_model_hls_automatic_mcxx_wrapper(axiStream_t& inStream, axiStream_t& outStream, ::F_base *mcxx_features, ::P_base *mcxx_predictions_i, ::P_base *mcxx_predictions_o, ::U_base (*mcxx_U_in)[4L][8L], ::mu_base (*mcxx_mu_in)[8L], ::B_base (*mcxx_B_in)[2L][8L]) {
#pragma HLS INTERFACE ap_ctrl_none port=return
#pragma HLS INTERFACE axis port=inStream
#pragma HLS INTERFACE axis port=outStream
#pragma HLS INTERFACE m_axi port=mcxx_data
#pragma HLS INTERFACE m_axi port=mcxx_features
#pragma HLS INTERFACE m_axi port=mcxx_predictions_i
#pragma HLS INTERFACE m_axi port=mcxx_predictions_o
#pragma HLS INTERFACE m_axi port=mcxx_U_in
#pragma HLS INTERFACE m_axi port=mcxx_mu_in
#pragma HLS INTERFACE m_axi port=mcxx_B_in

	static ::F_base features[1];
	static ::P_base predictions[1];
	bool update_model;
	::U_base (*U_in)[4L][8L];
	::mu_base (*mu_in)[8L];
	::B_base (*B_in)[2L][8L];
	counter_t  __counter_reg[4] = {
0xA, 0xBAD, 0xC0FFE, 0xDEAD}
;
	unsigned int __i;
	uint64_t __accHeader;
	ap_uint<8> __copyFlags, __destID;
	uint32_t __comp_needed;
	unsigned long long __param, __copyFlags_id;
	unsigned int __param_id, __n_params_in, __n_params_out;
	uint64_t __bufferData;
	unsigned long long __copyFlags_id_out[1];
	unsigned long long __param_out[1];

	__mcxx_taskId = inStream.read().data;
	__mcxx_instrCounter = inStream.read().data;
	__bufferData = inStream.read().data;
	__accHeader = inStream.read().data;
	__comp_needed = __accHeader;
	__destID = __accHeader>>32;
	__mcxx_instrBuffer = __bufferData & ((1ULL<<48)-1);
	__mcxx_instrSlots =__bufferData >> 48;
	__mcxx_instrNumOverflow = 0;
	__mcxx_instrCurrentSlot = 0;

	nanos_instrument_burst_begin(77, __mcxx_taskId);

	for (__i = 0;
 __i < 6;
 __i++) {
		__copyFlags_id = inStream.read().data;
		__copyFlags = __copyFlags_id;
		__param_id = __copyFlags_id >> 32;
		switch (__param_id) {
			case 0:
				__param = inStream.read().data;
				if(__copyFlags[4])
					memcpy(features, (const ::F_base *)(mcxx_features + __param/sizeof(::F_base)), ( 1 )*sizeof(::F_base));
				break;
			case 1:
				__param = inStream.read().data;
				if(__copyFlags[4])
					memcpy(predictions, (const ::P_base *)(mcxx_predictions_i + __param/sizeof(::P_base)), ( 1 )*sizeof(::P_base));
				__copyFlags_id_out[0] = __copyFlags_id;
				__param_out[0] = __param;
				break;
			case 2:
				union {
					bool update_model;
					uint64_t update_model_task_arg;
				}
 mcc_arg_2;
				mcc_arg_2.update_model_task_arg = inStream.read().data;
				update_model = mcc_arg_2.update_model;
				break;
			case 3:
				__param = inStream.read().data;
				U_in = (::U_base (*)[4L][8L])(mcxx_U_in + __param/sizeof(::U_base [4L][8L]));
				break;
			case 4:
				__param = inStream.read().data;
				mu_in = (::mu_base (*)[8L])(mcxx_mu_in + __param/sizeof(::mu_base [8L]));
				break;
			case 5:
				__param = inStream.read().data;
				B_in = (::B_base (*)[2L][8L])(mcxx_B_in + __param/sizeof(::B_base [2L][8L]));
				break;
			default:;
		}
	}

nanos_instrument_burst_end(77, __mcxx_taskId);
nanos_instrument_burst_begin(79, __mcxx_taskId);

	if (__comp_needed) {

		predict_or_update_model(features, predictions, update_model, U_in, mu_in, B_in);
	}
nanos_instrument_burst_end(79, __mcxx_taskId);
nanos_instrument_burst_begin(78, __mcxx_taskId);

	for (__i = 0;
 __i < (1);
 __i++) {
		__copyFlags_id = __copyFlags_id_out[__i];
		__copyFlags = __copyFlags_id;
 		__param_id = __copyFlags_id >> 32;
		__param = __param_out[__i];
		switch (__param_id) {
			case 1:
				if(__copyFlags[5])
					memcpy(mcxx_predictions_o + __param/sizeof(::P_base), (const ::P_base *)predictions, ( 1 )*sizeof(::P_base));
				break;
			default:;
		}
	}

nanos_instrument_burst_end(78, __mcxx_taskId);

	end_task: {
	#pragma HLS PROTOCOL fixed
		end_acc_task(outStream, __destID);
	}
 
}
